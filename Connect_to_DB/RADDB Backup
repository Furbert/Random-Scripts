create database "RADDB"
    with owner postgres;

create sequence _timescaledb_catalog.chunk_constraint_name;

alter sequence _timescaledb_catalog.chunk_constraint_name owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bool is 'boolean, ''true''/''false''';

alter type pg_catalog.bool owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bytea is 'variable-length string, binary values escaped';

alter type pg_catalog.bytea owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.char is 'single character';

alter type pg_catalog.char owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.name is '63-byte type for storing system identifiers';

alter type pg_catalog.name owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int8 is '~18 digit integer, 8-byte storage';

alter type pg_catalog.int8 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int2 is '-32 thousand to 32 thousand, 2-byte storage';

alter type pg_catalog.int2 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.int4 is '-2 billion to 2 billion integer, 4-byte storage';

alter type pg_catalog.int4 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regproc is 'registered procedure';

alter type pg_catalog.regproc owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.text is 'variable-length string, no limit specified';

alter type pg_catalog.text owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.oid is 'object identifier(oid), maximum 4 billion';

alter type pg_catalog.oid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tid is '(block, offset), physical location of tuple';

alter type pg_catalog.tid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.xid is 'transaction id';

alter type pg_catalog.xid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.cid is 'command identifier type, sequence in transaction id';

alter type pg_catalog.cid owner to postgres;

-- Unknown how to generate base type type

alter type pg_catalog.json owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.xml is 'XML content';

alter type pg_catalog.xml owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_node_tree is 'string representing an internal node tree';

alter type pg_catalog.pg_node_tree owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.smgr is 'storage manager';

alter type pg_catalog.smgr owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.point is 'geometric point ''(x, y)''';

alter type pg_catalog.point owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.lseg is 'geometric line segment ''(pt1,pt2)''';

alter type pg_catalog.lseg owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.path is 'geometric path ''(pt1,...)''';

alter type pg_catalog.path owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.box is 'geometric box ''(lower left,upper right)''';

alter type pg_catalog.box owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.polygon is 'geometric polygon ''(pt1,...)''';

alter type pg_catalog.polygon owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.line is 'geometric line';

alter type pg_catalog.line owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.cidr is 'network IP address/netmask, network address';

alter type pg_catalog.cidr owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.float4 is 'single-precision floating point number, 4-byte storage';

alter type pg_catalog.float4 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.float8 is 'double-precision floating point number, 8-byte storage';

alter type pg_catalog.float8 owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.abstime is 'absolute, limited-range date and time (Unix system time)';

alter type pg_catalog.abstime owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.reltime is 'relative, limited-range time interval (Unix delta time)';

alter type pg_catalog.reltime owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tinterval is '(abstime,abstime), time interval';

alter type pg_catalog.tinterval owner to postgres;

-- Unknown how to generate base type type

alter type pg_catalog.unknown owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.circle is 'geometric circle ''(center,radius)''';

alter type pg_catalog.circle owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.money is 'monetary amounts, $d,ddd.cc';

alter type pg_catalog.money owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr is 'XX:XX:XX:XX:XX:XX, MAC address';

alter type pg_catalog.macaddr owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.inet is 'IP address/netmask, host address, netmask optional';

alter type pg_catalog.inet owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.aclitem is 'access control list';

alter type pg_catalog.aclitem owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bpchar is 'char(length), blank-padded string, fixed storage length';

alter type pg_catalog.bpchar owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.varchar is 'varchar(length), non-blank-padded string, variable storage length';

alter type pg_catalog.varchar owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.date is 'date';

alter type pg_catalog.date owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.time is 'time of day';

alter type pg_catalog.time owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timestamp is 'date and time';

alter type pg_catalog.timestamp owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timestamptz is 'date and time with time zone';

alter type pg_catalog.timestamptz owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.interval is '@ <number> <units>, time interval';

alter type pg_catalog.interval owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.timetz is 'time of day with time zone';

alter type pg_catalog.timetz owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.bit is 'fixed-length bit string';

alter type pg_catalog.bit owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.varbit is 'variable-length bit string';

alter type pg_catalog.varbit owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.numeric is 'numeric(precision, decimal), arbitrary precision number';

alter type pg_catalog.numeric owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.refcursor is 'reference to cursor (portal name)';

alter type pg_catalog.refcursor owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regprocedure is 'registered procedure (with args)';

alter type pg_catalog.regprocedure owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regoper is 'registered operator';

alter type pg_catalog.regoper owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regoperator is 'registered operator (with args)';

alter type pg_catalog.regoperator owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regclass is 'registered class';

alter type pg_catalog.regclass owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regtype is 'registered type';

alter type pg_catalog.regtype owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.uuid is 'UUID datatype';

alter type pg_catalog.uuid owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.txid_snapshot is 'txid snapshot';

alter type pg_catalog.txid_snapshot owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.pg_lsn is 'PostgreSQL LSN datatype';

alter type pg_catalog.pg_lsn owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tsvector is 'text representation for text search';

alter type pg_catalog.tsvector owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.tsquery is 'query representation for text search';

alter type pg_catalog.tsquery owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.gtsvector is 'GiST index internal text representation for text search';

alter type pg_catalog.gtsvector owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regconfig is 'registered text search configuration';

alter type pg_catalog.regconfig owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regdictionary is 'registered text search dictionary';

alter type pg_catalog.regdictionary owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.jsonb is 'Binary JSON';

alter type pg_catalog.jsonb owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regnamespace is 'registered namespace';

alter type pg_catalog.regnamespace owner to postgres;

-- Unknown how to generate base type type

comment on type pg_catalog.regrole is 'registered role';

alter type pg_catalog.regrole owner to postgres;

create domain information_schema.cardinal_number as integer
    constraint cardinal_number_domain_check check (VALUE >= 0);

alter domain information_schema.cardinal_number owner to postgres;

create domain information_schema.character_data as varchar;

alter domain information_schema.character_data owner to postgres;

create domain information_schema.sql_identifier as varchar;

alter domain information_schema.sql_identifier owner to postgres;

create domain information_schema.time_stamp as timestamp(2) with time zone
    default ('now'::text)::timestamp(2) with time zone;

alter domain information_schema.time_stamp owner to postgres;

create domain information_schema.yes_or_no as varchar(3)
    constraint yes_or_no_check check ((VALUE)::text = ANY
                                      ((ARRAY ['YES'::character varying, 'NO'::character varying])::text[]));

alter domain information_schema.yes_or_no owner to postgres;

create table pg_catalog.pg_default_acl
(
    defaclrole      oid    not null,
    defaclnamespace oid    not null,
    defaclobjtype   "char" not null,
    defaclacl       aclitem[]
);

alter table pg_catalog.pg_default_acl
    owner to postgres;

create unique index pg_default_acl_role_nsp_obj_index
    on pg_catalog.pg_default_acl (defaclrole, defaclnamespace, defaclobjtype);

create unique index pg_default_acl_oid_index
    on pg_catalog.pg_default_acl (oid);

create table pg_catalog.pg_pltemplate
(
    tmplname      name    not null,
    tmpltrusted   boolean not null,
    tmpldbacreate boolean not null,
    tmplhandler   text    not null,
    tmplinline    text,
    tmplvalidator text,
    tmpllibrary   text    not null,
    tmplacl       aclitem[]
);

alter table pg_catalog.pg_pltemplate
    owner to postgres;

create unique index pg_pltemplate_name_index
    on pg_catalog.pg_pltemplate (tmplname);

create table pg_catalog.pg_tablespace
(
    spcname    name not null,
    spcowner   oid  not null,
    spcacl     aclitem[],
    spcoptions text[]
);

alter table pg_catalog.pg_tablespace
    owner to postgres;

create unique index pg_tablespace_oid_index
    on pg_catalog.pg_tablespace (oid);

create unique index pg_tablespace_spcname_index
    on pg_catalog.pg_tablespace (spcname);

create table pg_catalog.pg_shdepend
(
    dbid       oid     not null,
    classid    oid     not null,
    objid      oid     not null,
    objsubid   integer not null,
    refclassid oid     not null,
    refobjid   oid     not null,
    deptype    "char"  not null
);

alter table pg_catalog.pg_shdepend
    owner to postgres;

create index pg_shdepend_depender_index
    on pg_catalog.pg_shdepend (dbid, classid, objid, objsubid);

create index pg_shdepend_reference_index
    on pg_catalog.pg_shdepend (refclassid, refobjid);

create table pg_catalog.pg_type
(
    typname        name     not null,
    typnamespace   oid      not null,
    typowner       oid      not null,
    typlen         smallint not null,
    typbyval       boolean  not null,
    typtype        "char"   not null,
    typcategory    "char"   not null,
    typispreferred boolean  not null,
    typisdefined   boolean  not null,
    typdelim       "char"   not null,
    typrelid       oid      not null,
    typelem        oid      not null,
    typarray       oid      not null,
    typinput       regproc  not null,
    typoutput      regproc  not null,
    typreceive     regproc  not null,
    typsend        regproc  not null,
    typmodin       regproc  not null,
    typmodout      regproc  not null,
    typanalyze     regproc  not null,
    typalign       "char"   not null,
    typstorage     "char"   not null,
    typnotnull     boolean  not null,
    typbasetype    oid      not null,
    typtypmod      integer  not null,
    typndims       integer  not null,
    typcollation   oid      not null,
    typdefaultbin  pg_node_tree,
    typdefault     text,
    typacl         aclitem[]
);

alter table pg_catalog.pg_type
    owner to postgres;

create unique index pg_type_oid_index
    on pg_catalog.pg_type (oid);

create unique index pg_type_typname_nsp_index
    on pg_catalog.pg_type (typname, typnamespace);

create table pg_catalog.pg_attribute
(
    attrelid      oid      not null,
    attname       name     not null,
    atttypid      oid      not null,
    attstattarget integer  not null,
    attlen        smallint not null,
    attnum        smallint not null,
    attndims      integer  not null,
    attcacheoff   integer  not null,
    atttypmod     integer  not null,
    attbyval      boolean  not null,
    attstorage    "char"   not null,
    attalign      "char"   not null,
    attnotnull    boolean  not null,
    atthasdef     boolean  not null,
    attisdropped  boolean  not null,
    attislocal    boolean  not null,
    attinhcount   integer  not null,
    attcollation  oid      not null,
    attacl        aclitem[],
    attoptions    text[],
    attfdwoptions text[]
);

alter table pg_catalog.pg_attribute
    owner to postgres;

create unique index pg_attribute_relid_attnam_index
    on pg_catalog.pg_attribute (attrelid, attname);

create unique index pg_attribute_relid_attnum_index
    on pg_catalog.pg_attribute (attrelid, attnum);

create table pg_catalog.pg_proc
(
    proname         name      not null,
    pronamespace    oid       not null,
    proowner        oid       not null,
    prolang         oid       not null,
    procost         real      not null,
    prorows         real      not null,
    provariadic     oid       not null,
    protransform    regproc   not null,
    proisagg        boolean   not null,
    proiswindow     boolean   not null,
    prosecdef       boolean   not null,
    proleakproof    boolean   not null,
    proisstrict     boolean   not null,
    proretset       boolean   not null,
    provolatile     "char"    not null,
    proparallel     "char"    not null,
    pronargs        smallint  not null,
    pronargdefaults smallint  not null,
    prorettype      oid       not null,
    proargtypes     oidvector not null,
    proallargtypes  oid[],
    proargmodes     "char"[],
    proargnames     text[],
    proargdefaults  pg_node_tree,
    protrftypes     oid[],
    prosrc          text      not null,
    probin          text,
    proconfig       text[],
    proacl          aclitem[]
);

alter table pg_catalog.pg_proc
    owner to postgres;

create unique index pg_proc_oid_index
    on pg_catalog.pg_proc (oid);

create unique index pg_proc_proname_args_nsp_index
    on pg_catalog.pg_proc (proname, proargtypes, pronamespace);

create table pg_catalog.pg_class
(
    relname             name     not null,
    relnamespace        oid      not null,
    reltype             oid      not null,
    reloftype           oid      not null,
    relowner            oid      not null,
    relam               oid      not null,
    relfilenode         oid      not null,
    reltablespace       oid      not null,
    relpages            integer  not null,
    reltuples           real     not null,
    relallvisible       integer  not null,
    reltoastrelid       oid      not null,
    relhasindex         boolean  not null,
    relisshared         boolean  not null,
    relpersistence      "char"   not null,
    relkind             "char"   not null,
    relnatts            smallint not null,
    relchecks           smallint not null,
    relhasoids          boolean  not null,
    relhaspkey          boolean  not null,
    relhasrules         boolean  not null,
    relhastriggers      boolean  not null,
    relhassubclass      boolean  not null,
    relrowsecurity      boolean  not null,
    relforcerowsecurity boolean  not null,
    relispopulated      boolean  not null,
    relreplident        "char"   not null,
    relfrozenxid        xid      not null,
    relminmxid          xid      not null,
    relacl              aclitem[],
    reloptions          text[]
);

alter table pg_catalog.pg_class
    owner to postgres;

create unique index pg_class_oid_index
    on pg_catalog.pg_class (oid);

create unique index pg_class_relname_nsp_index
    on pg_catalog.pg_class (relname, relnamespace);

create index pg_class_tblspc_relfilenode_index
    on pg_catalog.pg_class (reltablespace, relfilenode);

create table pg_catalog.pg_authid
(
    rolname        name    not null,
    rolsuper       boolean not null,
    rolinherit     boolean not null,
    rolcreaterole  boolean not null,
    rolcreatedb    boolean not null,
    rolcanlogin    boolean not null,
    rolreplication boolean not null,
    rolbypassrls   boolean not null,
    rolconnlimit   integer not null,
    rolpassword    text,
    rolvaliduntil  timestamp with time zone
);

alter table pg_catalog.pg_authid
    owner to postgres;

create unique index pg_authid_rolname_index
    on pg_catalog.pg_authid (rolname);

create unique index pg_authid_oid_index
    on pg_catalog.pg_authid (oid);

create table pg_catalog.pg_auth_members
(
    roleid       oid     not null,
    member       oid     not null,
    grantor      oid     not null,
    admin_option boolean not null
);

alter table pg_catalog.pg_auth_members
    owner to postgres;

create unique index pg_auth_members_role_member_index
    on pg_catalog.pg_auth_members (roleid, member);

create unique index pg_auth_members_member_role_index
    on pg_catalog.pg_auth_members (member, roleid);

create table pg_catalog.pg_database
(
    datname       name    not null,
    datdba        oid     not null,
    encoding      integer not null,
    datcollate    name    not null,
    datctype      name    not null,
    datistemplate boolean not null,
    datallowconn  boolean not null,
    datconnlimit  integer not null,
    datlastsysoid oid     not null,
    datfrozenxid  xid     not null,
    datminmxid    xid     not null,
    dattablespace oid     not null,
    datacl        aclitem[]
);

alter table pg_catalog.pg_database
    owner to postgres;

create unique index pg_database_datname_index
    on pg_catalog.pg_database (datname);

create unique index pg_database_oid_index
    on pg_catalog.pg_database (oid);

create table pg_catalog.pg_foreign_server
(
    srvname    name not null,
    srvowner   oid  not null,
    srvfdw     oid  not null,
    srvtype    text,
    srvversion text,
    srvacl     aclitem[],
    srvoptions text[]
);

alter table pg_catalog.pg_foreign_server
    owner to postgres;

create unique index pg_foreign_server_oid_index
    on pg_catalog.pg_foreign_server (oid);

create unique index pg_foreign_server_name_index
    on pg_catalog.pg_foreign_server (srvname);

create table pg_catalog.pg_user_mapping
(
    umuser    oid not null,
    umserver  oid not null,
    umoptions text[]
);

alter table pg_catalog.pg_user_mapping
    owner to postgres;

create unique index pg_user_mapping_oid_index
    on pg_catalog.pg_user_mapping (oid);

create unique index pg_user_mapping_user_server_index
    on pg_catalog.pg_user_mapping (umuser, umserver);

create table pg_catalog.pg_foreign_data_wrapper
(
    fdwname      name not null,
    fdwowner     oid  not null,
    fdwhandler   oid  not null,
    fdwvalidator oid  not null,
    fdwacl       aclitem[],
    fdwoptions   text[]
);

alter table pg_catalog.pg_foreign_data_wrapper
    owner to postgres;

create unique index pg_foreign_data_wrapper_oid_index
    on pg_catalog.pg_foreign_data_wrapper (oid);

create unique index pg_foreign_data_wrapper_name_index
    on pg_catalog.pg_foreign_data_wrapper (fdwname);

create table pg_catalog.pg_shdescription
(
    objoid      oid  not null,
    classoid    oid  not null,
    description text not null
);

alter table pg_catalog.pg_shdescription
    owner to postgres;

create unique index pg_shdescription_o_c_index
    on pg_catalog.pg_shdescription (objoid, classoid);

create table pg_catalog.pg_aggregate
(
    aggfnoid         regproc  not null,
    aggkind          "char"   not null,
    aggnumdirectargs smallint not null,
    aggtransfn       regproc  not null,
    aggfinalfn       regproc  not null,
    aggcombinefn     regproc  not null,
    aggserialfn      regproc  not null,
    aggdeserialfn    regproc  not null,
    aggmtransfn      regproc  not null,
    aggminvtransfn   regproc  not null,
    aggmfinalfn      regproc  not null,
    aggfinalextra    boolean  not null,
    aggmfinalextra   boolean  not null,
    aggsortop        oid      not null,
    aggtranstype     oid      not null,
    aggtransspace    integer  not null,
    aggmtranstype    oid      not null,
    aggmtransspace   integer  not null,
    agginitval       text,
    aggminitval      text
);

alter table pg_catalog.pg_aggregate
    owner to postgres;

create unique index pg_aggregate_fnoid_index
    on pg_catalog.pg_aggregate (aggfnoid);

create table pg_catalog.pg_am
(
    amname    name    not null,
    amhandler regproc not null,
    amtype    "char"  not null
);

alter table pg_catalog.pg_am
    owner to postgres;

create unique index pg_am_name_index
    on pg_catalog.pg_am (amname);

create unique index pg_am_oid_index
    on pg_catalog.pg_am (oid);

create table pg_catalog.pg_amop
(
    amopfamily     oid      not null,
    amoplefttype   oid      not null,
    amoprighttype  oid      not null,
    amopstrategy   smallint not null,
    amoppurpose    "char"   not null,
    amopopr        oid      not null,
    amopmethod     oid      not null,
    amopsortfamily oid      not null
);

alter table pg_catalog.pg_amop
    owner to postgres;

create unique index pg_amop_fam_strat_index
    on pg_catalog.pg_amop (amopfamily, amoplefttype, amoprighttype, amopstrategy);

create unique index pg_amop_opr_fam_index
    on pg_catalog.pg_amop (amopopr, amoppurpose, amopfamily);

create unique index pg_amop_oid_index
    on pg_catalog.pg_amop (oid);

create table pg_catalog.pg_amproc
(
    amprocfamily    oid      not null,
    amproclefttype  oid      not null,
    amprocrighttype oid      not null,
    amprocnum       smallint not null,
    amproc          regproc  not null
);

alter table pg_catalog.pg_amproc
    owner to postgres;

create unique index pg_amproc_fam_proc_index
    on pg_catalog.pg_amproc (amprocfamily, amproclefttype, amprocrighttype, amprocnum);

create unique index pg_amproc_oid_index
    on pg_catalog.pg_amproc (oid);

create table pg_catalog.pg_attrdef
(
    adrelid oid      not null,
    adnum   smallint not null,
    adbin   pg_node_tree,
    adsrc   text
);

alter table pg_catalog.pg_attrdef
    owner to postgres;

create unique index pg_attrdef_adrelid_adnum_index
    on pg_catalog.pg_attrdef (adrelid, adnum);

create unique index pg_attrdef_oid_index
    on pg_catalog.pg_attrdef (oid);

create table pg_catalog.pg_cast
(
    castsource  oid    not null,
    casttarget  oid    not null,
    castfunc    oid    not null,
    castcontext "char" not null,
    castmethod  "char" not null
);

alter table pg_catalog.pg_cast
    owner to postgres;

create unique index pg_cast_oid_index
    on pg_catalog.pg_cast (oid);

create unique index pg_cast_source_target_index
    on pg_catalog.pg_cast (castsource, casttarget);

create table pg_catalog.pg_constraint
(
    conname       name    not null,
    connamespace  oid     not null,
    contype       "char"  not null,
    condeferrable boolean not null,
    condeferred   boolean not null,
    convalidated  boolean not null,
    conrelid      oid     not null,
    contypid      oid     not null,
    conindid      oid     not null,
    confrelid     oid     not null,
    confupdtype   "char"  not null,
    confdeltype   "char"  not null,
    confmatchtype "char"  not null,
    conislocal    boolean not null,
    coninhcount   integer not null,
    connoinherit  boolean not null,
    conkey        smallint[],
    confkey       smallint[],
    conpfeqop     oid[],
    conppeqop     oid[],
    conffeqop     oid[],
    conexclop     oid[],
    conbin        pg_node_tree,
    consrc        text
);

alter table pg_catalog.pg_constraint
    owner to postgres;

create index pg_constraint_conname_nsp_index
    on pg_catalog.pg_constraint (conname, connamespace);

create index pg_constraint_conrelid_index
    on pg_catalog.pg_constraint (conrelid);

create index pg_constraint_contypid_index
    on pg_catalog.pg_constraint (contypid);

create unique index pg_constraint_oid_index
    on pg_catalog.pg_constraint (oid);

create table pg_catalog.pg_conversion
(
    conname        name    not null,
    connamespace   oid     not null,
    conowner       oid     not null,
    conforencoding integer not null,
    contoencoding  integer not null,
    conproc        regproc not null,
    condefault     boolean not null
);

alter table pg_catalog.pg_conversion
    owner to postgres;

create unique index pg_conversion_default_index
    on pg_catalog.pg_conversion (connamespace, conforencoding, contoencoding, oid);

create unique index pg_conversion_name_nsp_index
    on pg_catalog.pg_conversion (conname, connamespace);

create unique index pg_conversion_oid_index
    on pg_catalog.pg_conversion (oid);

create table pg_catalog.pg_depend
(
    classid     oid     not null,
    objid       oid     not null,
    objsubid    integer not null,
    refclassid  oid     not null,
    refobjid    oid     not null,
    refobjsubid integer not null,
    deptype     "char"  not null
);

alter table pg_catalog.pg_depend
    owner to postgres;

create index pg_depend_depender_index
    on pg_catalog.pg_depend (classid, objid, objsubid);

create index pg_depend_reference_index
    on pg_catalog.pg_depend (refclassid, refobjid, refobjsubid);

create table pg_catalog.pg_description
(
    objoid      oid     not null,
    classoid    oid     not null,
    objsubid    integer not null,
    description text    not null
);

alter table pg_catalog.pg_description
    owner to postgres;

create unique index pg_description_o_c_o_index
    on pg_catalog.pg_description (objoid, classoid, objsubid);

create table pg_catalog.pg_index
(
    indexrelid     oid        not null,
    indrelid       oid        not null,
    indnatts       smallint   not null,
    indisunique    boolean    not null,
    indisprimary   boolean    not null,
    indisexclusion boolean    not null,
    indimmediate   boolean    not null,
    indisclustered boolean    not null,
    indisvalid     boolean    not null,
    indcheckxmin   boolean    not null,
    indisready     boolean    not null,
    indislive      boolean    not null,
    indisreplident boolean    not null,
    indkey         int2vector not null,
    indcollation   oidvector  not null,
    indclass       oidvector  not null,
    indoption      int2vector not null,
    indexprs       pg_node_tree,
    indpred        pg_node_tree
);

alter table pg_catalog.pg_index
    owner to postgres;

create index pg_index_indrelid_index
    on pg_catalog.pg_index (indrelid);

create unique index pg_index_indexrelid_index
    on pg_catalog.pg_index (indexrelid);

create table pg_catalog.pg_inherits
(
    inhrelid  oid     not null,
    inhparent oid     not null,
    inhseqno  integer not null
);

alter table pg_catalog.pg_inherits
    owner to postgres;

create index pg_inherits_parent_index
    on pg_catalog.pg_inherits (inhparent);

create unique index pg_inherits_relid_seqno_index
    on pg_catalog.pg_inherits (inhrelid, inhseqno);

create table pg_catalog.pg_language
(
    lanname       name    not null,
    lanowner      oid     not null,
    lanispl       boolean not null,
    lanpltrusted  boolean not null,
    lanplcallfoid oid     not null,
    laninline     oid     not null,
    lanvalidator  oid     not null,
    lanacl        aclitem[]
);

alter table pg_catalog.pg_language
    owner to postgres;

create unique index pg_language_name_index
    on pg_catalog.pg_language (lanname);

create unique index pg_language_oid_index
    on pg_catalog.pg_language (oid);

create table pg_catalog.pg_largeobject
(
    loid   oid     not null,
    pageno integer not null,
    data   bytea   not null
);

alter table pg_catalog.pg_largeobject
    owner to postgres;

create unique index pg_largeobject_loid_pn_index
    on pg_catalog.pg_largeobject (loid, pageno);

create table pg_catalog.pg_namespace
(
    nspname  name not null,
    nspowner oid  not null,
    nspacl   aclitem[]
);

alter table pg_catalog.pg_namespace
    owner to postgres;

create unique index pg_namespace_nspname_index
    on pg_catalog.pg_namespace (nspname);

create unique index pg_namespace_oid_index
    on pg_catalog.pg_namespace (oid);

create table pg_catalog.pg_opclass
(
    opcmethod    oid     not null,
    opcname      name    not null,
    opcnamespace oid     not null,
    opcowner     oid     not null,
    opcfamily    oid     not null,
    opcintype    oid     not null,
    opcdefault   boolean not null,
    opckeytype   oid     not null
);

alter table pg_catalog.pg_opclass
    owner to postgres;

create unique index pg_opclass_am_name_nsp_index
    on pg_catalog.pg_opclass (opcmethod, opcname, opcnamespace);

create unique index pg_opclass_oid_index
    on pg_catalog.pg_opclass (oid);

create table pg_catalog.pg_operator
(
    oprname      name    not null,
    oprnamespace oid     not null,
    oprowner     oid     not null,
    oprkind      "char"  not null,
    oprcanmerge  boolean not null,
    oprcanhash   boolean not null,
    oprleft      oid     not null,
    oprright     oid     not null,
    oprresult    oid     not null,
    oprcom       oid     not null,
    oprnegate    oid     not null,
    oprcode      regproc not null,
    oprrest      regproc not null,
    oprjoin      regproc not null
);

alter table pg_catalog.pg_operator
    owner to postgres;

create unique index pg_operator_oid_index
    on pg_catalog.pg_operator (oid);

create unique index pg_operator_oprname_l_r_n_index
    on pg_catalog.pg_operator (oprname, oprleft, oprright, oprnamespace);

create table pg_catalog.pg_rewrite
(
    rulename   name    not null,
    ev_class   oid     not null,
    ev_type    "char"  not null,
    ev_enabled "char"  not null,
    is_instead boolean not null,
    ev_qual    pg_node_tree,
    ev_action  pg_node_tree
);

alter table pg_catalog.pg_rewrite
    owner to postgres;

create unique index pg_rewrite_oid_index
    on pg_catalog.pg_rewrite (oid);

create unique index pg_rewrite_rel_rulename_index
    on pg_catalog.pg_rewrite (ev_class, rulename);

create table pg_catalog.pg_statistic
(
    starelid    oid      not null,
    staattnum   smallint not null,
    stainherit  boolean  not null,
    stanullfrac real     not null,
    stawidth    integer  not null,
    stadistinct real     not null,
    stakind1    smallint not null,
    stakind2    smallint not null,
    stakind3    smallint not null,
    stakind4    smallint not null,
    stakind5    smallint not null,
    staop1      oid      not null,
    staop2      oid      not null,
    staop3      oid      not null,
    staop4      oid      not null,
    staop5      oid      not null,
    stanumbers1 real[],
    stanumbers2 real[],
    stanumbers3 real[],
    stanumbers4 real[],
    stanumbers5 real[],
    stavalues1  anyarray,
    stavalues2  anyarray,
    stavalues3  anyarray,
    stavalues4  anyarray,
    stavalues5  anyarray
);

alter table pg_catalog.pg_statistic
    owner to postgres;

create unique index pg_statistic_relid_att_inh_index
    on pg_catalog.pg_statistic (starelid, staattnum, stainherit);

create table pg_catalog.pg_trigger
(
    tgrelid        oid        not null,
    tgname         name       not null,
    tgfoid         oid        not null,
    tgtype         smallint   not null,
    tgenabled      "char"     not null,
    tgisinternal   boolean    not null,
    tgconstrrelid  oid        not null,
    tgconstrindid  oid        not null,
    tgconstraint   oid        not null,
    tgdeferrable   boolean    not null,
    tginitdeferred boolean    not null,
    tgnargs        smallint   not null,
    tgattr         int2vector not null,
    tgargs         bytea      not null,
    tgqual         pg_node_tree
);

alter table pg_catalog.pg_trigger
    owner to postgres;

create index pg_trigger_tgconstraint_index
    on pg_catalog.pg_trigger (tgconstraint);

create unique index pg_trigger_tgrelid_tgname_index
    on pg_catalog.pg_trigger (tgrelid, tgname);

create unique index pg_trigger_oid_index
    on pg_catalog.pg_trigger (oid);

create table pg_catalog.pg_opfamily
(
    opfmethod    oid  not null,
    opfname      name not null,
    opfnamespace oid  not null,
    opfowner     oid  not null
);

alter table pg_catalog.pg_opfamily
    owner to postgres;

create unique index pg_opfamily_am_name_nsp_index
    on pg_catalog.pg_opfamily (opfmethod, opfname, opfnamespace);

create unique index pg_opfamily_oid_index
    on pg_catalog.pg_opfamily (oid);

create table pg_catalog.pg_db_role_setting
(
    setdatabase oid not null,
    setrole     oid not null,
    setconfig   text[]
);

alter table pg_catalog.pg_db_role_setting
    owner to postgres;

create unique index pg_db_role_setting_databaseid_rol_index
    on pg_catalog.pg_db_role_setting (setdatabase, setrole);

create table pg_catalog.pg_largeobject_metadata
(
    lomowner oid not null,
    lomacl   aclitem[]
);

alter table pg_catalog.pg_largeobject_metadata
    owner to postgres;

create unique index pg_largeobject_metadata_oid_index
    on pg_catalog.pg_largeobject_metadata (oid);

create table pg_catalog.pg_extension
(
    extname        name    not null,
    extowner       oid     not null,
    extnamespace   oid     not null,
    extrelocatable boolean not null,
    extversion     text    not null,
    extconfig      oid[],
    extcondition   text[]
);

alter table pg_catalog.pg_extension
    owner to postgres;

create unique index pg_extension_oid_index
    on pg_catalog.pg_extension (oid);

create unique index pg_extension_name_index
    on pg_catalog.pg_extension (extname);

create table pg_catalog.pg_foreign_table
(
    ftrelid   oid not null,
    ftserver  oid not null,
    ftoptions text[]
);

alter table pg_catalog.pg_foreign_table
    owner to postgres;

create unique index pg_foreign_table_relid_index
    on pg_catalog.pg_foreign_table (ftrelid);

create table pg_catalog.pg_policy
(
    polname      name   not null,
    polrelid     oid    not null,
    polcmd       "char" not null,
    polroles     oid[],
    polqual      pg_node_tree,
    polwithcheck pg_node_tree
);

alter table pg_catalog.pg_policy
    owner to postgres;

create unique index pg_policy_oid_index
    on pg_catalog.pg_policy (oid);

create unique index pg_policy_polrelid_polname_index
    on pg_catalog.pg_policy (polrelid, polname);

create table pg_catalog.pg_init_privs
(
    objoid    oid       not null,
    classoid  oid       not null,
    objsubid  integer   not null,
    privtype  "char"    not null,
    initprivs aclitem[] not null
);

alter table pg_catalog.pg_init_privs
    owner to postgres;

create unique index pg_init_privs_o_c_o_index
    on pg_catalog.pg_init_privs (objoid, classoid, objsubid);

create table pg_catalog.pg_collation
(
    collname      name    not null,
    collnamespace oid     not null,
    collowner     oid     not null,
    collencoding  integer not null,
    collcollate   name    not null,
    collctype     name    not null
);

alter table pg_catalog.pg_collation
    owner to postgres;

create unique index pg_collation_oid_index
    on pg_catalog.pg_collation (oid);

create unique index pg_collation_name_enc_nsp_index
    on pg_catalog.pg_collation (collname, collencoding, collnamespace);

create table pg_catalog.pg_event_trigger
(
    evtname    name   not null,
    evtevent   name   not null,
    evtowner   oid    not null,
    evtfoid    oid    not null,
    evtenabled "char" not null,
    evttags    text[]
);

alter table pg_catalog.pg_event_trigger
    owner to postgres;

create unique index pg_event_trigger_evtname_index
    on pg_catalog.pg_event_trigger (evtname);

create unique index pg_event_trigger_oid_index
    on pg_catalog.pg_event_trigger (oid);

create table pg_catalog.pg_enum
(
    enumtypid     oid  not null,
    enumsortorder real not null,
    enumlabel     name not null
);

alter table pg_catalog.pg_enum
    owner to postgres;

create unique index pg_enum_oid_index
    on pg_catalog.pg_enum (oid);

create unique index pg_enum_typid_label_index
    on pg_catalog.pg_enum (enumtypid, enumlabel);

create unique index pg_enum_typid_sortorder_index
    on pg_catalog.pg_enum (enumtypid, enumsortorder);

create table pg_catalog.pg_range
(
    rngtypid     oid     not null,
    rngsubtype   oid     not null,
    rngcollation oid     not null,
    rngsubopc    oid     not null,
    rngcanonical regproc not null,
    rngsubdiff   regproc not null
);

alter table pg_catalog.pg_range
    owner to postgres;

create unique index pg_range_rngtypid_index
    on pg_catalog.pg_range (rngtypid);

create table pg_catalog.pg_transform
(
    trftype    oid     not null,
    trflang    oid     not null,
    trffromsql regproc not null,
    trftosql   regproc not null
);

alter table pg_catalog.pg_transform
    owner to postgres;

create unique index pg_transform_oid_index
    on pg_catalog.pg_transform (oid);

create unique index pg_transform_type_lang_index
    on pg_catalog.pg_transform (trftype, trflang);

create table pg_catalog.pg_shseclabel
(
    objoid   oid  not null,
    classoid oid  not null,
    provider text not null,
    label    text not null
);

alter table pg_catalog.pg_shseclabel
    owner to postgres;

create unique index pg_shseclabel_object_index
    on pg_catalog.pg_shseclabel (objoid, classoid, provider);

create table pg_catalog.pg_seclabel
(
    objoid   oid     not null,
    classoid oid     not null,
    objsubid integer not null,
    provider text    not null,
    label    text    not null
);

alter table pg_catalog.pg_seclabel
    owner to postgres;

create unique index pg_seclabel_object_index
    on pg_catalog.pg_seclabel (objoid, classoid, objsubid, provider);

create table pg_catalog.pg_ts_dict
(
    dictname       name not null,
    dictnamespace  oid  not null,
    dictowner      oid  not null,
    dicttemplate   oid  not null,
    dictinitoption text
);

alter table pg_catalog.pg_ts_dict
    owner to postgres;

create unique index pg_ts_dict_dictname_index
    on pg_catalog.pg_ts_dict (dictname, dictnamespace);

create unique index pg_ts_dict_oid_index
    on pg_catalog.pg_ts_dict (oid);

create table pg_catalog.pg_ts_parser
(
    prsname      name    not null,
    prsnamespace oid     not null,
    prsstart     regproc not null,
    prstoken     regproc not null,
    prsend       regproc not null,
    prsheadline  regproc not null,
    prslextype   regproc not null
);

alter table pg_catalog.pg_ts_parser
    owner to postgres;

create unique index pg_ts_parser_prsname_index
    on pg_catalog.pg_ts_parser (prsname, prsnamespace);

create unique index pg_ts_parser_oid_index
    on pg_catalog.pg_ts_parser (oid);

create table pg_catalog.pg_ts_config
(
    cfgname      name not null,
    cfgnamespace oid  not null,
    cfgowner     oid  not null,
    cfgparser    oid  not null
);

alter table pg_catalog.pg_ts_config
    owner to postgres;

create unique index pg_ts_config_cfgname_index
    on pg_catalog.pg_ts_config (cfgname, cfgnamespace);

create unique index pg_ts_config_oid_index
    on pg_catalog.pg_ts_config (oid);

create table pg_catalog.pg_ts_config_map
(
    mapcfg       oid     not null,
    maptokentype integer not null,
    mapseqno     integer not null,
    mapdict      oid     not null
);

alter table pg_catalog.pg_ts_config_map
    owner to postgres;

create unique index pg_ts_config_map_index
    on pg_catalog.pg_ts_config_map (mapcfg, maptokentype, mapseqno);

create table pg_catalog.pg_ts_template
(
    tmplname      name    not null,
    tmplnamespace oid     not null,
    tmplinit      regproc not null,
    tmpllexize    regproc not null
);

alter table pg_catalog.pg_ts_template
    owner to postgres;

create unique index pg_ts_template_tmplname_index
    on pg_catalog.pg_ts_template (tmplname, tmplnamespace);

create unique index pg_ts_template_oid_index
    on pg_catalog.pg_ts_template (oid);

create table pg_catalog.pg_replication_origin
(
    roident oid  not null,
    roname  text not null
);

alter table pg_catalog.pg_replication_origin
    owner to postgres;

create unique index pg_replication_origin_roiident_index
    on pg_catalog.pg_replication_origin (roident);

create unique index pg_replication_origin_roname_index
    on pg_catalog.pg_replication_origin (roname);

create table information_schema.sql_features
(
    feature_id       information_schema.character_data,
    feature_name     information_schema.character_data,
    sub_feature_id   information_schema.character_data,
    sub_feature_name information_schema.character_data,
    is_supported     information_schema.yes_or_no,
    is_verified_by   information_schema.character_data,
    comments         information_schema.character_data
);

alter table information_schema.sql_features
    owner to postgres;

create table information_schema.sql_implementation_info
(
    implementation_info_id   information_schema.character_data,
    implementation_info_name information_schema.character_data,
    integer_value            information_schema.cardinal_number,
    character_value          information_schema.character_data,
    comments                 information_schema.character_data
);

alter table information_schema.sql_implementation_info
    owner to postgres;

create table information_schema.sql_languages
(
    sql_language_source               information_schema.character_data,
    sql_language_year                 information_schema.character_data,
    sql_language_conformance          information_schema.character_data,
    sql_language_integrity            information_schema.character_data,
    sql_language_implementation       information_schema.character_data,
    sql_language_binding_style        information_schema.character_data,
    sql_language_programming_language information_schema.character_data
);

alter table information_schema.sql_languages
    owner to postgres;

create table information_schema.sql_packages
(
    feature_id     information_schema.character_data,
    feature_name   information_schema.character_data,
    is_supported   information_schema.yes_or_no,
    is_verified_by information_schema.character_data,
    comments       information_schema.character_data
);

alter table information_schema.sql_packages
    owner to postgres;

create table information_schema.sql_parts
(
    feature_id     information_schema.character_data,
    feature_name   information_schema.character_data,
    is_supported   information_schema.yes_or_no,
    is_verified_by information_schema.character_data,
    comments       information_schema.character_data
);

alter table information_schema.sql_parts
    owner to postgres;

create table information_schema.sql_sizing
(
    sizing_id       information_schema.cardinal_number,
    sizing_name     information_schema.character_data,
    supported_value information_schema.cardinal_number,
    comments        information_schema.character_data
);

alter table information_schema.sql_sizing
    owner to postgres;

create table information_schema.sql_sizing_profiles
(
    sizing_id      information_schema.cardinal_number,
    sizing_name    information_schema.character_data,
    profile_id     information_schema.character_data,
    required_value information_schema.cardinal_number,
    comments       information_schema.character_data
);

alter table information_schema.sql_sizing_profiles
    owner to postgres;

create table _timescaledb_catalog.hypertable
(
    id                       serial   not null
        constraint hypertable_pkey
            primary key,
    schema_name              name     not null
        constraint hypertable_schema_name_check
            check (schema_name <> '_timescaledb_catalog'::name),
    table_name               name     not null,
    associated_schema_name   name     not null,
    associated_table_prefix  name     not null,
    num_dimensions           smallint not null
        constraint hypertable_num_dimensions_check
            check (num_dimensions > 0),
    chunk_sizing_func_schema name     not null,
    chunk_sizing_func_name   name     not null,
    chunk_target_size        bigint   not null
        constraint hypertable_chunk_target_size_check
            check (chunk_target_size >= 0),
    constraint hypertable_id_schema_name_key
        unique (id, schema_name),
    constraint hypertable_schema_name_table_name_key
        unique (schema_name, table_name),
    constraint hypertable_associated_schema_name_associated_table_prefix_key
        unique (associated_schema_name, associated_table_prefix)
);

alter table _timescaledb_catalog.hypertable
    owner to postgres;

create table _timescaledb_catalog.tablespace
(
    id              serial  not null
        constraint tablespace_pkey
            primary key,
    hypertable_id   integer not null
        constraint tablespace_hypertable_id_fkey
            references _timescaledb_catalog.hypertable
            on delete cascade,
    tablespace_name name    not null,
    constraint tablespace_hypertable_id_tablespace_name_key
        unique (hypertable_id, tablespace_name)
);

alter table _timescaledb_catalog.tablespace
    owner to postgres;

create table _timescaledb_catalog.dimension
(
    id                       serial  not null
        constraint dimension_pkey
            primary key,
    hypertable_id            integer not null
        constraint dimension_hypertable_id_fkey
            references _timescaledb_catalog.hypertable
            on delete cascade,
    column_name              name    not null,
    column_type              regtype not null,
    aligned                  boolean not null,
    num_slices               smallint,
    partitioning_func_schema name,
    partitioning_func        name,
    interval_length          bigint
        constraint dimension_interval_length_check
            check ((interval_length IS NULL) OR (interval_length > 0)),
    constraint dimension_hypertable_id_column_name_key
        unique (hypertable_id, column_name),
    constraint dimension_check
        check (((partitioning_func_schema IS NULL) AND (partitioning_func IS NULL)) OR
               ((partitioning_func_schema IS NOT NULL) AND (partitioning_func IS NOT NULL))),
    constraint dimension_check1
        check (((num_slices IS NULL) AND (interval_length IS NOT NULL)) OR
               ((num_slices IS NOT NULL) AND (interval_length IS NULL)))
);

alter table _timescaledb_catalog.dimension
    owner to postgres;

create table _timescaledb_catalog.dimension_slice
(
    id           serial  not null
        constraint dimension_slice_pkey
            primary key,
    dimension_id integer not null
        constraint dimension_slice_dimension_id_fkey
            references _timescaledb_catalog.dimension
            on delete cascade,
    range_start  bigint  not null,
    range_end    bigint  not null,
    constraint dimension_slice_dimension_id_range_start_range_end_key
        unique (dimension_id, range_start, range_end),
    constraint dimension_slice_check
        check (range_start <= range_end)
);

alter table _timescaledb_catalog.dimension_slice
    owner to postgres;

create table _timescaledb_catalog.chunk
(
    id            serial  not null
        constraint chunk_pkey
            primary key,
    hypertable_id integer not null
        constraint chunk_hypertable_id_fkey
            references _timescaledb_catalog.hypertable,
    schema_name   name    not null,
    table_name    name    not null,
    constraint chunk_schema_name_table_name_key
        unique (schema_name, table_name)
);

alter table _timescaledb_catalog.chunk
    owner to postgres;

create index chunk_hypertable_id_idx
    on _timescaledb_catalog.chunk (hypertable_id);

create table _timescaledb_catalog.chunk_constraint
(
    chunk_id                   integer not null
        constraint chunk_constraint_chunk_id_fkey
            references _timescaledb_catalog.chunk,
    dimension_slice_id         integer
        constraint chunk_constraint_dimension_slice_id_fkey
            references _timescaledb_catalog.dimension_slice,
    constraint_name            name    not null,
    hypertable_constraint_name name,
    constraint chunk_constraint_chunk_id_constraint_name_key
        unique (chunk_id, constraint_name)
);

alter table _timescaledb_catalog.chunk_constraint
    owner to postgres;

create index chunk_constraint_chunk_id_dimension_slice_id_idx
    on _timescaledb_catalog.chunk_constraint (chunk_id, dimension_slice_id);

create table _timescaledb_catalog.chunk_index
(
    chunk_id              integer not null
        constraint chunk_index_chunk_id_fkey
            references _timescaledb_catalog.chunk
            on delete cascade,
    index_name            name    not null,
    hypertable_id         integer not null
        constraint chunk_index_hypertable_id_fkey
            references _timescaledb_catalog.hypertable
            on delete cascade,
    hypertable_index_name name    not null,
    constraint chunk_index_chunk_id_index_name_key
        unique (chunk_id, index_name)
);

alter table _timescaledb_catalog.chunk_index
    owner to postgres;

create index chunk_index_hypertable_id_hypertable_index_name_idx
    on _timescaledb_catalog.chunk_index (hypertable_id, hypertable_index_name);

create table _timescaledb_config.bgw_job
(
    id                serial   not null
        constraint bgw_job_pkey
            primary key,
    application_name  name     not null,
    job_type          name     not null
        constraint valid_job_type
            check (job_type = ANY
                   (ARRAY ['telemetry_and_version_check_if_enabled'::name, 'reorder'::name, 'drop_chunks'::name, 'continuous_aggregate'::name])),
    schedule_interval interval not null,
    max_runtime       interval not null,
    max_retries       integer  not null,
    retry_period      interval not null
);

alter table _timescaledb_config.bgw_job
    owner to postgres;

create table _timescaledb_internal.bgw_job_stat
(
    job_id               integer                                not null
        constraint bgw_job_stat_pkey
            primary key
        constraint bgw_job_stat_job_id_fkey
            references _timescaledb_config.bgw_job
            on delete cascade,
    last_start           timestamp with time zone default now() not null,
    last_finish          timestamp with time zone               not null,
    next_start           timestamp with time zone               not null,
    last_run_success     boolean                                not null,
    total_runs           bigint                                 not null,
    total_duration       interval                               not null,
    total_successes      bigint                                 not null,
    total_failures       bigint                                 not null,
    total_crashes        bigint                                 not null,
    consecutive_failures integer                                not null,
    consecutive_crashes  integer                                not null
);

alter table _timescaledb_internal.bgw_job_stat
    owner to postgres;

create table _timescaledb_config.bgw_policy_reorder
(
    job_id                integer not null
        constraint bgw_policy_reorder_pkey
            primary key
        constraint bgw_policy_reorder_job_id_fkey
            references _timescaledb_config.bgw_job
            on delete cascade,
    hypertable_id         integer not null
        constraint bgw_policy_reorder_hypertable_id_key
            unique
        constraint bgw_policy_reorder_hypertable_id_fkey
            references _timescaledb_catalog.hypertable
            on delete cascade,
    hypertable_index_name name    not null
);

alter table _timescaledb_config.bgw_policy_reorder
    owner to postgres;

create table _timescaledb_config.bgw_policy_drop_chunks
(
    job_id                      integer  not null
        constraint bgw_policy_drop_chunks_pkey
            primary key
        constraint bgw_policy_drop_chunks_job_id_fkey
            references _timescaledb_config.bgw_job
            on delete cascade,
    hypertable_id               integer  not null
        constraint bgw_policy_drop_chunks_hypertable_id_key
            unique
        constraint bgw_policy_drop_chunks_hypertable_id_fkey
            references _timescaledb_catalog.hypertable
            on delete cascade,
    older_than                  interval not null,
    cascade                     boolean,
    cascade_to_materializations boolean
);

alter table _timescaledb_config.bgw_policy_drop_chunks
    owner to postgres;

create table _timescaledb_internal.bgw_policy_chunk_stats
(
    job_id            integer not null
        constraint bgw_policy_chunk_stats_job_id_fkey
            references _timescaledb_config.bgw_job
            on delete cascade,
    chunk_id          integer not null
        constraint bgw_policy_chunk_stats_chunk_id_fkey
            references _timescaledb_catalog.chunk
            on delete cascade,
    num_times_job_run integer,
    last_time_job_run timestamp with time zone,
    constraint bgw_policy_chunk_stats_job_id_chunk_id_key
        unique (job_id, chunk_id)
);

alter table _timescaledb_internal.bgw_policy_chunk_stats
    owner to postgres;

create table _timescaledb_catalog.metadata
(
    key                  name    not null
        constraint metadata_pkey
            primary key,
    value                text    not null,
    include_in_telemetry boolean not null
);

alter table _timescaledb_catalog.metadata
    owner to postgres;

create table _timescaledb_catalog.continuous_agg
(
    mat_hypertable_id    integer not null
        constraint continuous_agg_pkey
            primary key
        constraint continuous_agg_mat_hypertable_id_fkey
            references _timescaledb_catalog.hypertable
            on delete cascade,
    raw_hypertable_id    integer not null
        constraint continuous_agg_raw_hypertable_id_fkey
            references _timescaledb_catalog.hypertable
            on delete cascade,
    user_view_schema     name    not null,
    user_view_name       name    not null,
    partial_view_schema  name    not null,
    partial_view_name    name    not null,
    bucket_width         bigint  not null,
    job_id               integer not null
        constraint continuous_agg_job_id_key
            unique
        constraint continuous_agg_job_id_fkey
            references _timescaledb_config.bgw_job
            on delete restrict,
    refresh_lag          bigint  not null,
    direct_view_schema   name    not null,
    direct_view_name     name    not null,
    max_interval_per_job bigint  not null,
    constraint continuous_agg_user_view_schema_user_view_name_key
        unique (user_view_schema, user_view_name),
    constraint continuous_agg_partial_view_schema_partial_view_name_key
        unique (partial_view_schema, partial_view_name)
);

alter table _timescaledb_catalog.continuous_agg
    owner to postgres;

create table _timescaledb_catalog.continuous_aggs_invalidation_threshold
(
    hypertable_id integer not null
        constraint continuous_aggs_invalidation_threshold_pkey
            primary key
        constraint continuous_aggs_invalidation_threshold_hypertable_id_fkey
            references _timescaledb_catalog.hypertable
            on delete cascade,
    watermark     bigint  not null
);

alter table _timescaledb_catalog.continuous_aggs_invalidation_threshold
    owner to postgres;

create table _timescaledb_catalog.continuous_aggs_completed_threshold
(
    materialization_id integer not null
        constraint continuous_aggs_completed_threshold_pkey
            primary key
        constraint continuous_aggs_completed_threshold_materialization_id_fkey
            references _timescaledb_catalog.continuous_agg
            on delete cascade,
    watermark          bigint  not null
);

alter table _timescaledb_catalog.continuous_aggs_completed_threshold
    owner to postgres;

create table _timescaledb_catalog.continuous_aggs_hypertable_invalidation_log
(
    hypertable_id           integer not null,
    lowest_modified_value   bigint  not null,
    greatest_modified_value bigint  not null
);

alter table _timescaledb_catalog.continuous_aggs_hypertable_invalidation_log
    owner to postgres;

create index continuous_aggs_hypertable_invalidation_log_idx
    on _timescaledb_catalog.continuous_aggs_hypertable_invalidation_log (hypertable_id, lowest_modified_value);

create table _timescaledb_catalog.continuous_aggs_materialization_invalidation_log
(
    materialization_id      integer
        constraint continuous_aggs_materialization_invalid_materialization_id_fkey
            references _timescaledb_catalog.continuous_agg
            on delete cascade,
    lowest_modified_value   bigint not null,
    greatest_modified_value bigint not null
);

alter table _timescaledb_catalog.continuous_aggs_materialization_invalidation_log
    owner to postgres;

create index continuous_aggs_materialization_invalidation_log_idx
    on _timescaledb_catalog.continuous_aggs_materialization_invalidation_log (materialization_id, lowest_modified_value);

create table _timescaledb_cache.cache_inval_hypertable
(
);

alter table _timescaledb_cache.cache_inval_hypertable
    owner to postgres;

create table _timescaledb_cache.cache_inval_bgw_job
(
);

alter table _timescaledb_cache.cache_inval_bgw_job
    owner to postgres;

create table _timescaledb_cache.cache_inval_extension
(
);

alter table _timescaledb_cache.cache_inval_extension
    owner to postgres;

create table contractor
(
    contractor_id integer not null
        constraint contractor_id
            unique,
    short_name    varchar(250),
    long_name     varchar(500),
    id            serial  not null
        constraint id
            primary key
);

alter table contractor
    owner to postgres;

create table novos_version
(
    id           serial  not null
        constraint novos_id
            primary key,
    version_id   integer not null
        constraint version_id
            unique,
    version_name varchar,
    start_time   date    not null,
    end_time     date
);

alter table novos_version
    owner to postgres;

create table rig
(
    rig_id        integer not null
        constraint rig_id_uniq
            unique,
    rig_name      varchar,
    contractor_id integer not null
        constraint "contractorToRig"
            references contractor (contractor_id),
    version_id    integer
        constraint "novosVerToRig"
            references novos_version (version_id),
    id            serial  not null
        constraint rig_id
            primary key
);

alter table rig
    owner to postgres;

create table rad_output
(
    rig_id   integer      not null
        constraint "rigToTags"
            references rig (rig_id),
    time     timestamp(4) not null
        constraint time
            primary key,
    tag_name varchar(500) not null,
    value    varchar(500)
);

alter table rad_output
    owner to postgres;

create table collected
(
    rig_id   integer      not null
        constraint "collTagToRig"
            references rig (rig_id),
    time     timestamp(4) not null
        constraint "collPK"
            primary key,
    tag_name varchar(500) not null,
    value    varchar(500)
);

alter table collected
    owner to postgres;

create table well
(
    well_id    integer not null
        constraint "wellIdUniq"
            unique,
    well_name  varchar,
    rig_id     integer
        constraint "rigToWell"
            references rig (rig_id),
    id         serial  not null
        constraint "wellPK"
            primary key,
    start_time date    not null,
    end_time   date
);

alter table well
    owner to postgres;

create table rig_config
(
    id     serial  not null
        constraint "configPK"
            primary key,
    rig_id integer not null
        constraint "rigToConfig"
            references rig (rig_id),
    config jsonb
);

alter table rig_config
    owner to postgres;

create table oman_bst7
(
    epoch    bigint  not null,
    tag_name varchar not null,
    value    char    not null
);

alter table oman_bst7
    owner to postgres;

create table oman_bst8
(
    epoch    bigint  not null,
    tag_name varchar not null,
    value    char    not null
);

alter table oman_bst8
    owner to postgres;

create table oman_bst11
(
    epoch    bigint  not null,
    tag_name varchar not null,
    value    char    not null
);

alter table oman_bst11
    owner to postgres;

create table oman_bst12
(
    epoch    bigint  not null,
    tag_name varchar not null,
    value    char    not null
);

alter table oman_bst12
    owner to postgres;

create view pg_catalog.pg_roles(rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication,
                                rolconnlimit, rolpassword, rolvaliduntil, rolbypassrls, rolconfig, oid) as
SELECT pg_authid.rolname,
       pg_authid.rolsuper,
       pg_authid.rolinherit,
       pg_authid.rolcreaterole,
       pg_authid.rolcreatedb,
       pg_authid.rolcanlogin,
       pg_authid.rolreplication,
       pg_authid.rolconnlimit,
       '********'::text AS rolpassword,
       pg_authid.rolvaliduntil,
       pg_authid.rolbypassrls,
       s.setconfig      AS rolconfig,
       pg_authid.oid
FROM (pg_authid
         LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))));

alter table pg_catalog.pg_roles
    owner to postgres;

create view pg_catalog.pg_shadow(usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil,
                                 useconfig) as
SELECT pg_authid.rolname                  AS usename,
       pg_authid.oid                      AS usesysid,
       pg_authid.rolcreatedb              AS usecreatedb,
       pg_authid.rolsuper                 AS usesuper,
       pg_authid.rolreplication           AS userepl,
       pg_authid.rolbypassrls             AS usebypassrls,
       pg_authid.rolpassword              AS passwd,
       (pg_authid.rolvaliduntil)::abstime AS valuntil,
       s.setconfig                        AS useconfig
FROM (pg_authid
         LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))))
WHERE pg_authid.rolcanlogin;

alter table pg_catalog.pg_shadow
    owner to postgres;

create view pg_catalog.pg_group(groname, grosysid, grolist) as
SELECT pg_authid.rolname                                     AS groname,
       pg_authid.oid                                         AS grosysid,
       ARRAY(SELECT pg_auth_members.member
             FROM pg_auth_members
             WHERE (pg_auth_members.roleid = pg_authid.oid)) AS grolist
FROM pg_authid
WHERE (NOT pg_authid.rolcanlogin);

alter table pg_catalog.pg_group
    owner to postgres;

create view pg_catalog.pg_user(usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil,
                               useconfig) as
SELECT pg_shadow.usename,
       pg_shadow.usesysid,
       pg_shadow.usecreatedb,
       pg_shadow.usesuper,
       pg_shadow.userepl,
       pg_shadow.usebypassrls,
       '********'::text AS passwd,
       pg_shadow.valuntil,
       pg_shadow.useconfig
FROM pg_shadow;

alter table pg_catalog.pg_user
    owner to postgres;

create view pg_catalog.pg_policies(schemaname, tablename, policyname, roles, cmd, qual, with_check) as
SELECT n.nspname                                   AS schemaname,
       c.relname                                   AS tablename,
       pol.polname                                 AS policyname,
       CASE
           WHEN (pol.polroles = '{0}'::oid[]) THEN (string_to_array('public'::text, ''::text))::name[]
           ELSE ARRAY(SELECT pg_authid.rolname
                      FROM pg_authid
                      WHERE (pg_authid.oid = ANY (pol.polroles))
                      ORDER BY pg_authid.rolname)
           END                                     AS roles,
       CASE pol.polcmd
           WHEN 'r'::"char" THEN 'SELECT'::text
           WHEN 'a'::"char" THEN 'INSERT'::text
           WHEN 'w'::"char" THEN 'UPDATE'::text
           WHEN 'd'::"char" THEN 'DELETE'::text
           WHEN '*'::"char" THEN 'ALL'::text
           ELSE NULL::text
           END                                     AS cmd,
       pg_get_expr(pol.polqual, pol.polrelid)      AS qual,
       pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check
FROM ((pg_policy pol
    JOIN pg_class c ON ((c.oid = pol.polrelid)))
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)));

alter table pg_catalog.pg_policies
    owner to postgres;

create view pg_catalog.pg_rules(schemaname, tablename, rulename, definition) as
SELECT n.nspname             AS schemaname,
       c.relname             AS tablename,
       r.rulename,
       pg_get_ruledef(r.oid) AS definition
FROM ((pg_rewrite r
    JOIN pg_class c ON ((c.oid = r.ev_class)))
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE (r.rulename <> '_RETURN'::name);

alter table pg_catalog.pg_rules
    owner to postgres;

create view pg_catalog.pg_views(schemaname, viewname, viewowner, definition) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS viewname,
       pg_get_userbyid(c.relowner) AS viewowner,
       pg_get_viewdef(c.oid)       AS definition
FROM (pg_class c
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE (c.relkind = 'v'::"char");

alter table pg_catalog.pg_views
    owner to postgres;

create view pg_catalog.pg_tables(schemaname, tablename, tableowner, tablespace, hasindexes, hasrules, hastriggers,
                                 rowsecurity) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS tablename,
       pg_get_userbyid(c.relowner) AS tableowner,
       t.spcname                   AS tablespace,
       c.relhasindex               AS hasindexes,
       c.relhasrules               AS hasrules,
       c.relhastriggers            AS hastriggers,
       c.relrowsecurity            AS rowsecurity
FROM ((pg_class c
    LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
         LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
WHERE (c.relkind = 'r'::"char");

alter table pg_catalog.pg_tables
    owner to postgres;

create view pg_catalog.pg_matviews(schemaname, matviewname, matviewowner, tablespace, hasindexes, ispopulated,
                                   definition) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS matviewname,
       pg_get_userbyid(c.relowner) AS matviewowner,
       t.spcname                   AS tablespace,
       c.relhasindex               AS hasindexes,
       c.relispopulated            AS ispopulated,
       pg_get_viewdef(c.oid)       AS definition
FROM ((pg_class c
    LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
         LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
WHERE (c.relkind = 'm'::"char");

alter table pg_catalog.pg_matviews
    owner to postgres;

create view pg_catalog.pg_indexes(schemaname, tablename, indexname, tablespace, indexdef) as
SELECT n.nspname              AS schemaname,
       c.relname              AS tablename,
       i.relname              AS indexname,
       t.spcname              AS tablespace,
       pg_get_indexdef(i.oid) AS indexdef
FROM ((((pg_index x
    JOIN pg_class c ON ((c.oid = x.indrelid)))
    JOIN pg_class i ON ((i.oid = x.indexrelid)))
    LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
         LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace)))
WHERE ((c.relkind = ANY (ARRAY ['r'::"char", 'm'::"char"])) AND (i.relkind = 'i'::"char"));

alter table pg_catalog.pg_indexes
    owner to postgres;

create view pg_catalog.pg_stats(schemaname, tablename, attname, inherited, null_frac, avg_width, n_distinct,
                                most_common_vals, most_common_freqs, histogram_bounds, correlation, most_common_elems,
                                most_common_elem_freqs, elem_count_histogram) as
SELECT n.nspname     AS schemaname,
       c.relname     AS tablename,
       a.attname,
       s.stainherit  AS inherited,
       s.stanullfrac AS null_frac,
       s.stawidth    AS avg_width,
       s.stadistinct AS n_distinct,
       CASE
           WHEN (s.stakind1 = 1) THEN s.stavalues1
           WHEN (s.stakind2 = 1) THEN s.stavalues2
           WHEN (s.stakind3 = 1) THEN s.stavalues3
           WHEN (s.stakind4 = 1) THEN s.stavalues4
           WHEN (s.stakind5 = 1) THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS most_common_vals,
       CASE
           WHEN (s.stakind1 = 1) THEN s.stanumbers1
           WHEN (s.stakind2 = 1) THEN s.stanumbers2
           WHEN (s.stakind3 = 1) THEN s.stanumbers3
           WHEN (s.stakind4 = 1) THEN s.stanumbers4
           WHEN (s.stakind5 = 1) THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS most_common_freqs,
       CASE
           WHEN (s.stakind1 = 2) THEN s.stavalues1
           WHEN (s.stakind2 = 2) THEN s.stavalues2
           WHEN (s.stakind3 = 2) THEN s.stavalues3
           WHEN (s.stakind4 = 2) THEN s.stavalues4
           WHEN (s.stakind5 = 2) THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS histogram_bounds,
       CASE
           WHEN (s.stakind1 = 3) THEN s.stanumbers1[1]
           WHEN (s.stakind2 = 3) THEN s.stanumbers2[1]
           WHEN (s.stakind3 = 3) THEN s.stanumbers3[1]
           WHEN (s.stakind4 = 3) THEN s.stanumbers4[1]
           WHEN (s.stakind5 = 3) THEN s.stanumbers5[1]
           ELSE NULL::real
           END       AS correlation,
       CASE
           WHEN (s.stakind1 = 4) THEN s.stavalues1
           WHEN (s.stakind2 = 4) THEN s.stavalues2
           WHEN (s.stakind3 = 4) THEN s.stavalues3
           WHEN (s.stakind4 = 4) THEN s.stavalues4
           WHEN (s.stakind5 = 4) THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS most_common_elems,
       CASE
           WHEN (s.stakind1 = 4) THEN s.stanumbers1
           WHEN (s.stakind2 = 4) THEN s.stanumbers2
           WHEN (s.stakind3 = 4) THEN s.stanumbers3
           WHEN (s.stakind4 = 4) THEN s.stanumbers4
           WHEN (s.stakind5 = 4) THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS most_common_elem_freqs,
       CASE
           WHEN (s.stakind1 = 5) THEN s.stanumbers1
           WHEN (s.stakind2 = 5) THEN s.stanumbers2
           WHEN (s.stakind3 = 5) THEN s.stanumbers3
           WHEN (s.stakind4 = 5) THEN s.stanumbers4
           WHEN (s.stakind5 = 5) THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS elem_count_histogram
FROM (((pg_statistic s
    JOIN pg_class c ON ((c.oid = s.starelid)))
    JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum))))
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text) AND
       ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));

alter table pg_catalog.pg_stats
    owner to postgres;

create view pg_catalog.pg_locks(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid,
                                objsubid, virtualtransaction, pid, mode, granted, fastpath) as
SELECT l.locktype,
       l.database,
       l.relation,
       l.page,
       l.tuple,
       l.virtualxid,
       l.transactionid,
       l.classid,
       l.objid,
       l.objsubid,
       l.virtualtransaction,
       l.pid,
       l.mode,
       l.granted,
       l.fastpath
FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid,
                        virtualtransaction, pid, mode, granted, fastpath);

alter table pg_catalog.pg_locks
    owner to postgres;

create view pg_catalog.pg_cursors(name, statement, is_holdable, is_binary, is_scrollable, creation_time) as
SELECT c.name,
       c.statement,
       c.is_holdable,
       c.is_binary,
       c.is_scrollable,
       c.creation_time
FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);

alter table pg_catalog.pg_cursors
    owner to postgres;

create view pg_catalog.pg_available_extensions(name, default_version, installed_version, comment) as
SELECT e.name,
       e.default_version,
       x.extversion AS installed_version,
       e.comment
FROM (pg_available_extensions() e (name, default_version, comment)
         LEFT JOIN pg_extension x ON ((e.name = x.extname)));

alter table pg_catalog.pg_available_extensions
    owner to postgres;

create view pg_catalog.pg_available_extension_versions(name, version, installed, superuser, relocatable, schema,
                                                       requires, comment) as
SELECT e.name,
       e.version,
       (x.extname IS NOT NULL) AS installed,
       e.superuser,
       e.relocatable,
       e.schema,
       e.requires,
       e.comment
FROM (pg_available_extension_versions() e (name, version, superuser, relocatable, schema, requires, comment)
         LEFT JOIN pg_extension x ON (((e.name = x.extname) AND (e.version = x.extversion))));

alter table pg_catalog.pg_available_extension_versions
    owner to postgres;

create view pg_catalog.pg_prepared_xacts(transaction, gid, prepared, owner, database) as
SELECT p.transaction,
       p.gid,
       p.prepared,
       u.rolname AS owner,
       d.datname AS database
FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)
    LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))
         LEFT JOIN pg_database d ON ((p.dbid = d.oid)));

alter table pg_catalog.pg_prepared_xacts
    owner to postgres;

create view pg_catalog.pg_prepared_statements(name, statement, prepare_time, parameter_types, from_sql) as
SELECT p.name,
       p.statement,
       p.prepare_time,
       p.parameter_types,
       p.from_sql
FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);

alter table pg_catalog.pg_prepared_statements
    owner to postgres;

create view pg_catalog.pg_seclabels(objoid, classoid, objsubid, objtype, objnamespace, objname, provider, label) as
    SELECT l.objoid,
           l.classoid,
           l.objsubid,
           CASE
               WHEN (rel.relkind = 'r'::"char") THEN 'table'::text
               WHEN (rel.relkind = 'v'::"char") THEN 'view'::text
               WHEN (rel.relkind = 'm'::"char") THEN 'materialized view'::text
               WHEN (rel.relkind = 'S'::"char") THEN 'sequence'::text
               WHEN (rel.relkind = 'f'::"char") THEN 'foreign table'::text
               ELSE NULL::text
               END          AS objtype,
           rel.relnamespace AS objnamespace,
           CASE
               WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)
               ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((rel.relname)::text))
               END          AS objname,
           l.provider,
           l.label
    FROM ((pg_seclabel l
        JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
             JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
    WHERE (l.objsubid = 0)
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           l.objsubid,
           'column'::text                                         AS objtype,
           rel.relnamespace                                       AS objnamespace,
           ((
                    CASE
                        WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)
                        ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((rel.relname)::text))
                        END || '.'::text) || (att.attname)::text) AS objname,
           l.provider,
           l.label
    FROM (((pg_seclabel l
        JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))
        JOIN pg_attribute att ON (((rel.oid = att.attrelid) AND (l.objsubid = att.attnum))))
             JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))
    WHERE (l.objsubid <> 0)
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           l.objsubid,
           CASE
               WHEN (pro.proisagg = true) THEN 'aggregate'::text
               WHEN (pro.proisagg = false) THEN 'function'::text
               ELSE NULL::text
               END                                                                              AS objtype,
           pro.pronamespace                                                                     AS objnamespace,
           (((
                     CASE
                         WHEN pg_function_is_visible(pro.oid) THEN quote_ident((pro.proname)::text)
                         ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((pro.proname)::text))
                         END || '('::text) || pg_get_function_arguments(pro.oid)) || ')'::text) AS objname,
           l.provider,
           l.label
    FROM ((pg_seclabel l
        JOIN pg_proc pro ON (((l.classoid = pro.tableoid) AND (l.objoid = pro.oid))))
             JOIN pg_namespace nsp ON ((pro.pronamespace = nsp.oid)))
    WHERE (l.objsubid = 0)
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           l.objsubid,
           CASE
               WHEN (typ.typtype = 'd'::"char") THEN 'domain'::text
               ELSE 'type'::text
               END          AS objtype,
           typ.typnamespace AS objnamespace,
           CASE
               WHEN pg_type_is_visible(typ.oid) THEN quote_ident((typ.typname)::text)
               ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((typ.typname)::text))
               END          AS objname,
           l.provider,
           l.label
    FROM ((pg_seclabel l
        JOIN pg_type typ ON (((l.classoid = typ.tableoid) AND (l.objoid = typ.oid))))
             JOIN pg_namespace nsp ON ((typ.typnamespace = nsp.oid)))
    WHERE (l.objsubid = 0)
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           l.objsubid,
           'large object'::text AS objtype,
           NULL::oid            AS objnamespace,
           (l.objoid)::text     AS objname,
           l.provider,
           l.label
    FROM (pg_seclabel l
             JOIN pg_largeobject_metadata lom ON ((l.objoid = lom.oid)))
    WHERE ((l.classoid = ('pg_largeobject'::regclass)::oid) AND (l.objsubid = 0))
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           l.objsubid,
           'language'::text                 AS objtype,
           NULL::oid                        AS objnamespace,
           quote_ident((lan.lanname)::text) AS objname,
           l.provider,
           l.label
    FROM (pg_seclabel l
             JOIN pg_language lan ON (((l.classoid = lan.tableoid) AND (l.objoid = lan.oid))))
    WHERE (l.objsubid = 0)
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           l.objsubid,
           'schema'::text                   AS objtype,
           nsp.oid                          AS objnamespace,
           quote_ident((nsp.nspname)::text) AS objname,
           l.provider,
           l.label
    FROM (pg_seclabel l
             JOIN pg_namespace nsp ON (((l.classoid = nsp.tableoid) AND (l.objoid = nsp.oid))))
    WHERE (l.objsubid = 0)
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           l.objsubid,
           'event trigger'::text            AS objtype,
           NULL::oid                        AS objnamespace,
           quote_ident((evt.evtname)::text) AS objname,
           l.provider,
           l.label
    FROM (pg_seclabel l
             JOIN pg_event_trigger evt ON (((l.classoid = evt.tableoid) AND (l.objoid = evt.oid))))
    WHERE (l.objsubid = 0)
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           0                                AS objsubid,
           'database'::text                 AS objtype,
           NULL::oid                        AS objnamespace,
           quote_ident((dat.datname)::text) AS objname,
           l.provider,
           l.label
    FROM (pg_shseclabel l
             JOIN pg_database dat ON (((l.classoid = dat.tableoid) AND (l.objoid = dat.oid))))
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           0                                AS objsubid,
           'tablespace'::text               AS objtype,
           NULL::oid                        AS objnamespace,
           quote_ident((spc.spcname)::text) AS objname,
           l.provider,
           l.label
    FROM (pg_shseclabel l
             JOIN pg_tablespace spc ON (((l.classoid = spc.tableoid) AND (l.objoid = spc.oid))))
    UNION ALL
    SELECT l.objoid,
           l.classoid,
           0                                AS objsubid,
           'role'::text                     AS objtype,
           NULL::oid                        AS objnamespace,
           quote_ident((rol.rolname)::text) AS objname,
           l.provider,
           l.label
    FROM (pg_shseclabel l
             JOIN pg_authid rol ON (((l.classoid = rol.tableoid) AND (l.objoid = rol.oid))));

alter table pg_catalog.pg_seclabels
    owner to postgres;

create view pg_catalog.pg_settings(name, setting, unit, category, short_desc, extra_desc, context, vartype, source,
                                   min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline,
                                   pending_restart) as
SELECT a.name,
       a.setting,
       a.unit,
       a.category,
       a.short_desc,
       a.extra_desc,
       a.context,
       a.vartype,
       a.source,
       a.min_val,
       a.max_val,
       a.enumvals,
       a.boot_val,
       a.reset_val,
       a.sourcefile,
       a.sourceline,
       a.pending_restart
FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val,
                              max_val, enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart);

alter table pg_catalog.pg_settings
    owner to postgres;

CREATE RULE pg_settings_u AS
    ON UPDATE TO pg_catalog.pg_settings
    WHERE (new.name = old.name) DO SELECT set_config(old.name, new.setting, false) AS set_config;

CREATE RULE pg_settings_n AS
    ON UPDATE TO pg_catalog.pg_settings DO INSTEAD NOTHING;

create view pg_catalog.pg_file_settings(sourcefile, sourceline, seqno, name, setting, applied, error) as
SELECT a.sourcefile,
       a.sourceline,
       a.seqno,
       a.name,
       a.setting,
       a.applied,
       a.error
FROM pg_show_all_file_settings() a(sourcefile, sourceline, seqno, name, setting, applied, error);

alter table pg_catalog.pg_file_settings
    owner to postgres;

create view pg_catalog.pg_timezone_abbrevs(abbrev, utc_offset, is_dst) as
SELECT pg_timezone_abbrevs.abbrev,
       pg_timezone_abbrevs.utc_offset,
       pg_timezone_abbrevs.is_dst
FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);

alter table pg_catalog.pg_timezone_abbrevs
    owner to postgres;

create view pg_catalog.pg_timezone_names(name, abbrev, utc_offset, is_dst) as
SELECT pg_timezone_names.name,
       pg_timezone_names.abbrev,
       pg_timezone_names.utc_offset,
       pg_timezone_names.is_dst
FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);

alter table pg_catalog.pg_timezone_names
    owner to postgres;

create view pg_catalog.pg_config(name, setting) as
SELECT pg_config.name,
       pg_config.setting
FROM pg_config() pg_config(name, setting);

alter table pg_catalog.pg_config
    owner to postgres;

create view pg_catalog.pg_stat_all_tables(relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch,
                                          n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup,
                                          n_mod_since_analyze, last_vacuum, last_autovacuum, last_analyze,
                                          last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
                                          autoanalyze_count) as
SELECT c.oid                                                                                         AS relid,
       n.nspname                                                                                     AS schemaname,
       c.relname,
       pg_stat_get_numscans(c.oid)                                                                   AS seq_scan,
       pg_stat_get_tuples_returned(c.oid)                                                            AS seq_tup_read,
       (sum(pg_stat_get_numscans(i.indexrelid)))::bigint                                             AS idx_scan,
       ((sum(pg_stat_get_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_tuples_fetched(c.oid)) AS idx_tup_fetch,
       pg_stat_get_tuples_inserted(c.oid)                                                            AS n_tup_ins,
       pg_stat_get_tuples_updated(c.oid)                                                             AS n_tup_upd,
       pg_stat_get_tuples_deleted(c.oid)                                                             AS n_tup_del,
       pg_stat_get_tuples_hot_updated(c.oid)                                                         AS n_tup_hot_upd,
       pg_stat_get_live_tuples(c.oid)                                                                AS n_live_tup,
       pg_stat_get_dead_tuples(c.oid)                                                                AS n_dead_tup,
       pg_stat_get_mod_since_analyze(c.oid)                                                          AS n_mod_since_analyze,
       pg_stat_get_last_vacuum_time(c.oid)                                                           AS last_vacuum,
       pg_stat_get_last_autovacuum_time(c.oid)                                                       AS last_autovacuum,
       pg_stat_get_last_analyze_time(c.oid)                                                          AS last_analyze,
       pg_stat_get_last_autoanalyze_time(c.oid)                                                      AS last_autoanalyze,
       pg_stat_get_vacuum_count(c.oid)                                                               AS vacuum_count,
       pg_stat_get_autovacuum_count(c.oid)                                                           AS autovacuum_count,
       pg_stat_get_analyze_count(c.oid)                                                              AS analyze_count,
       pg_stat_get_autoanalyze_count(c.oid)                                                          AS autoanalyze_count
FROM ((pg_class c
    LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]))
GROUP BY c.oid, n.nspname, c.relname;

alter table pg_catalog.pg_stat_all_tables
    owner to postgres;

create view pg_catalog.pg_stat_xact_all_tables(relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan,
                                               idx_tup_fetch, n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd) as
SELECT c.oid                                                  AS relid,
       n.nspname                                              AS schemaname,
       c.relname,
       pg_stat_get_xact_numscans(c.oid)                       AS seq_scan,
       pg_stat_get_xact_tuples_returned(c.oid)                AS seq_tup_read,
       (sum(pg_stat_get_xact_numscans(i.indexrelid)))::bigint AS idx_scan,
       ((sum(pg_stat_get_xact_tuples_fetched(i.indexrelid)))::bigint +
        pg_stat_get_xact_tuples_fetched(c.oid))               AS idx_tup_fetch,
       pg_stat_get_xact_tuples_inserted(c.oid)                AS n_tup_ins,
       pg_stat_get_xact_tuples_updated(c.oid)                 AS n_tup_upd,
       pg_stat_get_xact_tuples_deleted(c.oid)                 AS n_tup_del,
       pg_stat_get_xact_tuples_hot_updated(c.oid)             AS n_tup_hot_upd
FROM ((pg_class c
    LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]))
GROUP BY c.oid, n.nspname, c.relname;

alter table pg_catalog.pg_stat_xact_all_tables
    owner to postgres;

create view pg_catalog.pg_stat_sys_tables(relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch,
                                          n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup,
                                          n_mod_since_analyze, last_vacuum, last_autovacuum, last_analyze,
                                          last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
                                          autoanalyze_count) as
SELECT pg_stat_all_tables.relid,
       pg_stat_all_tables.schemaname,
       pg_stat_all_tables.relname,
       pg_stat_all_tables.seq_scan,
       pg_stat_all_tables.seq_tup_read,
       pg_stat_all_tables.idx_scan,
       pg_stat_all_tables.idx_tup_fetch,
       pg_stat_all_tables.n_tup_ins,
       pg_stat_all_tables.n_tup_upd,
       pg_stat_all_tables.n_tup_del,
       pg_stat_all_tables.n_tup_hot_upd,
       pg_stat_all_tables.n_live_tup,
       pg_stat_all_tables.n_dead_tup,
       pg_stat_all_tables.n_mod_since_analyze,
       pg_stat_all_tables.last_vacuum,
       pg_stat_all_tables.last_autovacuum,
       pg_stat_all_tables.last_analyze,
       pg_stat_all_tables.last_autoanalyze,
       pg_stat_all_tables.vacuum_count,
       pg_stat_all_tables.autovacuum_count,
       pg_stat_all_tables.analyze_count,
       pg_stat_all_tables.autoanalyze_count
FROM pg_stat_all_tables
WHERE ((pg_stat_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name])) OR
       (pg_stat_all_tables.schemaname ~ '^pg_toast'::text));

alter table pg_catalog.pg_stat_sys_tables
    owner to postgres;

create view pg_catalog.pg_stat_xact_sys_tables(relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan,
                                               idx_tup_fetch, n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd) as
SELECT pg_stat_xact_all_tables.relid,
       pg_stat_xact_all_tables.schemaname,
       pg_stat_xact_all_tables.relname,
       pg_stat_xact_all_tables.seq_scan,
       pg_stat_xact_all_tables.seq_tup_read,
       pg_stat_xact_all_tables.idx_scan,
       pg_stat_xact_all_tables.idx_tup_fetch,
       pg_stat_xact_all_tables.n_tup_ins,
       pg_stat_xact_all_tables.n_tup_upd,
       pg_stat_xact_all_tables.n_tup_del,
       pg_stat_xact_all_tables.n_tup_hot_upd
FROM pg_stat_xact_all_tables
WHERE ((pg_stat_xact_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name])) OR
       (pg_stat_xact_all_tables.schemaname ~ '^pg_toast'::text));

alter table pg_catalog.pg_stat_xact_sys_tables
    owner to postgres;

create view pg_catalog.pg_stat_user_tables(relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch,
                                           n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup,
                                           n_mod_since_analyze, last_vacuum, last_autovacuum, last_analyze,
                                           last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
                                           autoanalyze_count) as
SELECT pg_stat_all_tables.relid,
       pg_stat_all_tables.schemaname,
       pg_stat_all_tables.relname,
       pg_stat_all_tables.seq_scan,
       pg_stat_all_tables.seq_tup_read,
       pg_stat_all_tables.idx_scan,
       pg_stat_all_tables.idx_tup_fetch,
       pg_stat_all_tables.n_tup_ins,
       pg_stat_all_tables.n_tup_upd,
       pg_stat_all_tables.n_tup_del,
       pg_stat_all_tables.n_tup_hot_upd,
       pg_stat_all_tables.n_live_tup,
       pg_stat_all_tables.n_dead_tup,
       pg_stat_all_tables.n_mod_since_analyze,
       pg_stat_all_tables.last_vacuum,
       pg_stat_all_tables.last_autovacuum,
       pg_stat_all_tables.last_analyze,
       pg_stat_all_tables.last_autoanalyze,
       pg_stat_all_tables.vacuum_count,
       pg_stat_all_tables.autovacuum_count,
       pg_stat_all_tables.analyze_count,
       pg_stat_all_tables.autoanalyze_count
FROM pg_stat_all_tables
WHERE ((pg_stat_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name])) AND
       (pg_stat_all_tables.schemaname !~ '^pg_toast'::text));

alter table pg_catalog.pg_stat_user_tables
    owner to postgres;

create view pg_catalog.pg_stat_xact_user_tables(relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan,
                                                idx_tup_fetch, n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd) as
SELECT pg_stat_xact_all_tables.relid,
       pg_stat_xact_all_tables.schemaname,
       pg_stat_xact_all_tables.relname,
       pg_stat_xact_all_tables.seq_scan,
       pg_stat_xact_all_tables.seq_tup_read,
       pg_stat_xact_all_tables.idx_scan,
       pg_stat_xact_all_tables.idx_tup_fetch,
       pg_stat_xact_all_tables.n_tup_ins,
       pg_stat_xact_all_tables.n_tup_upd,
       pg_stat_xact_all_tables.n_tup_del,
       pg_stat_xact_all_tables.n_tup_hot_upd
FROM pg_stat_xact_all_tables
WHERE ((pg_stat_xact_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name])) AND
       (pg_stat_xact_all_tables.schemaname !~ '^pg_toast'::text));

alter table pg_catalog.pg_stat_xact_user_tables
    owner to postgres;

create view pg_catalog.pg_statio_all_tables(relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read,
                                            idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read,
                                            tidx_blks_hit) as
SELECT c.oid                                                               AS relid,
       n.nspname                                                           AS schemaname,
       c.relname,
       (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read,
       pg_stat_get_blocks_hit(c.oid)                                       AS heap_blks_hit,
       (sum((pg_stat_get_blocks_fetched(i.indexrelid) -
             pg_stat_get_blocks_hit(i.indexrelid))))::bigint               AS idx_blks_read,
       (sum(pg_stat_get_blocks_hit(i.indexrelid)))::bigint                 AS idx_blks_hit,
       (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read,
       pg_stat_get_blocks_hit(t.oid)                                       AS toast_blks_hit,
       (sum((pg_stat_get_blocks_fetched(x.indexrelid) -
             pg_stat_get_blocks_hit(x.indexrelid))))::bigint               AS tidx_blks_read,
       (sum(pg_stat_get_blocks_hit(x.indexrelid)))::bigint                 AS tidx_blks_hit
FROM ((((pg_class c
    LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))
    LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid)))
    LEFT JOIN pg_index x ON ((t.oid = x.indrelid)))
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]))
GROUP BY c.oid, n.nspname, c.relname, t.oid, x.indrelid;

alter table pg_catalog.pg_statio_all_tables
    owner to postgres;

create view pg_catalog.pg_statio_sys_tables(relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read,
                                            idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read,
                                            tidx_blks_hit) as
SELECT pg_statio_all_tables.relid,
       pg_statio_all_tables.schemaname,
       pg_statio_all_tables.relname,
       pg_statio_all_tables.heap_blks_read,
       pg_statio_all_tables.heap_blks_hit,
       pg_statio_all_tables.idx_blks_read,
       pg_statio_all_tables.idx_blks_hit,
       pg_statio_all_tables.toast_blks_read,
       pg_statio_all_tables.toast_blks_hit,
       pg_statio_all_tables.tidx_blks_read,
       pg_statio_all_tables.tidx_blks_hit
FROM pg_statio_all_tables
WHERE ((pg_statio_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name])) OR
       (pg_statio_all_tables.schemaname ~ '^pg_toast'::text));

alter table pg_catalog.pg_statio_sys_tables
    owner to postgres;

create view pg_catalog.pg_statio_user_tables(relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read,
                                             idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read,
                                             tidx_blks_hit) as
SELECT pg_statio_all_tables.relid,
       pg_statio_all_tables.schemaname,
       pg_statio_all_tables.relname,
       pg_statio_all_tables.heap_blks_read,
       pg_statio_all_tables.heap_blks_hit,
       pg_statio_all_tables.idx_blks_read,
       pg_statio_all_tables.idx_blks_hit,
       pg_statio_all_tables.toast_blks_read,
       pg_statio_all_tables.toast_blks_hit,
       pg_statio_all_tables.tidx_blks_read,
       pg_statio_all_tables.tidx_blks_hit
FROM pg_statio_all_tables
WHERE ((pg_statio_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name])) AND
       (pg_statio_all_tables.schemaname !~ '^pg_toast'::text));

alter table pg_catalog.pg_statio_user_tables
    owner to postgres;

create view pg_catalog.pg_stat_all_indexes(relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read,
                                           idx_tup_fetch) as
SELECT c.oid                              AS relid,
       i.oid                              AS indexrelid,
       n.nspname                          AS schemaname,
       c.relname,
       i.relname                          AS indexrelname,
       pg_stat_get_numscans(i.oid)        AS idx_scan,
       pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,
       pg_stat_get_tuples_fetched(i.oid)  AS idx_tup_fetch
FROM (((pg_class c
    JOIN pg_index x ON ((c.oid = x.indrelid)))
    JOIN pg_class i ON ((i.oid = x.indexrelid)))
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]));

alter table pg_catalog.pg_stat_all_indexes
    owner to postgres;

create view pg_catalog.pg_stat_sys_indexes(relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read,
                                           idx_tup_fetch) as
SELECT pg_stat_all_indexes.relid,
       pg_stat_all_indexes.indexrelid,
       pg_stat_all_indexes.schemaname,
       pg_stat_all_indexes.relname,
       pg_stat_all_indexes.indexrelname,
       pg_stat_all_indexes.idx_scan,
       pg_stat_all_indexes.idx_tup_read,
       pg_stat_all_indexes.idx_tup_fetch
FROM pg_stat_all_indexes
WHERE ((pg_stat_all_indexes.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name])) OR
       (pg_stat_all_indexes.schemaname ~ '^pg_toast'::text));

alter table pg_catalog.pg_stat_sys_indexes
    owner to postgres;

create view pg_catalog.pg_stat_user_indexes(relid, indexrelid, schemaname, relname, indexrelname, idx_scan,
                                            idx_tup_read, idx_tup_fetch) as
SELECT pg_stat_all_indexes.relid,
       pg_stat_all_indexes.indexrelid,
       pg_stat_all_indexes.schemaname,
       pg_stat_all_indexes.relname,
       pg_stat_all_indexes.indexrelname,
       pg_stat_all_indexes.idx_scan,
       pg_stat_all_indexes.idx_tup_read,
       pg_stat_all_indexes.idx_tup_fetch
FROM pg_stat_all_indexes
WHERE ((pg_stat_all_indexes.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name])) AND
       (pg_stat_all_indexes.schemaname !~ '^pg_toast'::text));

alter table pg_catalog.pg_stat_user_indexes
    owner to postgres;

create view pg_catalog.pg_statio_all_indexes(relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read,
                                             idx_blks_hit) as
SELECT c.oid                                                               AS relid,
       i.oid                                                               AS indexrelid,
       n.nspname                                                           AS schemaname,
       c.relname,
       i.relname                                                           AS indexrelname,
       (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read,
       pg_stat_get_blocks_hit(i.oid)                                       AS idx_blks_hit
FROM (((pg_class c
    JOIN pg_index x ON ((c.oid = x.indrelid)))
    JOIN pg_class i ON ((i.oid = x.indexrelid)))
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]));

alter table pg_catalog.pg_statio_all_indexes
    owner to postgres;

create view pg_catalog.pg_statio_sys_indexes(relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read,
                                             idx_blks_hit) as
SELECT pg_statio_all_indexes.relid,
       pg_statio_all_indexes.indexrelid,
       pg_statio_all_indexes.schemaname,
       pg_statio_all_indexes.relname,
       pg_statio_all_indexes.indexrelname,
       pg_statio_all_indexes.idx_blks_read,
       pg_statio_all_indexes.idx_blks_hit
FROM pg_statio_all_indexes
WHERE ((pg_statio_all_indexes.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name])) OR
       (pg_statio_all_indexes.schemaname ~ '^pg_toast'::text));

alter table pg_catalog.pg_statio_sys_indexes
    owner to postgres;

create view pg_catalog.pg_statio_user_indexes(relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read,
                                              idx_blks_hit) as
SELECT pg_statio_all_indexes.relid,
       pg_statio_all_indexes.indexrelid,
       pg_statio_all_indexes.schemaname,
       pg_statio_all_indexes.relname,
       pg_statio_all_indexes.indexrelname,
       pg_statio_all_indexes.idx_blks_read,
       pg_statio_all_indexes.idx_blks_hit
FROM pg_statio_all_indexes
WHERE ((pg_statio_all_indexes.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name])) AND
       (pg_statio_all_indexes.schemaname !~ '^pg_toast'::text));

alter table pg_catalog.pg_statio_user_indexes
    owner to postgres;

create view pg_catalog.pg_statio_all_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT c.oid                                                               AS relid,
       n.nspname                                                           AS schemaname,
       c.relname,
       (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read,
       pg_stat_get_blocks_hit(c.oid)                                       AS blks_hit
FROM (pg_class c
         LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
WHERE (c.relkind = 'S'::"char");

alter table pg_catalog.pg_statio_all_sequences
    owner to postgres;

create view pg_catalog.pg_statio_sys_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT pg_statio_all_sequences.relid,
       pg_statio_all_sequences.schemaname,
       pg_statio_all_sequences.relname,
       pg_statio_all_sequences.blks_read,
       pg_statio_all_sequences.blks_hit
FROM pg_statio_all_sequences
WHERE ((pg_statio_all_sequences.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name])) OR
       (pg_statio_all_sequences.schemaname ~ '^pg_toast'::text));

alter table pg_catalog.pg_statio_sys_sequences
    owner to postgres;

create view pg_catalog.pg_statio_user_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT pg_statio_all_sequences.relid,
       pg_statio_all_sequences.schemaname,
       pg_statio_all_sequences.relname,
       pg_statio_all_sequences.blks_read,
       pg_statio_all_sequences.blks_hit
FROM pg_statio_all_sequences
WHERE ((pg_statio_all_sequences.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name])) AND
       (pg_statio_all_sequences.schemaname !~ '^pg_toast'::text));

alter table pg_catalog.pg_statio_user_sequences
    owner to postgres;

create view pg_catalog.pg_stat_activity(datid, datname, pid, usesysid, usename, application_name, client_addr,
                                        client_hostname, client_port, backend_start, xact_start, query_start,
                                        state_change, wait_event_type, wait_event, state, backend_xid, backend_xmin,
                                        query) as
SELECT s.datid,
       d.datname,
       s.pid,
       s.usesysid,
       u.rolname AS usename,
       s.application_name,
       s.client_addr,
       s.client_hostname,
       s.client_port,
       s.backend_start,
       s.xact_start,
       s.query_start,
       s.state_change,
       s.wait_event_type,
       s.wait_event,
       s.state,
       s.backend_xid,
       s.backend_xmin,
       s.query
FROM pg_database d,
     pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin, ssl,
                                           sslversion, sslcipher, sslbits, sslcompression, sslclientdn),
     pg_authid u
WHERE ((s.datid = d.oid) AND (s.usesysid = u.oid));

alter table pg_catalog.pg_stat_activity
    owner to postgres;

create view pg_catalog.pg_stat_replication(pid, usesysid, usename, application_name, client_addr, client_hostname,
                                           client_port, backend_start, backend_xmin, state, sent_location,
                                           write_location, flush_location, replay_location, sync_priority,
                                           sync_state) as
SELECT s.pid,
       s.usesysid,
       u.rolname AS usename,
       s.application_name,
       s.client_addr,
       s.client_hostname,
       s.client_port,
       s.backend_start,
       s.backend_xmin,
       w.state,
       w.sent_location,
       w.write_location,
       w.flush_location,
       w.replay_location,
       w.sync_priority,
       w.sync_state
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin, ssl,
                                           sslversion, sslcipher, sslbits, sslcompression, sslclientdn),
     pg_authid u,
     pg_stat_get_wal_senders() w(pid, state, sent_location, write_location, flush_location, replay_location,
                                 sync_priority, sync_state)
WHERE ((s.usesysid = u.oid) AND (s.pid = w.pid));

alter table pg_catalog.pg_stat_replication
    owner to postgres;

create view pg_catalog.pg_stat_wal_receiver(pid, status, receive_start_lsn, receive_start_tli, received_lsn,
                                            received_tli, last_msg_send_time, last_msg_receipt_time, latest_end_lsn,
                                            latest_end_time, slot_name, conninfo) as
SELECT s.pid,
       s.status,
       s.receive_start_lsn,
       s.receive_start_tli,
       s.received_lsn,
       s.received_tli,
       s.last_msg_send_time,
       s.last_msg_receipt_time,
       s.latest_end_lsn,
       s.latest_end_time,
       s.slot_name,
       s.conninfo
FROM pg_stat_get_wal_receiver() s(pid, status, receive_start_lsn, receive_start_tli, received_lsn, received_tli,
                                  last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name,
                                  conninfo)
WHERE (s.pid IS NOT NULL);

alter table pg_catalog.pg_stat_wal_receiver
    owner to postgres;

create view pg_catalog.pg_stat_ssl(pid, ssl, version, cipher, bits, compression, clientdn) as
SELECT s.pid,
       s.ssl,
       s.sslversion     AS version,
       s.sslcipher      AS cipher,
       s.sslbits        AS bits,
       s.sslcompression AS compression,
       s.sslclientdn    AS clientdn
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin, ssl,
                                           sslversion, sslcipher, sslbits, sslcompression, sslclientdn);

alter table pg_catalog.pg_stat_ssl
    owner to postgres;

create view pg_catalog.pg_replication_slots(slot_name, plugin, slot_type, datoid, database, active, active_pid, xmin,
                                            catalog_xmin, restart_lsn, confirmed_flush_lsn) as
SELECT l.slot_name,
       l.plugin,
       l.slot_type,
       l.datoid,
       d.datname AS database,
       l.active,
       l.active_pid,
       l.xmin,
       l.catalog_xmin,
       l.restart_lsn,
       l.confirmed_flush_lsn
FROM (pg_get_replication_slots() l
      (slot_name, plugin, slot_type, datoid, active, active_pid, xmin, catalog_xmin, restart_lsn, confirmed_flush_lsn)
         LEFT JOIN pg_database d ON ((l.datoid = d.oid)));

alter table pg_catalog.pg_replication_slots
    owner to postgres;

create view pg_catalog.pg_stat_database(datid, datname, numbackends, xact_commit, xact_rollback, blks_read, blks_hit,
                                        tup_returned, tup_fetched, tup_inserted, tup_updated, tup_deleted, conflicts,
                                        temp_files, temp_bytes, deadlocks, blk_read_time, blk_write_time,
                                        stats_reset) as
SELECT d.oid                                                                     AS datid,
       d.datname,
       pg_stat_get_db_numbackends(d.oid)                                         AS numbackends,
       pg_stat_get_db_xact_commit(d.oid)                                         AS xact_commit,
       pg_stat_get_db_xact_rollback(d.oid)                                       AS xact_rollback,
       (pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid)) AS blks_read,
       pg_stat_get_db_blocks_hit(d.oid)                                          AS blks_hit,
       pg_stat_get_db_tuples_returned(d.oid)                                     AS tup_returned,
       pg_stat_get_db_tuples_fetched(d.oid)                                      AS tup_fetched,
       pg_stat_get_db_tuples_inserted(d.oid)                                     AS tup_inserted,
       pg_stat_get_db_tuples_updated(d.oid)                                      AS tup_updated,
       pg_stat_get_db_tuples_deleted(d.oid)                                      AS tup_deleted,
       pg_stat_get_db_conflict_all(d.oid)                                        AS conflicts,
       pg_stat_get_db_temp_files(d.oid)                                          AS temp_files,
       pg_stat_get_db_temp_bytes(d.oid)                                          AS temp_bytes,
       pg_stat_get_db_deadlocks(d.oid)                                           AS deadlocks,
       pg_stat_get_db_blk_read_time(d.oid)                                       AS blk_read_time,
       pg_stat_get_db_blk_write_time(d.oid)                                      AS blk_write_time,
       pg_stat_get_db_stat_reset_time(d.oid)                                     AS stats_reset
FROM pg_database d;

alter table pg_catalog.pg_stat_database
    owner to postgres;

create view pg_catalog.pg_stat_database_conflicts(datid, datname, confl_tablespace, confl_lock, confl_snapshot,
                                                  confl_bufferpin, confl_deadlock) as
SELECT d.oid                                           AS datid,
       d.datname,
       pg_stat_get_db_conflict_tablespace(d.oid)       AS confl_tablespace,
       pg_stat_get_db_conflict_lock(d.oid)             AS confl_lock,
       pg_stat_get_db_conflict_snapshot(d.oid)         AS confl_snapshot,
       pg_stat_get_db_conflict_bufferpin(d.oid)        AS confl_bufferpin,
       pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock
FROM pg_database d;

alter table pg_catalog.pg_stat_database_conflicts
    owner to postgres;

create view pg_catalog.pg_stat_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
SELECT p.oid                                  AS funcid,
       n.nspname                              AS schemaname,
       p.proname                              AS funcname,
       pg_stat_get_function_calls(p.oid)      AS calls,
       pg_stat_get_function_total_time(p.oid) AS total_time,
       pg_stat_get_function_self_time(p.oid)  AS self_time
FROM (pg_proc p
         LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));

alter table pg_catalog.pg_stat_user_functions
    owner to postgres;

create view pg_catalog.pg_stat_xact_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
SELECT p.oid                                       AS funcid,
       n.nspname                                   AS schemaname,
       p.proname                                   AS funcname,
       pg_stat_get_xact_function_calls(p.oid)      AS calls,
       pg_stat_get_xact_function_total_time(p.oid) AS total_time,
       pg_stat_get_xact_function_self_time(p.oid)  AS self_time
FROM (pg_proc p
         LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))
WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_xact_function_calls(p.oid) IS NOT NULL));

alter table pg_catalog.pg_stat_xact_user_functions
    owner to postgres;

create view pg_catalog.pg_stat_archiver(archived_count, last_archived_wal, last_archived_time, failed_count,
                                        last_failed_wal, last_failed_time, stats_reset) as
SELECT s.archived_count,
       s.last_archived_wal,
       s.last_archived_time,
       s.failed_count,
       s.last_failed_wal,
       s.last_failed_time,
       s.stats_reset
FROM pg_stat_get_archiver() s(archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal,
                              last_failed_time, stats_reset);

alter table pg_catalog.pg_stat_archiver
    owner to postgres;

create view pg_catalog.pg_stat_bgwriter(checkpoints_timed, checkpoints_req, checkpoint_write_time, checkpoint_sync_time,
                                        buffers_checkpoint, buffers_clean, maxwritten_clean, buffers_backend,
                                        buffers_backend_fsync, buffers_alloc, stats_reset) as
SELECT pg_stat_get_bgwriter_timed_checkpoints()       AS checkpoints_timed,
       pg_stat_get_bgwriter_requested_checkpoints()   AS checkpoints_req,
       pg_stat_get_checkpoint_write_time()            AS checkpoint_write_time,
       pg_stat_get_checkpoint_sync_time()             AS checkpoint_sync_time,
       pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,
       pg_stat_get_bgwriter_buf_written_clean()       AS buffers_clean,
       pg_stat_get_bgwriter_maxwritten_clean()        AS maxwritten_clean,
       pg_stat_get_buf_written_backend()              AS buffers_backend,
       pg_stat_get_buf_fsync_backend()                AS buffers_backend_fsync,
       pg_stat_get_buf_alloc()                        AS buffers_alloc,
       pg_stat_get_bgwriter_stat_reset_time()         AS stats_reset;

alter table pg_catalog.pg_stat_bgwriter
    owner to postgres;

create view pg_catalog.pg_stat_progress_vacuum(pid, datid, datname, relid, phase, heap_blks_total, heap_blks_scanned,
                                               heap_blks_vacuumed, index_vacuum_count, max_dead_tuples,
                                               num_dead_tuples) as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       CASE s.param1
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'scanning heap'::text
           WHEN 2 THEN 'vacuuming indexes'::text
           WHEN 3 THEN 'vacuuming heap'::text
           WHEN 4 THEN 'cleaning up indexes'::text
           WHEN 5 THEN 'truncating heap'::text
           WHEN 6 THEN 'performing final cleanup'::text
           ELSE NULL::text
           END  AS phase,
       s.param2 AS heap_blks_total,
       s.param3 AS heap_blks_scanned,
       s.param4 AS heap_blks_vacuumed,
       s.param5 AS index_vacuum_count,
       s.param6 AS max_dead_tuples,
       s.param7 AS num_dead_tuples
FROM (pg_stat_get_progress_info('VACUUM'::text) s
      (pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)
         JOIN pg_database d ON ((s.datid = d.oid)));

alter table pg_catalog.pg_stat_progress_vacuum
    owner to postgres;

create view pg_catalog.pg_user_mappings(umid, srvid, srvname, umuser, usename, umoptions) as
SELECT u.oid   AS umid,
       s.oid   AS srvid,
       s.srvname,
       u.umuser,
       CASE
           WHEN (u.umuser = (0)::oid) THEN 'public'::name
           ELSE a.rolname
           END AS usename,
       CASE
           WHEN (((u.umuser <> (0)::oid) AND (a.rolname = "current_user"()) AND
                  (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text))) OR
                 ((u.umuser = (0)::oid) AND pg_has_role(s.srvowner, 'USAGE'::text)) OR (SELECT pg_authid.rolsuper
                                                                                        FROM pg_authid
                                                                                        WHERE (pg_authid.rolname = "current_user"())))
               THEN u.umoptions
           ELSE NULL::text[]
           END AS umoptions
FROM ((pg_user_mapping u
    LEFT JOIN pg_authid a ON ((a.oid = u.umuser)))
         JOIN pg_foreign_server s ON ((u.umserver = s.oid)));

alter table pg_catalog.pg_user_mappings
    owner to postgres;

create view pg_catalog.pg_replication_origin_status(local_id, external_id, remote_lsn, local_lsn) as
SELECT pg_show_replication_origin_status.local_id,
       pg_show_replication_origin_status.external_id,
       pg_show_replication_origin_status.remote_lsn,
       pg_show_replication_origin_status.local_lsn
FROM pg_show_replication_origin_status() pg_show_replication_origin_status(local_id, external_id, remote_lsn, local_lsn);

alter table pg_catalog.pg_replication_origin_status
    owner to postgres;

create view information_schema.information_schema_catalog_name(catalog_name) as
SELECT (current_database())::information_schema.sql_identifier AS catalog_name;

alter table information_schema.information_schema_catalog_name
    owner to postgres;

create view information_schema.applicable_roles(grantee, role_name, is_grantable) as
SELECT (a.rolname)::information_schema.sql_identifier AS grantee,
       (b.rolname)::information_schema.sql_identifier AS role_name,
       (
           CASE
               WHEN m.admin_option THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no     AS is_grantable
FROM ((pg_auth_members m
    JOIN pg_authid a ON ((m.member = a.oid)))
         JOIN pg_authid b ON ((m.roleid = b.oid)))
WHERE pg_has_role(a.oid, 'USAGE'::text);

alter table information_schema.applicable_roles
    owner to postgres;

create view information_schema.administrable_role_authorizations(grantee, role_name, is_grantable) as
SELECT applicable_roles.grantee,
       applicable_roles.role_name,
       applicable_roles.is_grantable
FROM information_schema.applicable_roles
WHERE ((applicable_roles.is_grantable)::text = 'YES'::text);

alter table information_schema.administrable_role_authorizations
    owner to postgres;

create view information_schema.attributes(udt_catalog, udt_schema, udt_name, attribute_name, ordinal_position,
                                          attribute_default, is_nullable, data_type, character_maximum_length,
                                          character_octet_length, character_set_catalog, character_set_schema,
                                          character_set_name, collation_catalog, collation_schema, collation_name,
                                          numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision,
                                          interval_type, interval_precision, attribute_udt_catalog,
                                          attribute_udt_schema, attribute_udt_name, scope_catalog, scope_schema,
                                          scope_name, maximum_cardinality, dtd_identifier,
                                          is_derived_reference_attribute) as
SELECT (current_database())::information_schema.sql_identifier                                                                           AS udt_catalog,
       (nc.nspname)::information_schema.sql_identifier                                                                                   AS udt_schema,
       (c.relname)::information_schema.sql_identifier                                                                                    AS udt_name,
       (a.attname)::information_schema.sql_identifier                                                                                    AS attribute_name,
       (a.attnum)::information_schema.cardinal_number                                                                                    AS ordinal_position,
       (pg_get_expr(ad.adbin, ad.adrelid))::information_schema.character_data                                                            AS attribute_default,
       (
           CASE
               WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text
               ELSE 'YES'::text
               END)::information_schema.yes_or_no                                                                                        AS is_nullable,
       (
           CASE
               WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
               WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer)
               ELSE 'USER-DEFINED'::text
               END)::information_schema.character_data                                                                                   AS data_type,
       (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number         AS character_maximum_length,
       (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number       AS character_octet_length,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS character_set_schema,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS character_set_name,
       (
           CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL::name
               END)::information_schema.sql_identifier                                                                                   AS collation_catalog,
       (nco.nspname)::information_schema.sql_identifier                                                                                  AS collation_schema,
       (co.collname)::information_schema.sql_identifier                                                                                  AS collation_name,
       (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number       AS numeric_precision,
       (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                       information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision_radix,
       (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                             information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number           AS numeric_scale,
       (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                  information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number      AS datetime_precision,
       (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                             information_schema._pg_truetypmod(a.*, t.*)))::information_schema.character_data            AS interval_type,
       (NULL::integer)::information_schema.cardinal_number                                                                               AS interval_precision,
       (current_database())::information_schema.sql_identifier                                                                           AS attribute_udt_catalog,
       (nt.nspname)::information_schema.sql_identifier                                                                                   AS attribute_udt_schema,
       (t.typname)::information_schema.sql_identifier                                                                                    AS attribute_udt_name,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS scope_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS scope_schema,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS scope_name,
       (NULL::integer)::information_schema.cardinal_number                                                                               AS maximum_cardinality,
       (a.attnum)::information_schema.sql_identifier                                                                                     AS dtd_identifier,
       ('NO'::character varying)::information_schema.yes_or_no                                                                           AS is_derived_reference_attribute
FROM ((((pg_attribute a
    LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
    JOIN (pg_class c
        JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
    JOIN (pg_type t
        JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND
                                                                  ((nco.nspname <> 'pg_catalog'::name) OR
                                                                   (co.collname <> 'default'::name)))))
WHERE ((a.attnum > 0) AND (NOT a.attisdropped) AND (c.relkind = 'c'::"char") AND
       (pg_has_role(c.relowner, 'USAGE'::text) OR has_type_privilege(c.reltype, 'USAGE'::text)));

alter table information_schema.attributes
    owner to postgres;

create view information_schema.character_sets(character_set_catalog, character_set_schema, character_set_name,
                                              character_repertoire, form_of_use, default_collate_catalog,
                                              default_collate_schema, default_collate_name) as
SELECT (NULL::character varying)::information_schema.sql_identifier AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier AS character_set_schema,
       (getdatabaseencoding())::information_schema.sql_identifier   AS character_set_name,
       (
           CASE
               WHEN (getdatabaseencoding() = 'UTF8'::name) THEN 'UCS'::name
               ELSE getdatabaseencoding()
               END)::information_schema.sql_identifier              AS character_repertoire,
       (getdatabaseencoding())::information_schema.sql_identifier   AS form_of_use,
       (current_database())::information_schema.sql_identifier      AS default_collate_catalog,
       (nc.nspname)::information_schema.sql_identifier              AS default_collate_schema,
       (c.collname)::information_schema.sql_identifier              AS default_collate_name
FROM (pg_database d
         LEFT JOIN (pg_collation c
    JOIN pg_namespace nc ON ((c.collnamespace = nc.oid)))
                   ON (((d.datcollate = c.collcollate) AND (d.datctype = c.collctype))))
WHERE (d.datname = current_database())
ORDER BY (char_length((c.collname)::text)) DESC, c.collname
LIMIT 1;

alter table information_schema.character_sets
    owner to postgres;

create view information_schema.check_constraint_routine_usage(constraint_catalog, constraint_schema, constraint_name,
                                                              specific_catalog, specific_schema, specific_name) as
SELECT (current_database())::information_schema.sql_identifier                                  AS constraint_catalog,
       (nc.nspname)::information_schema.sql_identifier                                          AS constraint_schema,
       (c.conname)::information_schema.sql_identifier                                           AS constraint_name,
       (current_database())::information_schema.sql_identifier                                  AS specific_catalog,
       (np.nspname)::information_schema.sql_identifier                                          AS specific_schema,
       ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name
FROM pg_namespace nc,
     pg_constraint c,
     pg_depend d,
     pg_proc p,
     pg_namespace np
WHERE ((nc.oid = c.connamespace) AND (c.contype = 'c'::"char") AND (c.oid = d.objid) AND
       (d.classid = ('pg_constraint'::regclass)::oid) AND (d.refobjid = p.oid) AND
       (d.refclassid = ('pg_proc'::regclass)::oid) AND (p.pronamespace = np.oid) AND
       pg_has_role(p.proowner, 'USAGE'::text));

alter table information_schema.check_constraint_routine_usage
    owner to postgres;

create view information_schema.check_constraints(constraint_catalog, constraint_schema, constraint_name, check_clause) as
    SELECT (current_database())::information_schema.sql_identifier                            AS constraint_catalog,
           (rs.nspname)::information_schema.sql_identifier                                    AS constraint_schema,
           (con.conname)::information_schema.sql_identifier                                   AS constraint_name,
           ("substring"(pg_get_constraintdef(con.oid), 7))::information_schema.character_data AS check_clause
    FROM (((pg_constraint con
        LEFT JOIN pg_namespace rs ON ((rs.oid = con.connamespace)))
        LEFT JOIN pg_class c ON ((c.oid = con.conrelid)))
             LEFT JOIN pg_type t ON ((t.oid = con.contypid)))
    WHERE (pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE'::text) AND (con.contype = 'c'::"char"))
    UNION
    SELECT (current_database())::information_schema.sql_identifier                          AS constraint_catalog,
           (n.nspname)::information_schema.sql_identifier                                   AS constraint_schema,
           (((((((n.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) ||
             '_not_null'::text))::information_schema.sql_identifier                         AS constraint_name,
           (((a.attname)::text || ' IS NOT NULL'::text))::information_schema.character_data AS check_clause
    FROM pg_namespace n,
         pg_class r,
         pg_attribute a
    WHERE ((n.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (a.attnum > 0) AND (NOT a.attisdropped) AND
           a.attnotnull AND (r.relkind = 'r'::"char") AND pg_has_role(r.relowner, 'USAGE'::text));

alter table information_schema.check_constraints
    owner to postgres;

create view information_schema.collations(collation_catalog, collation_schema, collation_name, pad_attribute) as
SELECT (current_database())::information_schema.sql_identifier          AS collation_catalog,
       (nc.nspname)::information_schema.sql_identifier                  AS collation_schema,
       (c.collname)::information_schema.sql_identifier                  AS collation_name,
       ('NO PAD'::character varying)::information_schema.character_data AS pad_attribute
FROM pg_collation c,
     pg_namespace nc
WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                                                    FROM pg_database
                                                                                    WHERE (pg_database.datname = current_database()))])));

alter table information_schema.collations
    owner to postgres;

create view information_schema.collation_character_set_applicability(collation_catalog, collation_schema,
                                                                     collation_name, character_set_catalog,
                                                                     character_set_schema, character_set_name) as
SELECT (current_database())::information_schema.sql_identifier      AS collation_catalog,
       (nc.nspname)::information_schema.sql_identifier              AS collation_schema,
       (c.collname)::information_schema.sql_identifier              AS collation_name,
       (NULL::character varying)::information_schema.sql_identifier AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier AS character_set_schema,
       (getdatabaseencoding())::information_schema.sql_identifier   AS character_set_name
FROM pg_collation c,
     pg_namespace nc
WHERE ((c.collnamespace = nc.oid) AND (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                                                    FROM pg_database
                                                                                    WHERE (pg_database.datname = current_database()))])));

alter table information_schema.collation_character_set_applicability
    owner to postgres;

create view information_schema.column_domain_usage(domain_catalog, domain_schema, domain_name, table_catalog,
                                                   table_schema, table_name, column_name) as
SELECT (current_database())::information_schema.sql_identifier AS domain_catalog,
       (nt.nspname)::information_schema.sql_identifier         AS domain_schema,
       (t.typname)::information_schema.sql_identifier          AS domain_name,
       (current_database())::information_schema.sql_identifier AS table_catalog,
       (nc.nspname)::information_schema.sql_identifier         AS table_schema,
       (c.relname)::information_schema.sql_identifier          AS table_name,
       (a.attname)::information_schema.sql_identifier          AS column_name
FROM pg_type t,
     pg_namespace nt,
     pg_class c,
     pg_namespace nc,
     pg_attribute a
WHERE ((t.typnamespace = nt.oid) AND (c.relnamespace = nc.oid) AND (a.attrelid = c.oid) AND (a.atttypid = t.oid) AND
       (t.typtype = 'd'::"char") AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"])) AND
       (a.attnum > 0) AND (NOT a.attisdropped) AND pg_has_role(t.typowner, 'USAGE'::text));

alter table information_schema.column_domain_usage
    owner to postgres;

create view information_schema.column_privileges(grantor, grantee, table_catalog, table_schema, table_name, column_name,
                                                 privilege_type, is_grantable) as
SELECT (u_grantor.rolname)::information_schema.sql_identifier  AS grantor,
       (grantee.rolname)::information_schema.sql_identifier    AS grantee,
       (current_database())::information_schema.sql_identifier AS table_catalog,
       (nc.nspname)::information_schema.sql_identifier         AS table_schema,
       (x.relname)::information_schema.sql_identifier          AS table_name,
       (x.attname)::information_schema.sql_identifier          AS column_name,
       (x.prtype)::information_schema.character_data           AS privilege_type,
       (
           CASE
               WHEN (pg_has_role(x.grantee, x.relowner, 'USAGE'::text) OR x.grantable) THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS is_grantable
FROM (SELECT pr_c.grantor,
             pr_c.grantee,
             a.attname,
             pr_c.relname,
             pr_c.relnamespace,
             pr_c.prtype,
             pr_c.grantable,
             pr_c.relowner
      FROM (SELECT pg_class.oid,
                   pg_class.relname,
                   pg_class.relnamespace,
                   pg_class.relowner,
                   (aclexplode(
                           COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).grantee              AS grantee,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).privilege_type       AS privilege_type,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).is_grantable         AS is_grantable
            FROM pg_class
            WHERE (pg_class.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"]))) pr_c(oid, relname,
                                                                                                 relnamespace, relowner,
                                                                                                 grantor, grantee,
                                                                                                 prtype, grantable),
           pg_attribute a
      WHERE ((a.attrelid = pr_c.oid) AND (a.attnum > 0) AND (NOT a.attisdropped))
      UNION
      SELECT pr_a.grantor,
             pr_a.grantee,
             pr_a.attname,
             c.relname,
             c.relnamespace,
             pr_a.prtype,
             pr_a.grantable,
             c.relowner
      FROM (SELECT a.attrelid,
                   a.attname,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantor      AS grantor,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantee      AS grantee,
                   (aclexplode(
                           COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).privilege_type   AS privilege_type,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).is_grantable AS is_grantable
            FROM (pg_attribute a
                     JOIN pg_class cc ON ((a.attrelid = cc.oid)))
            WHERE ((a.attnum > 0) AND (NOT a.attisdropped))) pr_a(attrelid, attname, grantor, grantee, prtype, grantable),
           pg_class c
      WHERE ((pr_a.attrelid = c.oid) AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"])))) x,
     pg_namespace nc,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT (0)::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE ((x.relnamespace = nc.oid) AND (x.grantee = grantee.oid) AND (x.grantor = u_grantor.oid) AND
       (x.prtype = ANY (ARRAY ['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'REFERENCES'::text])) AND
       (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
        (grantee.rolname = 'PUBLIC'::name)));

alter table information_schema.column_privileges
    owner to postgres;

create view information_schema.column_udt_usage(udt_catalog, udt_schema, udt_name, table_catalog, table_schema,
                                                table_name, column_name) as
SELECT (current_database())::information_schema.sql_identifier                AS udt_catalog,
       (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier AS udt_schema,
       (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier   AS udt_name,
       (current_database())::information_schema.sql_identifier                AS table_catalog,
       (nc.nspname)::information_schema.sql_identifier                        AS table_schema,
       (c.relname)::information_schema.sql_identifier                         AS table_name,
       (a.attname)::information_schema.sql_identifier                         AS column_name
FROM pg_attribute a,
     pg_class c,
     pg_namespace nc,
     ((pg_type t
         JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
         LEFT JOIN (pg_type bt
         JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid)))
                   ON (((t.typtype = 'd'::"char") AND (t.typbasetype = bt.oid))))
WHERE ((a.attrelid = c.oid) AND (a.atttypid = t.oid) AND (nc.oid = c.relnamespace) AND (a.attnum > 0) AND
       (NOT a.attisdropped) AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"])) AND
       pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE'::text));

alter table information_schema.column_udt_usage
    owner to postgres;

create view information_schema.columns(table_catalog, table_schema, table_name, column_name, ordinal_position,
                                       column_default, is_nullable, data_type, character_maximum_length,
                                       character_octet_length, numeric_precision, numeric_precision_radix,
                                       numeric_scale, datetime_precision, interval_type, interval_precision,
                                       character_set_catalog, character_set_schema, character_set_name,
                                       collation_catalog, collation_schema, collation_name, domain_catalog,
                                       domain_schema, domain_name, udt_catalog, udt_schema, udt_name, scope_catalog,
                                       scope_schema, scope_name, maximum_cardinality, dtd_identifier,
                                       is_self_referencing, is_identity, identity_generation, identity_start,
                                       identity_increment, identity_maximum, identity_minimum, identity_cycle,
                                       is_generated, generation_expression, is_updatable) as
SELECT (current_database())::information_schema.sql_identifier                                                                           AS table_catalog,
       (nc.nspname)::information_schema.sql_identifier                                                                                   AS table_schema,
       (c.relname)::information_schema.sql_identifier                                                                                    AS table_name,
       (a.attname)::information_schema.sql_identifier                                                                                    AS column_name,
       (a.attnum)::information_schema.cardinal_number                                                                                    AS ordinal_position,
       (pg_get_expr(ad.adbin, ad.adrelid))::information_schema.character_data                                                            AS column_default,
       (
           CASE
               WHEN (a.attnotnull OR ((t.typtype = 'd'::"char") AND t.typnotnull)) THEN 'NO'::text
               ELSE 'YES'::text
               END)::information_schema.yes_or_no                                                                                        AS is_nullable,
       (
           CASE
               WHEN (t.typtype = 'd'::"char") THEN
                   CASE
                       WHEN ((bt.typelem <> (0)::oid) AND (bt.typlen = '-1'::integer)) THEN 'ARRAY'::text
                       WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer)
                       ELSE 'USER-DEFINED'::text
                       END
               ELSE
                   CASE
                       WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
                       WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(a.atttypid, NULL::integer)
                       ELSE 'USER-DEFINED'::text
                       END
               END)::information_schema.character_data                                                                                   AS data_type,
       (information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                               information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number         AS character_maximum_length,
       (information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number       AS character_octet_length,
       (information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number       AS numeric_precision,
       (information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                       information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number AS numeric_precision_radix,
       (information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                             information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number           AS numeric_scale,
       (information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                  information_schema._pg_truetypmod(a.*, t.*)))::information_schema.cardinal_number      AS datetime_precision,
       (information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                             information_schema._pg_truetypmod(a.*, t.*)))::information_schema.character_data            AS interval_type,
       (NULL::integer)::information_schema.cardinal_number                                                                               AS interval_precision,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS character_set_schema,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS character_set_name,
       (
           CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL::name
               END)::information_schema.sql_identifier                                                                                   AS collation_catalog,
       (nco.nspname)::information_schema.sql_identifier                                                                                  AS collation_schema,
       (co.collname)::information_schema.sql_identifier                                                                                  AS collation_name,
       (
           CASE
               WHEN (t.typtype = 'd'::"char") THEN current_database()
               ELSE NULL::name
               END)::information_schema.sql_identifier                                                                                   AS domain_catalog,
       (
           CASE
               WHEN (t.typtype = 'd'::"char") THEN nt.nspname
               ELSE NULL::name
               END)::information_schema.sql_identifier                                                                                   AS domain_schema,
       (
           CASE
               WHEN (t.typtype = 'd'::"char") THEN t.typname
               ELSE NULL::name
               END)::information_schema.sql_identifier                                                                                   AS domain_name,
       (current_database())::information_schema.sql_identifier                                                                           AS udt_catalog,
       (COALESCE(nbt.nspname, nt.nspname))::information_schema.sql_identifier                                                            AS udt_schema,
       (COALESCE(bt.typname, t.typname))::information_schema.sql_identifier                                                              AS udt_name,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS scope_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS scope_schema,
       (NULL::character varying)::information_schema.sql_identifier                                                                      AS scope_name,
       (NULL::integer)::information_schema.cardinal_number                                                                               AS maximum_cardinality,
       (a.attnum)::information_schema.sql_identifier                                                                                     AS dtd_identifier,
       ('NO'::character varying)::information_schema.yes_or_no                                                                           AS is_self_referencing,
       ('NO'::character varying)::information_schema.yes_or_no                                                                           AS is_identity,
       (NULL::character varying)::information_schema.character_data                                                                      AS identity_generation,
       (NULL::character varying)::information_schema.character_data                                                                      AS identity_start,
       (NULL::character varying)::information_schema.character_data                                                                      AS identity_increment,
       (NULL::character varying)::information_schema.character_data                                                                      AS identity_maximum,
       (NULL::character varying)::information_schema.character_data                                                                      AS identity_minimum,
       (NULL::character varying)::information_schema.yes_or_no                                                                           AS identity_cycle,
       ('NEVER'::character varying)::information_schema.character_data                                                                   AS is_generated,
       (NULL::character varying)::information_schema.character_data                                                                      AS generation_expression,
       (
           CASE
               WHEN ((c.relkind = 'r'::"char") OR ((c.relkind = ANY (ARRAY ['v'::"char", 'f'::"char"])) AND
                                                   pg_column_is_updatable((c.oid)::regclass, a.attnum, false)))
                   THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no                                                                                        AS is_updatable
FROM (((((pg_attribute a
    LEFT JOIN pg_attrdef ad ON (((a.attrelid = ad.adrelid) AND (a.attnum = ad.adnum))))
    JOIN (pg_class c
        JOIN pg_namespace nc ON ((c.relnamespace = nc.oid))) ON ((a.attrelid = c.oid)))
    JOIN (pg_type t
        JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((a.atttypid = t.oid)))
    LEFT JOIN (pg_type bt
        JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typtype = 'd'::"char") AND (t.typbasetype = bt.oid))))
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((a.attcollation = co.oid) AND
                                                                  ((nco.nspname <> 'pg_catalog'::name) OR
                                                                   (co.collname <> 'default'::name)))))
WHERE ((NOT pg_is_other_temp_schema(nc.oid)) AND (a.attnum > 0) AND (NOT a.attisdropped) AND
       (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"])) AND (pg_has_role(c.relowner, 'USAGE'::text) OR
                                                                              has_column_privilege(c.oid, a.attnum,
                                                                                                   'SELECT, INSERT, UPDATE, REFERENCES'::text)));

alter table information_schema.columns
    owner to postgres;

create view information_schema.constraint_column_usage(table_catalog, table_schema, table_name, column_name,
                                                       constraint_catalog, constraint_schema, constraint_name) as
SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
       (x.tblschema)::information_schema.sql_identifier        AS table_schema,
       (x.tblname)::information_schema.sql_identifier          AS table_name,
       (x.colname)::information_schema.sql_identifier          AS column_name,
       (current_database())::information_schema.sql_identifier AS constraint_catalog,
       (x.cstrschema)::information_schema.sql_identifier       AS constraint_schema,
       (x.cstrname)::information_schema.sql_identifier         AS constraint_name
FROM (SELECT DISTINCT nr.nspname,
                      r.relname,
                      r.relowner,
                      a.attname,
                      nc.nspname,
                      c.conname
      FROM pg_namespace nr,
           pg_class r,
           pg_attribute a,
           pg_depend d,
           pg_namespace nc,
           pg_constraint c
      WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (d.refclassid = ('pg_class'::regclass)::oid) AND
             (d.refobjid = r.oid) AND (d.refobjsubid = a.attnum) AND (d.classid = ('pg_constraint'::regclass)::oid) AND
             (d.objid = c.oid) AND (c.connamespace = nc.oid) AND (c.contype = 'c'::"char") AND
             (r.relkind = 'r'::"char") AND (NOT a.attisdropped))
      UNION ALL
      SELECT nr.nspname,
             r.relname,
             r.relowner,
             a.attname,
             nc.nspname,
             c.conname
      FROM pg_namespace nr,
           pg_class r,
           pg_attribute a,
           pg_namespace nc,
           pg_constraint c
      WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND (nc.oid = c.connamespace) AND
             CASE
                 WHEN (c.contype = 'f'::"char") THEN ((r.oid = c.confrelid) AND (a.attnum = ANY (c.confkey)))
                 ELSE ((r.oid = c.conrelid) AND (a.attnum = ANY (c.conkey)))
                 END AND (NOT a.attisdropped) AND (c.contype = ANY (ARRAY ['p'::"char", 'u'::"char", 'f'::"char"])) AND
             (r.relkind = 'r'::"char"))) x(tblschema, tblname, tblowner, colname, cstrschema, cstrname)
WHERE pg_has_role(x.tblowner, 'USAGE'::text);

alter table information_schema.constraint_column_usage
    owner to postgres;

create view information_schema.constraint_table_usage(table_catalog, table_schema, table_name, constraint_catalog,
                                                      constraint_schema, constraint_name) as
SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
       (nr.nspname)::information_schema.sql_identifier         AS table_schema,
       (r.relname)::information_schema.sql_identifier          AS table_name,
       (current_database())::information_schema.sql_identifier AS constraint_catalog,
       (nc.nspname)::information_schema.sql_identifier         AS constraint_schema,
       (c.conname)::information_schema.sql_identifier          AS constraint_name
FROM pg_constraint c,
     pg_namespace nc,
     pg_class r,
     pg_namespace nr
WHERE ((c.connamespace = nc.oid) AND (r.relnamespace = nr.oid) AND
       (((c.contype = 'f'::"char") AND (c.confrelid = r.oid)) OR
        ((c.contype = ANY (ARRAY ['p'::"char", 'u'::"char"])) AND (c.conrelid = r.oid))) AND
       (r.relkind = 'r'::"char") AND pg_has_role(r.relowner, 'USAGE'::text));

alter table information_schema.constraint_table_usage
    owner to postgres;

create view information_schema.domain_constraints(constraint_catalog, constraint_schema, constraint_name,
                                                  domain_catalog, domain_schema, domain_name, is_deferrable,
                                                  initially_deferred) as
SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
       (rs.nspname)::information_schema.sql_identifier         AS constraint_schema,
       (con.conname)::information_schema.sql_identifier        AS constraint_name,
       (current_database())::information_schema.sql_identifier AS domain_catalog,
       (n.nspname)::information_schema.sql_identifier          AS domain_schema,
       (t.typname)::information_schema.sql_identifier          AS domain_name,
       (
           CASE
               WHEN con.condeferrable THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS is_deferrable,
       (
           CASE
               WHEN con.condeferred THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS initially_deferred
FROM pg_namespace rs,
     pg_namespace n,
     pg_constraint con,
     pg_type t
WHERE ((rs.oid = con.connamespace) AND (n.oid = t.typnamespace) AND (t.oid = con.contypid) AND
       (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text)));

alter table information_schema.domain_constraints
    owner to postgres;

create view information_schema.domain_udt_usage(udt_catalog, udt_schema, udt_name, domain_catalog, domain_schema,
                                                domain_name) as
SELECT (current_database())::information_schema.sql_identifier AS udt_catalog,
       (nbt.nspname)::information_schema.sql_identifier        AS udt_schema,
       (bt.typname)::information_schema.sql_identifier         AS udt_name,
       (current_database())::information_schema.sql_identifier AS domain_catalog,
       (nt.nspname)::information_schema.sql_identifier         AS domain_schema,
       (t.typname)::information_schema.sql_identifier          AS domain_name
FROM pg_type t,
     pg_namespace nt,
     pg_type bt,
     pg_namespace nbt
WHERE ((t.typnamespace = nt.oid) AND (t.typbasetype = bt.oid) AND (bt.typnamespace = nbt.oid) AND
       (t.typtype = 'd'::"char") AND pg_has_role(bt.typowner, 'USAGE'::text));

alter table information_schema.domain_udt_usage
    owner to postgres;

create view information_schema.domains(domain_catalog, domain_schema, domain_name, data_type, character_maximum_length,
                                       character_octet_length, character_set_catalog, character_set_schema,
                                       character_set_name, collation_catalog, collation_schema, collation_name,
                                       numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision,
                                       interval_type, interval_precision, domain_default, udt_catalog, udt_schema,
                                       udt_name, scope_catalog, scope_schema, scope_name, maximum_cardinality,
                                       dtd_identifier) as
SELECT (current_database())::information_schema.sql_identifier                                                  AS domain_catalog,
       (nt.nspname)::information_schema.sql_identifier                                                          AS domain_schema,
       (t.typname)::information_schema.sql_identifier                                                           AS domain_name,
       (
           CASE
               WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
               WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(t.typbasetype, NULL::integer)
               ELSE 'USER-DEFINED'::text
               END)::information_schema.character_data                                                          AS data_type,
       (information_schema._pg_char_max_length(t.typbasetype, t.typtypmod))::information_schema.cardinal_number AS character_maximum_length,
       (information_schema._pg_char_octet_length(t.typbasetype,
                                                 t.typtypmod))::information_schema.cardinal_number              AS character_octet_length,
       (NULL::character varying)::information_schema.sql_identifier                                             AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                             AS character_set_schema,
       (NULL::character varying)::information_schema.sql_identifier                                             AS character_set_name,
       (
           CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL::name
               END)::information_schema.sql_identifier                                                          AS collation_catalog,
       (nco.nspname)::information_schema.sql_identifier                                                         AS collation_schema,
       (co.collname)::information_schema.sql_identifier                                                         AS collation_name,
       (information_schema._pg_numeric_precision(t.typbasetype,
                                                 t.typtypmod))::information_schema.cardinal_number              AS numeric_precision,
       (information_schema._pg_numeric_precision_radix(t.typbasetype,
                                                       t.typtypmod))::information_schema.cardinal_number        AS numeric_precision_radix,
       (information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod))::information_schema.cardinal_number   AS numeric_scale,
       (information_schema._pg_datetime_precision(t.typbasetype,
                                                  t.typtypmod))::information_schema.cardinal_number             AS datetime_precision,
       (information_schema._pg_interval_type(t.typbasetype, t.typtypmod))::information_schema.character_data    AS interval_type,
       (NULL::integer)::information_schema.cardinal_number                                                      AS interval_precision,
       (t.typdefault)::information_schema.character_data                                                        AS domain_default,
       (current_database())::information_schema.sql_identifier                                                  AS udt_catalog,
       (nbt.nspname)::information_schema.sql_identifier                                                         AS udt_schema,
       (bt.typname)::information_schema.sql_identifier                                                          AS udt_name,
       (NULL::character varying)::information_schema.sql_identifier                                             AS scope_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                             AS scope_schema,
       (NULL::character varying)::information_schema.sql_identifier                                             AS scope_name,
       (NULL::integer)::information_schema.cardinal_number                                                      AS maximum_cardinality,
       (1)::information_schema.sql_identifier                                                                   AS dtd_identifier
FROM (((pg_type t
    JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
    JOIN (pg_type bt
        JOIN pg_namespace nbt ON ((bt.typnamespace = nbt.oid))) ON (((t.typbasetype = bt.oid) AND (t.typtype = 'd'::"char"))))
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((t.typcollation = co.oid) AND
                                                                  ((nco.nspname <> 'pg_catalog'::name) OR
                                                                   (co.collname <> 'default'::name)))))
WHERE (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text));

alter table information_schema.domains
    owner to postgres;

create view information_schema.enabled_roles(role_name) as
SELECT (a.rolname)::information_schema.sql_identifier AS role_name
FROM pg_authid a
WHERE pg_has_role(a.oid, 'USAGE'::text);

alter table information_schema.enabled_roles
    owner to postgres;

create view information_schema.key_column_usage(constraint_catalog, constraint_schema, constraint_name, table_catalog,
                                                table_schema, table_name, column_name, ordinal_position,
                                                position_in_unique_constraint) as
SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
       (ss.nc_nspname)::information_schema.sql_identifier      AS constraint_schema,
       (ss.conname)::information_schema.sql_identifier         AS constraint_name,
       (current_database())::information_schema.sql_identifier AS table_catalog,
       (ss.nr_nspname)::information_schema.sql_identifier      AS table_schema,
       (ss.relname)::information_schema.sql_identifier         AS table_name,
       (a.attname)::information_schema.sql_identifier          AS column_name,
       ((ss.x).n)::information_schema.cardinal_number          AS ordinal_position,
       (
           CASE
               WHEN (ss.contype = 'f'::"char") THEN information_schema._pg_index_position(ss.conindid,
                                                                                          ss.confkey[(ss.x).n])
               ELSE NULL::integer
               END)::information_schema.cardinal_number        AS position_in_unique_constraint
FROM pg_attribute a,
     (SELECT r.oid                                        AS roid,
             r.relname,
             r.relowner,
             nc.nspname                                   AS nc_nspname,
             nr.nspname                                   AS nr_nspname,
             c.oid                                        AS coid,
             c.conname,
             c.contype,
             c.conindid,
             c.confkey,
             c.confrelid,
             information_schema._pg_expandarray(c.conkey) AS x
      FROM pg_namespace nr,
           pg_class r,
           pg_namespace nc,
           pg_constraint c
      WHERE ((nr.oid = r.relnamespace) AND (r.oid = c.conrelid) AND (nc.oid = c.connamespace) AND
             (c.contype = ANY (ARRAY ['p'::"char", 'u'::"char", 'f'::"char"])) AND (r.relkind = 'r'::"char") AND
             (NOT pg_is_other_temp_schema(nr.oid)))) ss
WHERE ((ss.roid = a.attrelid) AND (a.attnum = (ss.x).x) AND (NOT a.attisdropped) AND
       (pg_has_role(ss.relowner, 'USAGE'::text) OR
        has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));

alter table information_schema.key_column_usage
    owner to postgres;

create view information_schema.parameters(specific_catalog, specific_schema, specific_name, ordinal_position,
                                          parameter_mode, is_result, as_locator, parameter_name, data_type,
                                          character_maximum_length, character_octet_length, character_set_catalog,
                                          character_set_schema, character_set_name, collation_catalog, collation_schema,
                                          collation_name, numeric_precision, numeric_precision_radix, numeric_scale,
                                          datetime_precision, interval_type, interval_precision, udt_catalog,
                                          udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
                                          maximum_cardinality, dtd_identifier, parameter_default) as
SELECT (current_database())::information_schema.sql_identifier                                      AS specific_catalog,
       (ss.n_nspname)::information_schema.sql_identifier                                            AS specific_schema,
       ((((ss.proname)::text || '_'::text) || (ss.p_oid)::text))::information_schema.sql_identifier AS specific_name,
       ((ss.x).n)::information_schema.cardinal_number                                               AS ordinal_position,
       (
           CASE
               WHEN (ss.proargmodes IS NULL) THEN 'IN'::text
               WHEN (ss.proargmodes[(ss.x).n] = 'i'::"char") THEN 'IN'::text
               WHEN (ss.proargmodes[(ss.x).n] = 'o'::"char") THEN 'OUT'::text
               WHEN (ss.proargmodes[(ss.x).n] = 'b'::"char") THEN 'INOUT'::text
               WHEN (ss.proargmodes[(ss.x).n] = 'v'::"char") THEN 'IN'::text
               WHEN (ss.proargmodes[(ss.x).n] = 't'::"char") THEN 'OUT'::text
               ELSE NULL::text
               END)::information_schema.character_data                                              AS parameter_mode,
       ('NO'::character varying)::information_schema.yes_or_no                                      AS is_result,
       ('NO'::character varying)::information_schema.yes_or_no                                      AS as_locator,
       (NULLIF(ss.proargnames[(ss.x).n], ''::text))::information_schema.sql_identifier              AS parameter_name,
       (
           CASE
               WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
               WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer)
               ELSE 'USER-DEFINED'::text
               END)::information_schema.character_data                                              AS data_type,
       (NULL::integer)::information_schema.cardinal_number                                          AS character_maximum_length,
       (NULL::integer)::information_schema.cardinal_number                                          AS character_octet_length,
       (NULL::character varying)::information_schema.sql_identifier                                 AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                 AS character_set_schema,
       (NULL::character varying)::information_schema.sql_identifier                                 AS character_set_name,
       (NULL::character varying)::information_schema.sql_identifier                                 AS collation_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                 AS collation_schema,
       (NULL::character varying)::information_schema.sql_identifier                                 AS collation_name,
       (NULL::integer)::information_schema.cardinal_number                                          AS numeric_precision,
       (NULL::integer)::information_schema.cardinal_number                                          AS numeric_precision_radix,
       (NULL::integer)::information_schema.cardinal_number                                          AS numeric_scale,
       (NULL::integer)::information_schema.cardinal_number                                          AS datetime_precision,
       (NULL::character varying)::information_schema.character_data                                 AS interval_type,
       (NULL::integer)::information_schema.cardinal_number                                          AS interval_precision,
       (current_database())::information_schema.sql_identifier                                      AS udt_catalog,
       (nt.nspname)::information_schema.sql_identifier                                              AS udt_schema,
       (t.typname)::information_schema.sql_identifier                                               AS udt_name,
       (NULL::character varying)::information_schema.sql_identifier                                 AS scope_catalog,
       (NULL::character varying)::information_schema.sql_identifier                                 AS scope_schema,
       (NULL::character varying)::information_schema.sql_identifier                                 AS scope_name,
       (NULL::integer)::information_schema.cardinal_number                                          AS maximum_cardinality,
       ((ss.x).n)::information_schema.sql_identifier                                                AS dtd_identifier,
       (
           CASE
               WHEN pg_has_role(ss.proowner, 'USAGE'::text) THEN pg_get_function_arg_default(ss.p_oid, (ss.x).n)
               ELSE NULL::text
               END)::information_schema.character_data                                              AS parameter_default
FROM pg_type t,
     pg_namespace nt,
     (SELECT n.nspname                                                                              AS n_nspname,
             p.proname,
             p.oid                                                                                  AS p_oid,
             p.proowner,
             p.proargnames,
             p.proargmodes,
             information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x
      FROM pg_namespace n,
           pg_proc p
      WHERE ((n.oid = p.pronamespace) AND
             (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text)))) ss
WHERE ((t.oid = (ss.x).x) AND (t.typnamespace = nt.oid));

alter table information_schema.parameters
    owner to postgres;

create view information_schema.referential_constraints(constraint_catalog, constraint_schema, constraint_name,
                                                       unique_constraint_catalog, unique_constraint_schema,
                                                       unique_constraint_name, match_option, update_rule,
                                                       delete_rule) as
SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
       (ncon.nspname)::information_schema.sql_identifier       AS constraint_schema,
       (con.conname)::information_schema.sql_identifier        AS constraint_name,
       (
           CASE
               WHEN (npkc.nspname IS NULL) THEN NULL::name
               ELSE current_database()
               END)::information_schema.sql_identifier         AS unique_constraint_catalog,
       (npkc.nspname)::information_schema.sql_identifier       AS unique_constraint_schema,
       (pkc.conname)::information_schema.sql_identifier        AS unique_constraint_name,
       (
           CASE con.confmatchtype
               WHEN 'f'::"char" THEN 'FULL'::text
               WHEN 'p'::"char" THEN 'PARTIAL'::text
               WHEN 's'::"char" THEN 'NONE'::text
               ELSE NULL::text
               END)::information_schema.character_data         AS match_option,
       (
           CASE con.confupdtype
               WHEN 'c'::"char" THEN 'CASCADE'::text
               WHEN 'n'::"char" THEN 'SET NULL'::text
               WHEN 'd'::"char" THEN 'SET DEFAULT'::text
               WHEN 'r'::"char" THEN 'RESTRICT'::text
               WHEN 'a'::"char" THEN 'NO ACTION'::text
               ELSE NULL::text
               END)::information_schema.character_data         AS update_rule,
       (
           CASE con.confdeltype
               WHEN 'c'::"char" THEN 'CASCADE'::text
               WHEN 'n'::"char" THEN 'SET NULL'::text
               WHEN 'd'::"char" THEN 'SET DEFAULT'::text
               WHEN 'r'::"char" THEN 'RESTRICT'::text
               WHEN 'a'::"char" THEN 'NO ACTION'::text
               ELSE NULL::text
               END)::information_schema.character_data         AS delete_rule
FROM ((((((pg_namespace ncon
    JOIN pg_constraint con ON ((ncon.oid = con.connamespace)))
    JOIN pg_class c ON (((con.conrelid = c.oid) AND (con.contype = 'f'::"char"))))
    LEFT JOIN pg_depend d1 ON (((d1.objid = con.oid) AND (d1.classid = ('pg_constraint'::regclass)::oid) AND
                                (d1.refclassid = ('pg_class'::regclass)::oid) AND (d1.refobjsubid = 0))))
    LEFT JOIN pg_depend d2 ON (((d2.refclassid = ('pg_constraint'::regclass)::oid) AND
                                (d2.classid = ('pg_class'::regclass)::oid) AND (d2.objid = d1.refobjid) AND
                                (d2.objsubid = 0) AND (d2.deptype = 'i'::"char"))))
    LEFT JOIN pg_constraint pkc ON (((pkc.oid = d2.refobjid) AND
                                     (pkc.contype = ANY (ARRAY ['p'::"char", 'u'::"char"])) AND
                                     (pkc.conrelid = con.confrelid))))
         LEFT JOIN pg_namespace npkc ON ((pkc.connamespace = npkc.oid)))
WHERE (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.referential_constraints
    owner to postgres;

create view information_schema.role_column_grants(grantor, grantee, table_catalog, table_schema, table_name,
                                                  column_name, privilege_type, is_grantable) as
SELECT column_privileges.grantor,
       column_privileges.grantee,
       column_privileges.table_catalog,
       column_privileges.table_schema,
       column_privileges.table_name,
       column_privileges.column_name,
       column_privileges.privilege_type,
       column_privileges.is_grantable
FROM information_schema.column_privileges
WHERE (((column_privileges.grantor)::text IN (SELECT enabled_roles.role_name
                                              FROM information_schema.enabled_roles)) OR
       ((column_privileges.grantee)::text IN (SELECT enabled_roles.role_name
                                              FROM information_schema.enabled_roles)));

alter table information_schema.role_column_grants
    owner to postgres;

create view information_schema.routine_privileges(grantor, grantee, specific_catalog, specific_schema, specific_name,
                                                  routine_catalog, routine_schema, routine_name, privilege_type,
                                                  is_grantable) as
SELECT (u_grantor.rolname)::information_schema.sql_identifier                                   AS grantor,
       (grantee.rolname)::information_schema.sql_identifier                                     AS grantee,
       (current_database())::information_schema.sql_identifier                                  AS specific_catalog,
       (n.nspname)::information_schema.sql_identifier                                           AS specific_schema,
       ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name,
       (current_database())::information_schema.sql_identifier                                  AS routine_catalog,
       (n.nspname)::information_schema.sql_identifier                                           AS routine_schema,
       (p.proname)::information_schema.sql_identifier                                           AS routine_name,
       ('EXECUTE'::character varying)::information_schema.character_data                        AS privilege_type,
       (
           CASE
               WHEN (pg_has_role(grantee.oid, p.proowner, 'USAGE'::text) OR p.grantable) THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no                                               AS is_grantable
FROM (SELECT pg_proc.oid,
             pg_proc.proname,
             pg_proc.proowner,
             pg_proc.pronamespace,
             (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).grantor AS grantor,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).grantee                 AS grantee,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).privilege_type          AS privilege_type,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).is_grantable            AS is_grantable
      FROM pg_proc) p(oid, proname, proowner, pronamespace, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT (0)::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE ((p.pronamespace = n.oid) AND (grantee.oid = p.grantee) AND (u_grantor.oid = p.grantor) AND
       (p.prtype = 'EXECUTE'::text) AND
       (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
        (grantee.rolname = 'PUBLIC'::name)));

alter table information_schema.routine_privileges
    owner to postgres;

create view information_schema.role_routine_grants(grantor, grantee, specific_catalog, specific_schema, specific_name,
                                                   routine_catalog, routine_schema, routine_name, privilege_type,
                                                   is_grantable) as
SELECT routine_privileges.grantor,
       routine_privileges.grantee,
       routine_privileges.specific_catalog,
       routine_privileges.specific_schema,
       routine_privileges.specific_name,
       routine_privileges.routine_catalog,
       routine_privileges.routine_schema,
       routine_privileges.routine_name,
       routine_privileges.privilege_type,
       routine_privileges.is_grantable
FROM information_schema.routine_privileges
WHERE (((routine_privileges.grantor)::text IN (SELECT enabled_roles.role_name
                                               FROM information_schema.enabled_roles)) OR
       ((routine_privileges.grantee)::text IN (SELECT enabled_roles.role_name
                                               FROM information_schema.enabled_roles)));

alter table information_schema.role_routine_grants
    owner to postgres;

create view information_schema.routines(specific_catalog, specific_schema, specific_name, routine_catalog,
                                        routine_schema, routine_name, routine_type, module_catalog, module_schema,
                                        module_name, udt_catalog, udt_schema, udt_name, data_type,
                                        character_maximum_length, character_octet_length, character_set_catalog,
                                        character_set_schema, character_set_name, collation_catalog, collation_schema,
                                        collation_name, numeric_precision, numeric_precision_radix, numeric_scale,
                                        datetime_precision, interval_type, interval_precision, type_udt_catalog,
                                        type_udt_schema, type_udt_name, scope_catalog, scope_schema, scope_name,
                                        maximum_cardinality, dtd_identifier, routine_body, routine_definition,
                                        external_name, external_language, parameter_style, is_deterministic,
                                        sql_data_access, is_null_call, sql_path, schema_level_routine,
                                        max_dynamic_result_sets, is_user_defined_cast, is_implicitly_invocable,
                                        security_type, to_sql_specific_catalog, to_sql_specific_schema,
                                        to_sql_specific_name, as_locator, created, last_altered, new_savepoint_level,
                                        is_udt_dependent, result_cast_from_data_type, result_cast_as_locator,
                                        result_cast_char_max_length, result_cast_char_octet_length,
                                        result_cast_char_set_catalog, result_cast_char_set_schema,
                                        result_cast_char_set_name, result_cast_collation_catalog,
                                        result_cast_collation_schema, result_cast_collation_name,
                                        result_cast_numeric_precision, result_cast_numeric_precision_radix,
                                        result_cast_numeric_scale, result_cast_datetime_precision,
                                        result_cast_interval_type, result_cast_interval_precision,
                                        result_cast_type_udt_catalog, result_cast_type_udt_schema,
                                        result_cast_type_udt_name, result_cast_scope_catalog, result_cast_scope_schema,
                                        result_cast_scope_name, result_cast_maximum_cardinality,
                                        result_cast_dtd_identifier) as
SELECT (current_database())::information_schema.sql_identifier                                  AS specific_catalog,
       (n.nspname)::information_schema.sql_identifier                                           AS specific_schema,
       ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name,
       (current_database())::information_schema.sql_identifier                                  AS routine_catalog,
       (n.nspname)::information_schema.sql_identifier                                           AS routine_schema,
       (p.proname)::information_schema.sql_identifier                                           AS routine_name,
       ('FUNCTION'::character varying)::information_schema.character_data                       AS routine_type,
       (NULL::character varying)::information_schema.sql_identifier                             AS module_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS module_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS module_name,
       (NULL::character varying)::information_schema.sql_identifier                             AS udt_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS udt_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS udt_name,
       (
           CASE
               WHEN ((t.typelem <> (0)::oid) AND (t.typlen = '-1'::integer)) THEN 'ARRAY'::text
               WHEN (nt.nspname = 'pg_catalog'::name) THEN format_type(t.oid, NULL::integer)
               ELSE 'USER-DEFINED'::text
               END)::information_schema.character_data                                          AS data_type,
       (NULL::integer)::information_schema.cardinal_number                                      AS character_maximum_length,
       (NULL::integer)::information_schema.cardinal_number                                      AS character_octet_length,
       (NULL::character varying)::information_schema.sql_identifier                             AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS character_set_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS character_set_name,
       (NULL::character varying)::information_schema.sql_identifier                             AS collation_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS collation_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS collation_name,
       (NULL::integer)::information_schema.cardinal_number                                      AS numeric_precision,
       (NULL::integer)::information_schema.cardinal_number                                      AS numeric_precision_radix,
       (NULL::integer)::information_schema.cardinal_number                                      AS numeric_scale,
       (NULL::integer)::information_schema.cardinal_number                                      AS datetime_precision,
       (NULL::character varying)::information_schema.character_data                             AS interval_type,
       (NULL::integer)::information_schema.cardinal_number                                      AS interval_precision,
       (current_database())::information_schema.sql_identifier                                  AS type_udt_catalog,
       (nt.nspname)::information_schema.sql_identifier                                          AS type_udt_schema,
       (t.typname)::information_schema.sql_identifier                                           AS type_udt_name,
       (NULL::character varying)::information_schema.sql_identifier                             AS scope_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS scope_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS scope_name,
       (NULL::integer)::information_schema.cardinal_number                                      AS maximum_cardinality,
       (0)::information_schema.sql_identifier                                                   AS dtd_identifier,
       (
           CASE
               WHEN (l.lanname = 'sql'::name) THEN 'SQL'::text
               ELSE 'EXTERNAL'::text
               END)::information_schema.character_data                                          AS routine_body,
       (
           CASE
               WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN p.prosrc
               ELSE NULL::text
               END)::information_schema.character_data                                          AS routine_definition,
       (
           CASE
               WHEN (l.lanname = 'c'::name) THEN p.prosrc
               ELSE NULL::text
               END)::information_schema.character_data                                          AS external_name,
       (upper((l.lanname)::text))::information_schema.character_data                            AS external_language,
       ('GENERAL'::character varying)::information_schema.character_data                        AS parameter_style,
       (
           CASE
               WHEN (p.provolatile = 'i'::"char") THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no                                               AS is_deterministic,
       ('MODIFIES'::character varying)::information_schema.character_data                       AS sql_data_access,
       (
           CASE
               WHEN p.proisstrict THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no                                               AS is_null_call,
       (NULL::character varying)::information_schema.character_data                             AS sql_path,
       ('YES'::character varying)::information_schema.yes_or_no                                 AS schema_level_routine,
       (0)::information_schema.cardinal_number                                                  AS max_dynamic_result_sets,
       (NULL::character varying)::information_schema.yes_or_no                                  AS is_user_defined_cast,
       (NULL::character varying)::information_schema.yes_or_no                                  AS is_implicitly_invocable,
       (
           CASE
               WHEN p.prosecdef THEN 'DEFINER'::text
               ELSE 'INVOKER'::text
               END)::information_schema.character_data                                          AS security_type,
       (NULL::character varying)::information_schema.sql_identifier                             AS to_sql_specific_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS to_sql_specific_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS to_sql_specific_name,
       ('NO'::character varying)::information_schema.yes_or_no                                  AS as_locator,
       (NULL::timestamp with time zone)::information_schema.time_stamp                          AS created,
       (NULL::timestamp with time zone)::information_schema.time_stamp                          AS last_altered,
       (NULL::character varying)::information_schema.yes_or_no                                  AS new_savepoint_level,
       ('NO'::character varying)::information_schema.yes_or_no                                  AS is_udt_dependent,
       (NULL::character varying)::information_schema.character_data                             AS result_cast_from_data_type,
       (NULL::character varying)::information_schema.yes_or_no                                  AS result_cast_as_locator,
       (NULL::integer)::information_schema.cardinal_number                                      AS result_cast_char_max_length,
       (NULL::integer)::information_schema.cardinal_number                                      AS result_cast_char_octet_length,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_char_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_char_set_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_char_set_name,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_collation_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_collation_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_collation_name,
       (NULL::integer)::information_schema.cardinal_number                                      AS result_cast_numeric_precision,
       (NULL::integer)::information_schema.cardinal_number                                      AS result_cast_numeric_precision_radix,
       (NULL::integer)::information_schema.cardinal_number                                      AS result_cast_numeric_scale,
       (NULL::integer)::information_schema.cardinal_number                                      AS result_cast_datetime_precision,
       (NULL::character varying)::information_schema.character_data                             AS result_cast_interval_type,
       (NULL::integer)::information_schema.cardinal_number                                      AS result_cast_interval_precision,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_type_udt_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_type_udt_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_type_udt_name,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_scope_catalog,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_scope_schema,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_scope_name,
       (NULL::integer)::information_schema.cardinal_number                                      AS result_cast_maximum_cardinality,
       (NULL::character varying)::information_schema.sql_identifier                             AS result_cast_dtd_identifier
FROM pg_namespace n,
     pg_proc p,
     pg_language l,
     pg_type t,
     pg_namespace nt
WHERE ((n.oid = p.pronamespace) AND (p.prolang = l.oid) AND (p.prorettype = t.oid) AND (t.typnamespace = nt.oid) AND
       (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text)));

alter table information_schema.routines
    owner to postgres;

create view information_schema.schemata(catalog_name, schema_name, schema_owner, default_character_set_catalog,
                                        default_character_set_schema, default_character_set_name, sql_path) as
SELECT (current_database())::information_schema.sql_identifier      AS catalog_name,
       (n.nspname)::information_schema.sql_identifier               AS schema_name,
       (u.rolname)::information_schema.sql_identifier               AS schema_owner,
       (NULL::character varying)::information_schema.sql_identifier AS default_character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier AS default_character_set_schema,
       (NULL::character varying)::information_schema.sql_identifier AS default_character_set_name,
       (NULL::character varying)::information_schema.character_data AS sql_path
FROM pg_namespace n,
     pg_authid u
WHERE ((n.nspowner = u.oid) AND
       (pg_has_role(n.nspowner, 'USAGE'::text) OR has_schema_privilege(n.oid, 'CREATE, USAGE'::text)));

alter table information_schema.schemata
    owner to postgres;

create view information_schema.sequences(sequence_catalog, sequence_schema, sequence_name, data_type, numeric_precision,
                                         numeric_precision_radix, numeric_scale, start_value, minimum_value,
                                         maximum_value, increment, cycle_option) as
SELECT (current_database())::information_schema.sql_identifier          AS sequence_catalog,
       (nc.nspname)::information_schema.sql_identifier                  AS sequence_schema,
       (c.relname)::information_schema.sql_identifier                   AS sequence_name,
       ('bigint'::character varying)::information_schema.character_data AS data_type,
       (64)::information_schema.cardinal_number                         AS numeric_precision,
       (2)::information_schema.cardinal_number                          AS numeric_precision_radix,
       (0)::information_schema.cardinal_number                          AS numeric_scale,
       (p.start_value)::information_schema.character_data               AS start_value,
       (p.minimum_value)::information_schema.character_data             AS minimum_value,
       (p.maximum_value)::information_schema.character_data             AS maximum_value,
       (p.increment)::information_schema.character_data                 AS increment,
       (
           CASE
               WHEN p.cycle_option THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no                       AS cycle_option
FROM pg_namespace nc,
     pg_class c,
     LATERAL pg_sequence_parameters(c.oid) p(start_value, minimum_value, maximum_value, increment, cycle_option)
WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'S'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) AND
       (pg_has_role(c.relowner, 'USAGE'::text) OR has_sequence_privilege(c.oid, 'SELECT, UPDATE, USAGE'::text)));

alter table information_schema.sequences
    owner to postgres;

create view information_schema.table_constraints(constraint_catalog, constraint_schema, constraint_name, table_catalog,
                                                 table_schema, table_name, constraint_type, is_deferrable,
                                                 initially_deferred) as
    SELECT (current_database())::information_schema.sql_identifier AS constraint_catalog,
           (nc.nspname)::information_schema.sql_identifier         AS constraint_schema,
           (c.conname)::information_schema.sql_identifier          AS constraint_name,
           (current_database())::information_schema.sql_identifier AS table_catalog,
           (nr.nspname)::information_schema.sql_identifier         AS table_schema,
           (r.relname)::information_schema.sql_identifier          AS table_name,
           (
               CASE c.contype
                   WHEN 'c'::"char" THEN 'CHECK'::text
                   WHEN 'f'::"char" THEN 'FOREIGN KEY'::text
                   WHEN 'p'::"char" THEN 'PRIMARY KEY'::text
                   WHEN 'u'::"char" THEN 'UNIQUE'::text
                   ELSE NULL::text
                   END)::information_schema.character_data         AS constraint_type,
           (
               CASE
                   WHEN c.condeferrable THEN 'YES'::text
                   ELSE 'NO'::text
                   END)::information_schema.yes_or_no              AS is_deferrable,
           (
               CASE
                   WHEN c.condeferred THEN 'YES'::text
                   ELSE 'NO'::text
                   END)::information_schema.yes_or_no              AS initially_deferred
    FROM pg_namespace nc,
         pg_namespace nr,
         pg_constraint c,
         pg_class r
    WHERE ((nc.oid = c.connamespace) AND (nr.oid = r.relnamespace) AND (c.conrelid = r.oid) AND
           (c.contype <> ALL (ARRAY ['t'::"char", 'x'::"char"])) AND (r.relkind = 'r'::"char") AND
           (NOT pg_is_other_temp_schema(nr.oid)) AND (pg_has_role(r.relowner, 'USAGE'::text) OR
                                                      has_table_privilege(r.oid,
                                                                          'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
                                                      has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text)))
    UNION ALL
    SELECT (current_database())::information_schema.sql_identifier         AS constraint_catalog,
           (nr.nspname)::information_schema.sql_identifier                 AS constraint_schema,
           (((((((nr.oid)::text || '_'::text) || (r.oid)::text) || '_'::text) || (a.attnum)::text) ||
             '_not_null'::text))::information_schema.sql_identifier        AS constraint_name,
           (current_database())::information_schema.sql_identifier         AS table_catalog,
           (nr.nspname)::information_schema.sql_identifier                 AS table_schema,
           (r.relname)::information_schema.sql_identifier                  AS table_name,
           ('CHECK'::character varying)::information_schema.character_data AS constraint_type,
           ('NO'::character varying)::information_schema.yes_or_no         AS is_deferrable,
           ('NO'::character varying)::information_schema.yes_or_no         AS initially_deferred
    FROM pg_namespace nr,
         pg_class r,
         pg_attribute a
    WHERE ((nr.oid = r.relnamespace) AND (r.oid = a.attrelid) AND a.attnotnull AND (a.attnum > 0) AND
           (NOT a.attisdropped) AND (r.relkind = 'r'::"char") AND (NOT pg_is_other_temp_schema(nr.oid)) AND
           (pg_has_role(r.relowner, 'USAGE'::text) OR
            has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
            has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text)));

alter table information_schema.table_constraints
    owner to postgres;

create view information_schema.table_privileges(grantor, grantee, table_catalog, table_schema, table_name,
                                                privilege_type, is_grantable, with_hierarchy) as
SELECT (u_grantor.rolname)::information_schema.sql_identifier  AS grantor,
       (grantee.rolname)::information_schema.sql_identifier    AS grantee,
       (current_database())::information_schema.sql_identifier AS table_catalog,
       (nc.nspname)::information_schema.sql_identifier         AS table_schema,
       (c.relname)::information_schema.sql_identifier          AS table_name,
       (c.prtype)::information_schema.character_data           AS privilege_type,
       (
           CASE
               WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable) THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS is_grantable,
       (
           CASE
               WHEN (c.prtype = 'SELECT'::text) THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS with_hierarchy
FROM (SELECT pg_class.oid,
             pg_class.relname,
             pg_class.relnamespace,
             pg_class.relkind,
             pg_class.relowner,
             (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).grantee                  AS grantee,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).privilege_type           AS privilege_type,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).is_grantable             AS is_grantable
      FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
     pg_namespace nc,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT (0)::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE ((c.relnamespace = nc.oid) AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"])) AND
       (c.grantee = grantee.oid) AND (c.grantor = u_grantor.oid) AND (c.prtype = ANY
                                                                      (ARRAY ['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'DELETE'::text, 'TRUNCATE'::text, 'REFERENCES'::text, 'TRIGGER'::text])) AND
       (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
        (grantee.rolname = 'PUBLIC'::name)));

alter table information_schema.table_privileges
    owner to postgres;

create view information_schema.role_table_grants(grantor, grantee, table_catalog, table_schema, table_name,
                                                 privilege_type, is_grantable, with_hierarchy) as
SELECT table_privileges.grantor,
       table_privileges.grantee,
       table_privileges.table_catalog,
       table_privileges.table_schema,
       table_privileges.table_name,
       table_privileges.privilege_type,
       table_privileges.is_grantable,
       table_privileges.with_hierarchy
FROM information_schema.table_privileges
WHERE (((table_privileges.grantor)::text IN (SELECT enabled_roles.role_name
                                             FROM information_schema.enabled_roles)) OR
       ((table_privileges.grantee)::text IN (SELECT enabled_roles.role_name
                                             FROM information_schema.enabled_roles)));

alter table information_schema.role_table_grants
    owner to postgres;

create view information_schema.tables(table_catalog, table_schema, table_name, table_type, self_referencing_column_name,
                                      reference_generation, user_defined_type_catalog, user_defined_type_schema,
                                      user_defined_type_name, is_insertable_into, is_typed, commit_action) as
SELECT (current_database())::information_schema.sql_identifier      AS table_catalog,
       (nc.nspname)::information_schema.sql_identifier              AS table_schema,
       (c.relname)::information_schema.sql_identifier               AS table_name,
       (
           CASE
               WHEN (nc.oid = pg_my_temp_schema()) THEN 'LOCAL TEMPORARY'::text
               WHEN (c.relkind = 'r'::"char") THEN 'BASE TABLE'::text
               WHEN (c.relkind = 'v'::"char") THEN 'VIEW'::text
               WHEN (c.relkind = 'f'::"char") THEN 'FOREIGN TABLE'::text
               ELSE NULL::text
               END)::information_schema.character_data              AS table_type,
       (NULL::character varying)::information_schema.sql_identifier AS self_referencing_column_name,
       (NULL::character varying)::information_schema.character_data AS reference_generation,
       (
           CASE
               WHEN (t.typname IS NOT NULL) THEN current_database()
               ELSE NULL::name
               END)::information_schema.sql_identifier              AS user_defined_type_catalog,
       (nt.nspname)::information_schema.sql_identifier              AS user_defined_type_schema,
       (t.typname)::information_schema.sql_identifier               AS user_defined_type_name,
       (
           CASE
               WHEN ((c.relkind = 'r'::"char") OR ((c.relkind = ANY (ARRAY ['v'::"char", 'f'::"char"])) AND
                                                   ((pg_relation_is_updatable((c.oid)::regclass, false) & 8) = 8)))
                   THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no                   AS is_insertable_into,
       (
           CASE
               WHEN (t.typname IS NOT NULL) THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no                   AS is_typed,
       (NULL::character varying)::information_schema.character_data AS commit_action
FROM ((pg_namespace nc
    JOIN pg_class c ON ((nc.oid = c.relnamespace)))
         LEFT JOIN (pg_type t
    JOIN pg_namespace nt ON ((t.typnamespace = nt.oid))) ON ((c.reloftype = t.oid)))
WHERE ((c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"])) AND (NOT pg_is_other_temp_schema(nc.oid)) AND
       (pg_has_role(c.relowner, 'USAGE'::text) OR
        has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
        has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));

alter table information_schema.tables
    owner to postgres;

create view information_schema.transforms(udt_catalog, udt_schema, udt_name, specific_catalog, specific_schema,
                                          specific_name, group_name, transform_type) as
    SELECT (current_database())::information_schema.sql_identifier                                  AS udt_catalog,
           (nt.nspname)::information_schema.sql_identifier                                          AS udt_schema,
           (t.typname)::information_schema.sql_identifier                                           AS udt_name,
           (current_database())::information_schema.sql_identifier                                  AS specific_catalog,
           (np.nspname)::information_schema.sql_identifier                                          AS specific_schema,
           ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name,
           (l.lanname)::information_schema.sql_identifier                                           AS group_name,
           ('FROM SQL'::character varying)::information_schema.character_data                       AS transform_type
    FROM (((((pg_type t
        JOIN pg_transform x ON ((t.oid = x.trftype)))
        JOIN pg_language l ON ((x.trflang = l.oid)))
        JOIN pg_proc p ON (((x.trffromsql)::oid = p.oid)))
        JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
             JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
    UNION
    SELECT (current_database())::information_schema.sql_identifier                                  AS udt_catalog,
           (nt.nspname)::information_schema.sql_identifier                                          AS udt_schema,
           (t.typname)::information_schema.sql_identifier                                           AS udt_name,
           (current_database())::information_schema.sql_identifier                                  AS specific_catalog,
           (np.nspname)::information_schema.sql_identifier                                          AS specific_schema,
           ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name,
           (l.lanname)::information_schema.sql_identifier                                           AS group_name,
           ('TO SQL'::character varying)::information_schema.character_data                         AS transform_type
    FROM (((((pg_type t
        JOIN pg_transform x ON ((t.oid = x.trftype)))
        JOIN pg_language l ON ((x.trflang = l.oid)))
        JOIN pg_proc p ON (((x.trftosql)::oid = p.oid)))
        JOIN pg_namespace nt ON ((t.typnamespace = nt.oid)))
             JOIN pg_namespace np ON ((p.pronamespace = np.oid)))
    ORDER BY 1, 2, 3, 7, 8;

alter table information_schema.transforms
    owner to postgres;

create view information_schema.triggered_update_columns(trigger_catalog, trigger_schema, trigger_name,
                                                        event_object_catalog, event_object_schema, event_object_table,
                                                        event_object_column) as
SELECT (current_database())::information_schema.sql_identifier AS trigger_catalog,
       (n.nspname)::information_schema.sql_identifier          AS trigger_schema,
       (t.tgname)::information_schema.sql_identifier           AS trigger_name,
       (current_database())::information_schema.sql_identifier AS event_object_catalog,
       (n.nspname)::information_schema.sql_identifier          AS event_object_schema,
       (c.relname)::information_schema.sql_identifier          AS event_object_table,
       (a.attname)::information_schema.sql_identifier          AS event_object_column
FROM pg_namespace n,
     pg_class c,
     pg_trigger t,
     (SELECT ta0.tgoid,
             (ta0.tgat).x AS tgattnum,
             (ta0.tgat).n AS tgattpos
      FROM (SELECT pg_trigger.oid                                        AS tgoid,
                   information_schema._pg_expandarray(pg_trigger.tgattr) AS tgat
            FROM pg_trigger) ta0) ta,
     pg_attribute a
WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (t.oid = ta.tgoid) AND
       ((a.attrelid = t.tgrelid) AND (a.attnum = ta.tgattnum)) AND (NOT t.tgisinternal) AND
       (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR
                                                 has_column_privilege(c.oid, a.attnum,
                                                                      'INSERT, UPDATE, REFERENCES'::text)));

alter table information_schema.triggered_update_columns
    owner to postgres;

create view information_schema.triggers(trigger_catalog, trigger_schema, trigger_name, event_manipulation,
                                        event_object_catalog, event_object_schema, event_object_table, action_order,
                                        action_condition, action_statement, action_orientation, action_timing,
                                        action_reference_old_table, action_reference_new_table,
                                        action_reference_old_row, action_reference_new_row, created) as
SELECT (current_database())::information_schema.sql_identifier         AS trigger_catalog,
       (n.nspname)::information_schema.sql_identifier                  AS trigger_schema,
       (t.tgname)::information_schema.sql_identifier                   AS trigger_name,
       (em.text)::information_schema.character_data                    AS event_manipulation,
       (current_database())::information_schema.sql_identifier         AS event_object_catalog,
       (n.nspname)::information_schema.sql_identifier                  AS event_object_schema,
       (c.relname)::information_schema.sql_identifier                  AS event_object_table,
       (NULL::integer)::information_schema.cardinal_number             AS action_order,
       (
           CASE
               WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN (SELECT rm.m[1] AS m
                                                                 FROM regexp_matches(pg_get_triggerdef(t.oid),
                                                                                     '.{35,} WHEN \((.+)\) EXECUTE PROCEDURE'::text) rm(m)
                                                                 LIMIT 1)
               ELSE NULL::text
               END)::information_schema.character_data                 AS action_condition,
       ("substring"(pg_get_triggerdef(t.oid),
                    ("position"("substring"(pg_get_triggerdef(t.oid), 48), 'EXECUTE PROCEDURE'::text) +
                     47)))::information_schema.character_data          AS action_statement,
       (
           CASE ((t.tgtype)::integer & 1)
               WHEN 1 THEN 'ROW'::text
               ELSE 'STATEMENT'::text
               END)::information_schema.character_data                 AS action_orientation,
       (
           CASE ((t.tgtype)::integer & 66)
               WHEN 2 THEN 'BEFORE'::text
               WHEN 64 THEN 'INSTEAD OF'::text
               ELSE 'AFTER'::text
               END)::information_schema.character_data                 AS action_timing,
       (NULL::character varying)::information_schema.sql_identifier    AS action_reference_old_table,
       (NULL::character varying)::information_schema.sql_identifier    AS action_reference_new_table,
       (NULL::character varying)::information_schema.sql_identifier    AS action_reference_old_row,
       (NULL::character varying)::information_schema.sql_identifier    AS action_reference_new_row,
       (NULL::timestamp with time zone)::information_schema.time_stamp AS created
FROM pg_namespace n,
     pg_class c,
     pg_trigger t,
     (VALUES (4, 'INSERT'::text), (8, 'DELETE'::text), (16, 'UPDATE'::text)) em(num, text)
WHERE ((n.oid = c.relnamespace) AND (c.oid = t.tgrelid) AND (((t.tgtype)::integer & em.num) <> 0) AND
       (NOT t.tgisinternal) AND (NOT pg_is_other_temp_schema(n.oid)) AND (pg_has_role(c.relowner, 'USAGE'::text) OR
                                                                          has_table_privilege(c.oid,
                                                                                              'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
                                                                          has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text)));

alter table information_schema.triggers
    owner to postgres;

create view information_schema.udt_privileges(grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type,
                                              is_grantable) as
SELECT (u_grantor.rolname)::information_schema.sql_identifier               AS grantor,
       (grantee.rolname)::information_schema.sql_identifier                 AS grantee,
       (current_database())::information_schema.sql_identifier              AS udt_catalog,
       (n.nspname)::information_schema.sql_identifier                       AS udt_schema,
       (t.typname)::information_schema.sql_identifier                       AS udt_name,
       ('TYPE USAGE'::character varying)::information_schema.character_data AS privilege_type,
       (
           CASE
               WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable) THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no                           AS is_grantable
FROM (SELECT pg_type.oid,
             pg_type.typname,
             pg_type.typnamespace,
             pg_type.typtype,
             pg_type.typowner,
             (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor AS grantor,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).grantee                 AS grantee,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).privilege_type          AS privilege_type,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).is_grantable            AS is_grantable
      FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT (0)::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'c'::"char") AND (t.grantee = grantee.oid) AND
       (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE'::text) AND
       (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
        (grantee.rolname = 'PUBLIC'::name)));

alter table information_schema.udt_privileges
    owner to postgres;

create view information_schema.role_udt_grants(grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type,
                                               is_grantable) as
SELECT udt_privileges.grantor,
       udt_privileges.grantee,
       udt_privileges.udt_catalog,
       udt_privileges.udt_schema,
       udt_privileges.udt_name,
       udt_privileges.privilege_type,
       udt_privileges.is_grantable
FROM information_schema.udt_privileges
WHERE (((udt_privileges.grantor)::text IN (SELECT enabled_roles.role_name
                                           FROM information_schema.enabled_roles)) OR
       ((udt_privileges.grantee)::text IN (SELECT enabled_roles.role_name
                                           FROM information_schema.enabled_roles)));

alter table information_schema.role_udt_grants
    owner to postgres;

create view information_schema.usage_privileges(grantor, grantee, object_catalog, object_schema, object_name,
                                                object_type, privilege_type, is_grantable) as
    SELECT (u.rolname)::information_schema.sql_identifier                      AS grantor,
           ('PUBLIC'::character varying)::information_schema.sql_identifier    AS grantee,
           (current_database())::information_schema.sql_identifier             AS object_catalog,
           (n.nspname)::information_schema.sql_identifier                      AS object_schema,
           (c.collname)::information_schema.sql_identifier                     AS object_name,
           ('COLLATION'::character varying)::information_schema.character_data AS object_type,
           ('USAGE'::character varying)::information_schema.character_data     AS privilege_type,
           ('NO'::character varying)::information_schema.yes_or_no             AS is_grantable
    FROM pg_authid u,
         pg_namespace n,
         pg_collation c
    WHERE ((u.oid = c.collowner) AND (c.collnamespace = n.oid) AND
           (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                         FROM pg_database
                                                         WHERE (pg_database.datname = current_database()))])))
    UNION ALL
    SELECT (u_grantor.rolname)::information_schema.sql_identifier           AS grantor,
           (grantee.rolname)::information_schema.sql_identifier             AS grantee,
           (current_database())::information_schema.sql_identifier          AS object_catalog,
           (n.nspname)::information_schema.sql_identifier                   AS object_schema,
           (t.typname)::information_schema.sql_identifier                   AS object_name,
           ('DOMAIN'::character varying)::information_schema.character_data AS object_type,
           ('USAGE'::character varying)::information_schema.character_data  AS privilege_type,
           (
               CASE
                   WHEN (pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable) THEN 'YES'::text
                   ELSE 'NO'::text
                   END)::information_schema.yes_or_no                       AS is_grantable
    FROM (SELECT pg_type.oid,
                 pg_type.typname,
                 pg_type.typnamespace,
                 pg_type.typtype,
                 pg_type.typowner,
                 (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor AS grantor,
                 (aclexplode(COALESCE(pg_type.typacl,
                                      acldefault('T'::"char", pg_type.typowner)))).grantee                 AS grantee,
                 (aclexplode(COALESCE(pg_type.typacl,
                                      acldefault('T'::"char", pg_type.typowner)))).privilege_type          AS privilege_type,
                 (aclexplode(COALESCE(pg_type.typacl,
                                      acldefault('T'::"char", pg_type.typowner)))).is_grantable            AS is_grantable
          FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
         pg_namespace n,
         pg_authid u_grantor,
         (SELECT pg_authid.oid,
                 pg_authid.rolname
          FROM pg_authid
          UNION ALL
          SELECT (0)::oid AS oid,
                 'PUBLIC'::name) grantee(oid, rolname)
    WHERE ((t.typnamespace = n.oid) AND (t.typtype = 'd'::"char") AND (t.grantee = grantee.oid) AND
           (t.grantor = u_grantor.oid) AND (t.prtype = 'USAGE'::text) AND
           (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
            (grantee.rolname = 'PUBLIC'::name)))
    UNION ALL
    SELECT (u_grantor.rolname)::information_schema.sql_identifier                         AS grantor,
           (grantee.rolname)::information_schema.sql_identifier                           AS grantee,
           (current_database())::information_schema.sql_identifier                        AS object_catalog,
           (''::character varying)::information_schema.sql_identifier                     AS object_schema,
           (fdw.fdwname)::information_schema.sql_identifier                               AS object_name,
           ('FOREIGN DATA WRAPPER'::character varying)::information_schema.character_data AS object_type,
           ('USAGE'::character varying)::information_schema.character_data                AS privilege_type,
           (
               CASE
                   WHEN (pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE'::text) OR fdw.grantable) THEN 'YES'::text
                   ELSE 'NO'::text
                   END)::information_schema.yes_or_no                                     AS is_grantable
    FROM (SELECT pg_foreign_data_wrapper.fdwname,
                 pg_foreign_data_wrapper.fdwowner,
                 (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                      acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantor        AS grantor,
                 (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                      acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantee        AS grantee,
                 (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                      acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).privilege_type AS privilege_type,
                 (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                      acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).is_grantable   AS is_grantable
          FROM pg_foreign_data_wrapper) fdw(fdwname, fdwowner, grantor, grantee, prtype, grantable),
         pg_authid u_grantor,
         (SELECT pg_authid.oid,
                 pg_authid.rolname
          FROM pg_authid
          UNION ALL
          SELECT (0)::oid AS oid,
                 'PUBLIC'::name) grantee(oid, rolname)
    WHERE ((u_grantor.oid = fdw.grantor) AND (grantee.oid = fdw.grantee) AND (fdw.prtype = 'USAGE'::text) AND
           (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
            (grantee.rolname = 'PUBLIC'::name)))
    UNION ALL
    SELECT (u_grantor.rolname)::information_schema.sql_identifier                   AS grantor,
           (grantee.rolname)::information_schema.sql_identifier                     AS grantee,
           (current_database())::information_schema.sql_identifier                  AS object_catalog,
           (''::character varying)::information_schema.sql_identifier               AS object_schema,
           (srv.srvname)::information_schema.sql_identifier                         AS object_name,
           ('FOREIGN SERVER'::character varying)::information_schema.character_data AS object_type,
           ('USAGE'::character varying)::information_schema.character_data          AS privilege_type,
           (
               CASE
                   WHEN (pg_has_role(grantee.oid, srv.srvowner, 'USAGE'::text) OR srv.grantable) THEN 'YES'::text
                   ELSE 'NO'::text
                   END)::information_schema.yes_or_no                               AS is_grantable
    FROM (SELECT pg_foreign_server.srvname,
                 pg_foreign_server.srvowner,
                 (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                      acldefault('S'::"char", pg_foreign_server.srvowner)))).grantor        AS grantor,
                 (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                      acldefault('S'::"char", pg_foreign_server.srvowner)))).grantee        AS grantee,
                 (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                      acldefault('S'::"char", pg_foreign_server.srvowner)))).privilege_type AS privilege_type,
                 (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                      acldefault('S'::"char", pg_foreign_server.srvowner)))).is_grantable   AS is_grantable
          FROM pg_foreign_server) srv(srvname, srvowner, grantor, grantee, prtype, grantable),
         pg_authid u_grantor,
         (SELECT pg_authid.oid,
                 pg_authid.rolname
          FROM pg_authid
          UNION ALL
          SELECT (0)::oid AS oid,
                 'PUBLIC'::name) grantee(oid, rolname)
    WHERE ((u_grantor.oid = srv.grantor) AND (grantee.oid = srv.grantee) AND (srv.prtype = 'USAGE'::text) AND
           (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
            (grantee.rolname = 'PUBLIC'::name)))
    UNION ALL
    SELECT (u_grantor.rolname)::information_schema.sql_identifier             AS grantor,
           (grantee.rolname)::information_schema.sql_identifier               AS grantee,
           (current_database())::information_schema.sql_identifier            AS object_catalog,
           (n.nspname)::information_schema.sql_identifier                     AS object_schema,
           (c.relname)::information_schema.sql_identifier                     AS object_name,
           ('SEQUENCE'::character varying)::information_schema.character_data AS object_type,
           ('USAGE'::character varying)::information_schema.character_data    AS privilege_type,
           (
               CASE
                   WHEN (pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable) THEN 'YES'::text
                   ELSE 'NO'::text
                   END)::information_schema.yes_or_no                         AS is_grantable
    FROM (SELECT pg_class.oid,
                 pg_class.relname,
                 pg_class.relnamespace,
                 pg_class.relkind,
                 pg_class.relowner,
                 (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor AS grantor,
                 (aclexplode(COALESCE(pg_class.relacl,
                                      acldefault('r'::"char", pg_class.relowner)))).grantee                  AS grantee,
                 (aclexplode(COALESCE(pg_class.relacl,
                                      acldefault('r'::"char", pg_class.relowner)))).privilege_type           AS privilege_type,
                 (aclexplode(COALESCE(pg_class.relacl,
                                      acldefault('r'::"char", pg_class.relowner)))).is_grantable             AS is_grantable
          FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
         pg_namespace n,
         pg_authid u_grantor,
         (SELECT pg_authid.oid,
                 pg_authid.rolname
          FROM pg_authid
          UNION ALL
          SELECT (0)::oid AS oid,
                 'PUBLIC'::name) grantee(oid, rolname)
    WHERE ((c.relnamespace = n.oid) AND (c.relkind = 'S'::"char") AND (c.grantee = grantee.oid) AND
           (c.grantor = u_grantor.oid) AND (c.prtype = 'USAGE'::text) AND
           (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
            (grantee.rolname = 'PUBLIC'::name)));

alter table information_schema.usage_privileges
    owner to postgres;

create view information_schema.role_usage_grants(grantor, grantee, object_catalog, object_schema, object_name,
                                                 object_type, privilege_type, is_grantable) as
SELECT usage_privileges.grantor,
       usage_privileges.grantee,
       usage_privileges.object_catalog,
       usage_privileges.object_schema,
       usage_privileges.object_name,
       usage_privileges.object_type,
       usage_privileges.privilege_type,
       usage_privileges.is_grantable
FROM information_schema.usage_privileges
WHERE (((usage_privileges.grantor)::text IN (SELECT enabled_roles.role_name
                                             FROM information_schema.enabled_roles)) OR
       ((usage_privileges.grantee)::text IN (SELECT enabled_roles.role_name
                                             FROM information_schema.enabled_roles)));

alter table information_schema.role_usage_grants
    owner to postgres;

create view information_schema.user_defined_types(user_defined_type_catalog, user_defined_type_schema,
                                                  user_defined_type_name, user_defined_type_category, is_instantiable,
                                                  is_final, ordering_form, ordering_category, ordering_routine_catalog,
                                                  ordering_routine_schema, ordering_routine_name, reference_type,
                                                  data_type, character_maximum_length, character_octet_length,
                                                  character_set_catalog, character_set_schema, character_set_name,
                                                  collation_catalog, collation_schema, collation_name,
                                                  numeric_precision, numeric_precision_radix, numeric_scale,
                                                  datetime_precision, interval_type, interval_precision,
                                                  source_dtd_identifier, ref_dtd_identifier) as
SELECT (current_database())::information_schema.sql_identifier              AS user_defined_type_catalog,
       (n.nspname)::information_schema.sql_identifier                       AS user_defined_type_schema,
       (c.relname)::information_schema.sql_identifier                       AS user_defined_type_name,
       ('STRUCTURED'::character varying)::information_schema.character_data AS user_defined_type_category,
       ('YES'::character varying)::information_schema.yes_or_no             AS is_instantiable,
       (NULL::character varying)::information_schema.yes_or_no              AS is_final,
       (NULL::character varying)::information_schema.character_data         AS ordering_form,
       (NULL::character varying)::information_schema.character_data         AS ordering_category,
       (NULL::character varying)::information_schema.sql_identifier         AS ordering_routine_catalog,
       (NULL::character varying)::information_schema.sql_identifier         AS ordering_routine_schema,
       (NULL::character varying)::information_schema.sql_identifier         AS ordering_routine_name,
       (NULL::character varying)::information_schema.character_data         AS reference_type,
       (NULL::character varying)::information_schema.character_data         AS data_type,
       (NULL::integer)::information_schema.cardinal_number                  AS character_maximum_length,
       (NULL::integer)::information_schema.cardinal_number                  AS character_octet_length,
       (NULL::character varying)::information_schema.sql_identifier         AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier         AS character_set_schema,
       (NULL::character varying)::information_schema.sql_identifier         AS character_set_name,
       (NULL::character varying)::information_schema.sql_identifier         AS collation_catalog,
       (NULL::character varying)::information_schema.sql_identifier         AS collation_schema,
       (NULL::character varying)::information_schema.sql_identifier         AS collation_name,
       (NULL::integer)::information_schema.cardinal_number                  AS numeric_precision,
       (NULL::integer)::information_schema.cardinal_number                  AS numeric_precision_radix,
       (NULL::integer)::information_schema.cardinal_number                  AS numeric_scale,
       (NULL::integer)::information_schema.cardinal_number                  AS datetime_precision,
       (NULL::character varying)::information_schema.character_data         AS interval_type,
       (NULL::integer)::information_schema.cardinal_number                  AS interval_precision,
       (NULL::character varying)::information_schema.sql_identifier         AS source_dtd_identifier,
       (NULL::character varying)::information_schema.sql_identifier         AS ref_dtd_identifier
FROM pg_namespace n,
     pg_class c,
     pg_type t
WHERE ((n.oid = c.relnamespace) AND (t.typrelid = c.oid) AND (c.relkind = 'c'::"char") AND
       (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text)));

alter table information_schema.user_defined_types
    owner to postgres;

create view information_schema.view_column_usage(view_catalog, view_schema, view_name, table_catalog, table_schema,
                                                 table_name, column_name) as
SELECT DISTINCT (current_database())::information_schema.sql_identifier AS view_catalog,
                (nv.nspname)::information_schema.sql_identifier         AS view_schema,
                (v.relname)::information_schema.sql_identifier          AS view_name,
                (current_database())::information_schema.sql_identifier AS table_catalog,
                (nt.nspname)::information_schema.sql_identifier         AS table_schema,
                (t.relname)::information_schema.sql_identifier          AS table_name,
                (a.attname)::information_schema.sql_identifier          AS column_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dt,
     pg_class t,
     pg_namespace nt,
     pg_attribute a
WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND
       (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND
       (dv.deptype = 'i'::"char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND
       (dt.classid = ('pg_rewrite'::regclass)::oid) AND (dt.refclassid = ('pg_class'::regclass)::oid) AND
       (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND
       (t.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"])) AND (t.oid = a.attrelid) AND
       (dt.refobjsubid = a.attnum) AND pg_has_role(t.relowner, 'USAGE'::text));

alter table information_schema.view_column_usage
    owner to postgres;

create view information_schema.view_routine_usage(table_catalog, table_schema, table_name, specific_catalog,
                                                  specific_schema, specific_name) as
SELECT DISTINCT (current_database())::information_schema.sql_identifier                                  AS table_catalog,
                (nv.nspname)::information_schema.sql_identifier                                          AS table_schema,
                (v.relname)::information_schema.sql_identifier                                           AS table_name,
                (current_database())::information_schema.sql_identifier                                  AS specific_catalog,
                (np.nspname)::information_schema.sql_identifier                                          AS specific_schema,
                ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS specific_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dp,
     pg_proc p,
     pg_namespace np
WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND
       (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND
       (dv.deptype = 'i'::"char") AND (dv.objid = dp.objid) AND (dp.classid = ('pg_rewrite'::regclass)::oid) AND
       (dp.refclassid = ('pg_proc'::regclass)::oid) AND (dp.refobjid = p.oid) AND (p.pronamespace = np.oid) AND
       pg_has_role(p.proowner, 'USAGE'::text));

alter table information_schema.view_routine_usage
    owner to postgres;

create view information_schema.view_table_usage(view_catalog, view_schema, view_name, table_catalog, table_schema,
                                                table_name) as
SELECT DISTINCT (current_database())::information_schema.sql_identifier AS view_catalog,
                (nv.nspname)::information_schema.sql_identifier         AS view_schema,
                (v.relname)::information_schema.sql_identifier          AS view_name,
                (current_database())::information_schema.sql_identifier AS table_catalog,
                (nt.nspname)::information_schema.sql_identifier         AS table_schema,
                (t.relname)::information_schema.sql_identifier          AS table_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dt,
     pg_class t,
     pg_namespace nt
WHERE ((nv.oid = v.relnamespace) AND (v.relkind = 'v'::"char") AND (v.oid = dv.refobjid) AND
       (dv.refclassid = ('pg_class'::regclass)::oid) AND (dv.classid = ('pg_rewrite'::regclass)::oid) AND
       (dv.deptype = 'i'::"char") AND (dv.objid = dt.objid) AND (dv.refobjid <> dt.refobjid) AND
       (dt.classid = ('pg_rewrite'::regclass)::oid) AND (dt.refclassid = ('pg_class'::regclass)::oid) AND
       (dt.refobjid = t.oid) AND (t.relnamespace = nt.oid) AND
       (t.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char"])) AND pg_has_role(t.relowner, 'USAGE'::text));

alter table information_schema.view_table_usage
    owner to postgres;

create view information_schema.views(table_catalog, table_schema, table_name, view_definition, check_option,
                                     is_updatable, is_insertable_into, is_trigger_updatable, is_trigger_deletable,
                                     is_trigger_insertable_into) as
SELECT (current_database())::information_schema.sql_identifier AS table_catalog,
       (nc.nspname)::information_schema.sql_identifier         AS table_schema,
       (c.relname)::information_schema.sql_identifier          AS table_name,
       (
           CASE
               WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN pg_get_viewdef(c.oid)
               ELSE NULL::text
               END)::information_schema.character_data         AS view_definition,
       (
           CASE
               WHEN ('check_option=cascaded'::text = ANY (c.reloptions)) THEN 'CASCADED'::text
               WHEN ('check_option=local'::text = ANY (c.reloptions)) THEN 'LOCAL'::text
               ELSE 'NONE'::text
               END)::information_schema.character_data         AS check_option,
       (
           CASE
               WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 20) = 20) THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS is_updatable,
       (
           CASE
               WHEN ((pg_relation_is_updatable((c.oid)::regclass, false) & 8) = 8) THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS is_insertable_into,
       (
           CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 81) = 81))))
                   THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS is_trigger_updatable,
       (
           CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 73) = 73))))
                   THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS is_trigger_deletable,
       (
           CASE
               WHEN (EXISTS(SELECT 1
                            FROM pg_trigger
                            WHERE ((pg_trigger.tgrelid = c.oid) AND (((pg_trigger.tgtype)::integer & 69) = 69))))
                   THEN 'YES'::text
               ELSE 'NO'::text
               END)::information_schema.yes_or_no              AS is_trigger_insertable_into
FROM pg_namespace nc,
     pg_class c
WHERE ((c.relnamespace = nc.oid) AND (c.relkind = 'v'::"char") AND (NOT pg_is_other_temp_schema(nc.oid)) AND
       (pg_has_role(c.relowner, 'USAGE'::text) OR
        has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
        has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text)));

alter table information_schema.views
    owner to postgres;

create view information_schema.data_type_privileges(object_catalog, object_schema, object_name, object_type,
                                                    dtd_identifier) as
SELECT (current_database())::information_schema.sql_identifier AS object_catalog,
       x.objschema                                             AS object_schema,
       x.objname                                               AS object_name,
       (x.objtype)::information_schema.character_data          AS object_type,
       x.objdtdid                                              AS dtd_identifier
FROM (SELECT attributes.udt_schema,
             attributes.udt_name,
             'USER-DEFINED TYPE'::text AS text,
             attributes.dtd_identifier
      FROM information_schema.attributes
      UNION ALL
      SELECT columns.table_schema,
             columns.table_name,
             'TABLE'::text AS text,
             columns.dtd_identifier
      FROM information_schema.columns
      UNION ALL
      SELECT domains.domain_schema,
             domains.domain_name,
             'DOMAIN'::text AS text,
             domains.dtd_identifier
      FROM information_schema.domains
      UNION ALL
      SELECT parameters.specific_schema,
             parameters.specific_name,
             'ROUTINE'::text AS text,
             parameters.dtd_identifier
      FROM information_schema.parameters
      UNION ALL
      SELECT routines.specific_schema,
             routines.specific_name,
             'ROUTINE'::text AS text,
             routines.dtd_identifier
      FROM information_schema.routines) x(objschema, objname, objtype, objdtdid);

alter table information_schema.data_type_privileges
    owner to postgres;

create view information_schema.element_types(object_catalog, object_schema, object_name, object_type,
                                             collection_type_identifier, data_type, character_maximum_length,
                                             character_octet_length, character_set_catalog, character_set_schema,
                                             character_set_name, collation_catalog, collation_schema, collation_name,
                                             numeric_precision, numeric_precision_radix, numeric_scale,
                                             datetime_precision, interval_type, interval_precision, domain_default,
                                             udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
                                             maximum_cardinality, dtd_identifier) as
SELECT (current_database())::information_schema.sql_identifier                AS object_catalog,
       (n.nspname)::information_schema.sql_identifier                         AS object_schema,
       x.objname                                                              AS object_name,
       (x.objtype)::information_schema.character_data                         AS object_type,
       (x.objdtdid)::information_schema.sql_identifier                        AS collection_type_identifier,
       (
           CASE
               WHEN (nbt.nspname = 'pg_catalog'::name) THEN format_type(bt.oid, NULL::integer)
               ELSE 'USER-DEFINED'::text
               END)::information_schema.character_data                        AS data_type,
       (NULL::integer)::information_schema.cardinal_number                    AS character_maximum_length,
       (NULL::integer)::information_schema.cardinal_number                    AS character_octet_length,
       (NULL::character varying)::information_schema.sql_identifier           AS character_set_catalog,
       (NULL::character varying)::information_schema.sql_identifier           AS character_set_schema,
       (NULL::character varying)::information_schema.sql_identifier           AS character_set_name,
       (
           CASE
               WHEN (nco.nspname IS NOT NULL) THEN current_database()
               ELSE NULL::name
               END)::information_schema.sql_identifier                        AS collation_catalog,
       (nco.nspname)::information_schema.sql_identifier                       AS collation_schema,
       (co.collname)::information_schema.sql_identifier                       AS collation_name,
       (NULL::integer)::information_schema.cardinal_number                    AS numeric_precision,
       (NULL::integer)::information_schema.cardinal_number                    AS numeric_precision_radix,
       (NULL::integer)::information_schema.cardinal_number                    AS numeric_scale,
       (NULL::integer)::information_schema.cardinal_number                    AS datetime_precision,
       (NULL::character varying)::information_schema.character_data           AS interval_type,
       (NULL::integer)::information_schema.cardinal_number                    AS interval_precision,
       (NULL::character varying)::information_schema.character_data           AS domain_default,
       (current_database())::information_schema.sql_identifier                AS udt_catalog,
       (nbt.nspname)::information_schema.sql_identifier                       AS udt_schema,
       (bt.typname)::information_schema.sql_identifier                        AS udt_name,
       (NULL::character varying)::information_schema.sql_identifier           AS scope_catalog,
       (NULL::character varying)::information_schema.sql_identifier           AS scope_schema,
       (NULL::character varying)::information_schema.sql_identifier           AS scope_name,
       (NULL::integer)::information_schema.cardinal_number                    AS maximum_cardinality,
       (('a'::text || (x.objdtdid)::text))::information_schema.sql_identifier AS dtd_identifier
FROM pg_namespace n,
     pg_type at,
     pg_namespace nbt,
     pg_type bt,
     ((SELECT c.relnamespace,
              (c.relname)::information_schema.sql_identifier AS relname,
              CASE
                  WHEN (c.relkind = 'c'::"char") THEN 'USER-DEFINED TYPE'::text
                  ELSE 'TABLE'::text
                  END                                        AS "case",
              a.attnum,
              a.atttypid,
              a.attcollation
       FROM pg_class c,
            pg_attribute a
       WHERE ((c.oid = a.attrelid) AND
              (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'c'::"char"])) AND (a.attnum > 0) AND
              (NOT a.attisdropped))
       UNION ALL
       SELECT t.typnamespace,
              (t.typname)::information_schema.sql_identifier AS typname,
              'DOMAIN'::text                                 AS text,
              1,
              t.typbasetype,
              t.typcollation
       FROM pg_type t
       WHERE (t.typtype = 'd'::"char")
       UNION ALL
       SELECT ss.pronamespace,
              ((((ss.proname)::text || '_'::text) || (ss.oid)::text))::information_schema.sql_identifier AS sql_identifier,
              'ROUTINE'::text                                                                            AS text,
              (ss.x).n                                                                                   AS n,
              (ss.x).x                                                                                   AS x,
              0
       FROM (SELECT p.pronamespace,
                    p.proname,
                    p.oid,
                    information_schema._pg_expandarray(COALESCE(p.proallargtypes, (p.proargtypes)::oid[])) AS x
             FROM pg_proc p) ss
       UNION ALL
       SELECT p.pronamespace,
              ((((p.proname)::text || '_'::text) || (p.oid)::text))::information_schema.sql_identifier AS sql_identifier,
              'ROUTINE'::text                                                                          AS text,
              0,
              p.prorettype,
              0
       FROM pg_proc p) x (objschema, objname, objtype, objdtdid, objtypeid, objcollation)
         LEFT JOIN (pg_collation co
         JOIN pg_namespace nco ON ((co.collnamespace = nco.oid))) ON (((x.objcollation = co.oid) AND
                                                                       ((nco.nspname <> 'pg_catalog'::name) OR
                                                                        (co.collname <> 'default'::name)))))
WHERE ((n.oid = x.objschema) AND (at.oid = x.objtypeid) AND
       ((at.typelem <> (0)::oid) AND (at.typlen = '-1'::integer)) AND (at.typelem = bt.oid) AND
       (nbt.oid = bt.typnamespace) AND
       ((n.nspname, (x.objname)::text, x.objtype, ((x.objdtdid)::information_schema.sql_identifier)::text) IN
        (SELECT data_type_privileges.object_schema,
                data_type_privileges.object_name,
                data_type_privileges.object_type,
                data_type_privileges.dtd_identifier
         FROM information_schema.data_type_privileges)));

alter table information_schema.element_types
    owner to postgres;

create view information_schema._pg_foreign_table_columns(nspname, relname, attname, attfdwoptions) as
SELECT n.nspname,
       c.relname,
       a.attname,
       a.attfdwoptions
FROM pg_foreign_table t,
     pg_authid u,
     pg_namespace n,
     pg_class c,
     pg_attribute a
WHERE ((u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE'::text) OR
                                 has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text)) AND
       (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f'::"char") AND (a.attrelid = c.oid) AND
       (a.attnum > 0));

alter table information_schema._pg_foreign_table_columns
    owner to postgres;

create view information_schema.column_options(table_catalog, table_schema, table_name, column_name, option_name,
                                              option_value) as
SELECT (current_database())::information_schema.sql_identifier                                  AS table_catalog,
       (c.nspname)::information_schema.sql_identifier                                           AS table_schema,
       (c.relname)::information_schema.sql_identifier                                           AS table_name,
       (c.attname)::information_schema.sql_identifier                                           AS column_name,
       ((pg_options_to_table(c.attfdwoptions)).option_name)::information_schema.sql_identifier  AS option_name,
       ((pg_options_to_table(c.attfdwoptions)).option_value)::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_table_columns c;

alter table information_schema.column_options
    owner to postgres;

create view information_schema._pg_foreign_data_wrappers(oid, fdwowner, fdwoptions, foreign_data_wrapper_catalog,
                                                         foreign_data_wrapper_name, authorization_identifier,
                                                         foreign_data_wrapper_language) as
SELECT w.oid,
       w.fdwowner,
       w.fdwoptions,
       (current_database())::information_schema.sql_identifier     AS foreign_data_wrapper_catalog,
       (w.fdwname)::information_schema.sql_identifier              AS foreign_data_wrapper_name,
       (u.rolname)::information_schema.sql_identifier              AS authorization_identifier,
       ('c'::character varying)::information_schema.character_data AS foreign_data_wrapper_language
FROM pg_foreign_data_wrapper w,
     pg_authid u
WHERE ((u.oid = w.fdwowner) AND
       (pg_has_role(w.fdwowner, 'USAGE'::text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE'::text)));

alter table information_schema._pg_foreign_data_wrappers
    owner to postgres;

create view information_schema.foreign_data_wrapper_options(foreign_data_wrapper_catalog, foreign_data_wrapper_name,
                                                            option_name, option_value) as
SELECT w.foreign_data_wrapper_catalog,
       w.foreign_data_wrapper_name,
       ((pg_options_to_table(w.fdwoptions)).option_name)::information_schema.sql_identifier  AS option_name,
       ((pg_options_to_table(w.fdwoptions)).option_value)::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_data_wrappers w;

alter table information_schema.foreign_data_wrapper_options
    owner to postgres;

create view information_schema.foreign_data_wrappers(foreign_data_wrapper_catalog, foreign_data_wrapper_name,
                                                     authorization_identifier, library_name,
                                                     foreign_data_wrapper_language) as
SELECT w.foreign_data_wrapper_catalog,
       w.foreign_data_wrapper_name,
       w.authorization_identifier,
       (NULL::character varying)::information_schema.character_data AS library_name,
       w.foreign_data_wrapper_language
FROM information_schema._pg_foreign_data_wrappers w;

alter table information_schema.foreign_data_wrappers
    owner to postgres;

create view information_schema._pg_foreign_servers(oid, srvoptions, foreign_server_catalog, foreign_server_name,
                                                   foreign_data_wrapper_catalog, foreign_data_wrapper_name,
                                                   foreign_server_type, foreign_server_version,
                                                   authorization_identifier) as
SELECT s.oid,
       s.srvoptions,
       (current_database())::information_schema.sql_identifier AS foreign_server_catalog,
       (s.srvname)::information_schema.sql_identifier          AS foreign_server_name,
       (current_database())::information_schema.sql_identifier AS foreign_data_wrapper_catalog,
       (w.fdwname)::information_schema.sql_identifier          AS foreign_data_wrapper_name,
       (s.srvtype)::information_schema.character_data          AS foreign_server_type,
       (s.srvversion)::information_schema.character_data       AS foreign_server_version,
       (u.rolname)::information_schema.sql_identifier          AS authorization_identifier
FROM pg_foreign_server s,
     pg_foreign_data_wrapper w,
     pg_authid u
WHERE ((w.oid = s.srvfdw) AND (u.oid = s.srvowner) AND
       (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)));

alter table information_schema._pg_foreign_servers
    owner to postgres;

create view information_schema.foreign_server_options(foreign_server_catalog, foreign_server_name, option_name,
                                                      option_value) as
SELECT s.foreign_server_catalog,
       s.foreign_server_name,
       ((pg_options_to_table(s.srvoptions)).option_name)::information_schema.sql_identifier  AS option_name,
       ((pg_options_to_table(s.srvoptions)).option_value)::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_servers s;

alter table information_schema.foreign_server_options
    owner to postgres;

create view information_schema.foreign_servers(foreign_server_catalog, foreign_server_name,
                                               foreign_data_wrapper_catalog, foreign_data_wrapper_name,
                                               foreign_server_type, foreign_server_version, authorization_identifier) as
SELECT _pg_foreign_servers.foreign_server_catalog,
       _pg_foreign_servers.foreign_server_name,
       _pg_foreign_servers.foreign_data_wrapper_catalog,
       _pg_foreign_servers.foreign_data_wrapper_name,
       _pg_foreign_servers.foreign_server_type,
       _pg_foreign_servers.foreign_server_version,
       _pg_foreign_servers.authorization_identifier
FROM information_schema._pg_foreign_servers;

alter table information_schema.foreign_servers
    owner to postgres;

create view information_schema._pg_foreign_tables(foreign_table_catalog, foreign_table_schema, foreign_table_name,
                                                  ftoptions, foreign_server_catalog, foreign_server_name,
                                                  authorization_identifier) as
SELECT (current_database())::information_schema.sql_identifier AS foreign_table_catalog,
       (n.nspname)::information_schema.sql_identifier          AS foreign_table_schema,
       (c.relname)::information_schema.sql_identifier          AS foreign_table_name,
       t.ftoptions,
       (current_database())::information_schema.sql_identifier AS foreign_server_catalog,
       (s.srvname)::information_schema.sql_identifier          AS foreign_server_name,
       (u.rolname)::information_schema.sql_identifier          AS authorization_identifier
FROM pg_foreign_table t,
     pg_foreign_server s,
     pg_foreign_data_wrapper w,
     pg_authid u,
     pg_namespace n,
     pg_class c
WHERE ((w.oid = s.srvfdw) AND (u.oid = c.relowner) AND (pg_has_role(c.relowner, 'USAGE'::text) OR
                                                        has_table_privilege(c.oid,
                                                                            'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
                                                        has_any_column_privilege(c.oid,
                                                                                 'SELECT, INSERT, UPDATE, REFERENCES'::text)) AND
       (n.oid = c.relnamespace) AND (c.oid = t.ftrelid) AND (c.relkind = 'f'::"char") AND (s.oid = t.ftserver));

alter table information_schema._pg_foreign_tables
    owner to postgres;

create view information_schema.foreign_table_options(foreign_table_catalog, foreign_table_schema, foreign_table_name,
                                                     option_name, option_value) as
SELECT t.foreign_table_catalog,
       t.foreign_table_schema,
       t.foreign_table_name,
       ((pg_options_to_table(t.ftoptions)).option_name)::information_schema.sql_identifier  AS option_name,
       ((pg_options_to_table(t.ftoptions)).option_value)::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_tables t;

alter table information_schema.foreign_table_options
    owner to postgres;

create view information_schema.foreign_tables(foreign_table_catalog, foreign_table_schema, foreign_table_name,
                                              foreign_server_catalog, foreign_server_name) as
SELECT _pg_foreign_tables.foreign_table_catalog,
       _pg_foreign_tables.foreign_table_schema,
       _pg_foreign_tables.foreign_table_name,
       _pg_foreign_tables.foreign_server_catalog,
       _pg_foreign_tables.foreign_server_name
FROM information_schema._pg_foreign_tables;

alter table information_schema.foreign_tables
    owner to postgres;

create view information_schema._pg_user_mappings(oid, umoptions, umuser, authorization_identifier,
                                                 foreign_server_catalog, foreign_server_name, srvowner) as
SELECT um.oid,
       um.umoptions,
       um.umuser,
       (COALESCE(u.rolname, 'PUBLIC'::name))::information_schema.sql_identifier AS authorization_identifier,
       s.foreign_server_catalog,
       s.foreign_server_name,
       s.authorization_identifier                                               AS srvowner
FROM (pg_user_mapping um
         LEFT JOIN pg_authid u ON ((u.oid = um.umuser))),
     information_schema._pg_foreign_servers s
WHERE (s.oid = um.umserver);

alter table information_schema._pg_user_mappings
    owner to postgres;

create view information_schema.user_mapping_options(authorization_identifier, foreign_server_catalog,
                                                    foreign_server_name, option_name, option_value) as
SELECT um.authorization_identifier,
       um.foreign_server_catalog,
       um.foreign_server_name,
       ((pg_options_to_table(um.umoptions)).option_name)::information_schema.sql_identifier AS option_name,
       (
           CASE
               WHEN (((um.umuser <> (0)::oid) AND ((um.authorization_identifier)::name = "current_user"())) OR
                     ((um.umuser = (0)::oid) AND pg_has_role((um.srvowner)::name, 'USAGE'::text)) OR
                     (SELECT pg_authid.rolsuper
                      FROM pg_authid
                      WHERE (pg_authid.rolname = "current_user"())))
                   THEN (pg_options_to_table(um.umoptions)).option_value
               ELSE NULL::text
               END)::information_schema.character_data                                      AS option_value
FROM information_schema._pg_user_mappings um;

alter table information_schema.user_mapping_options
    owner to postgres;

create view information_schema.user_mappings(authorization_identifier, foreign_server_catalog, foreign_server_name) as
SELECT _pg_user_mappings.authorization_identifier,
       _pg_user_mappings.foreign_server_catalog,
       _pg_user_mappings.foreign_server_name
FROM information_schema._pg_user_mappings;

alter table information_schema.user_mappings
    owner to postgres;

create view timescaledb_information.hypertable(table_schema, table_name, table_owner, num_dimensions, num_chunks,
                                               table_size, index_size, toast_size, total_size) as
SELECT ht.schema_name                     AS table_schema,
       ht.table_name,
       t.tableowner                       AS table_owner,
       ht.num_dimensions,
       (SELECT count(1) AS count
        FROM _timescaledb_catalog.chunk ch
        WHERE (ch.hypertable_id = ht.id)) AS num_chunks,
       size.table_size,
       size.index_size,
       size.toast_size,
       size.total_size
FROM ((_timescaledb_catalog.hypertable ht
    LEFT JOIN pg_tables t ON (((ht.table_name = t.tablename) AND (ht.schema_name = t.schemaname))))
         LEFT JOIN LATERAL hypertable_relation_size_pretty((
    CASE
        WHEN has_schema_privilege((ht.schema_name)::text, 'USAGE'::text)
            THEN format('%I.%I'::text, ht.schema_name, ht.table_name)
        ELSE NULL::text
        END)::regclass) size(table_size, index_size, toast_size, total_size) ON (true));

alter table timescaledb_information.hypertable
    owner to postgres;

create view timescaledb_information.license(edition, expired, expiration_time) as
SELECT _timescaledb_internal.license_edition()                    AS edition,
       (_timescaledb_internal.license_expiration_time() <= now()) AS expired,
       _timescaledb_internal.license_expiration_time()            AS expiration_time;

alter table timescaledb_information.license
    owner to postgres;

create view timescaledb_information.drop_chunks_policies(hypertable, older_than, cascade, job_id, schedule_interval,
                                                         max_runtime, max_retries, retry_period,
                                                         cascade_to_materializations) as
SELECT (format('%1$I.%2$I'::text, ht.schema_name, ht.table_name))::regclass AS hypertable,
       p.older_than,
       p.cascade,
       p.job_id,
       j.schedule_interval,
       j.max_runtime,
       j.max_retries,
       j.retry_period,
       p.cascade_to_materializations
FROM ((_timescaledb_config.bgw_policy_drop_chunks p
    JOIN _timescaledb_catalog.hypertable ht ON ((p.hypertable_id = ht.id)))
         JOIN _timescaledb_config.bgw_job j ON ((p.job_id = j.id)));

alter table timescaledb_information.drop_chunks_policies
    owner to postgres;

create view timescaledb_information.reorder_policies(hypertable, hypertable_index_name, job_id, schedule_interval,
                                                     max_runtime, max_retries, retry_period) as
SELECT (format('%1$I.%2$I'::text, ht.schema_name, ht.table_name))::regclass AS hypertable,
       p.hypertable_index_name,
       p.job_id,
       j.schedule_interval,
       j.max_runtime,
       j.max_retries,
       j.retry_period
FROM ((_timescaledb_config.bgw_policy_reorder p
    JOIN _timescaledb_catalog.hypertable ht ON ((p.hypertable_id = ht.id)))
         JOIN _timescaledb_config.bgw_job j ON ((p.job_id = j.id)));

alter table timescaledb_information.reorder_policies
    owner to postgres;

create view timescaledb_information.policy_stats(hypertable, job_id, job_type, last_run_success, last_finish,
                                                 last_start, next_start, total_runs, total_failures) as
SELECT (format('%1$I.%2$I'::text, ht.schema_name, ht.table_name))::regclass AS hypertable,
       p.job_id,
       j.job_type,
       js.last_run_success,
       js.last_finish,
       js.last_start,
       js.next_start,
       js.total_runs,
       js.total_failures
FROM ((((SELECT bgw_policy_reorder.job_id,
                bgw_policy_reorder.hypertable_id
         FROM _timescaledb_config.bgw_policy_reorder
         UNION
         SELECT bgw_policy_drop_chunks.job_id,
                bgw_policy_drop_chunks.hypertable_id
         FROM _timescaledb_config.bgw_policy_drop_chunks) p
    JOIN _timescaledb_catalog.hypertable ht ON ((p.hypertable_id = ht.id)))
    JOIN _timescaledb_config.bgw_job j ON ((p.job_id = j.id)))
         JOIN _timescaledb_internal.bgw_job_stat js ON ((p.job_id = js.job_id)))
ORDER BY ht.schema_name, ht.table_name;

alter table timescaledb_information.policy_stats
    owner to postgres;

create view timescaledb_information.continuous_aggregates(view_name, view_owner, refresh_lag, refresh_interval,
                                                          max_interval_per_job, materialization_hypertable,
                                                          view_definition) as
SELECT (format('%1$I.%2$I'::text, cagg.user_view_schema, cagg.user_view_name))::regclass AS view_name,
       viewinfo.viewowner                                                                AS view_owner,
       CASE _timescaledb_internal.get_time_type(cagg.raw_hypertable_id)
           WHEN 'timestamp without time zone'::regtype THEN (_timescaledb_internal.to_interval(cagg.refresh_lag))::text
           WHEN 'timestamp with time zone'::regtype THEN (_timescaledb_internal.to_interval(cagg.refresh_lag))::text
           WHEN 'date'::regtype THEN (_timescaledb_internal.to_interval(cagg.refresh_lag))::text
           ELSE (cagg.refresh_lag)::text
           END                                                                           AS refresh_lag,
       bgwjob.schedule_interval                                                          AS refresh_interval,
       CASE _timescaledb_internal.get_time_type(cagg.raw_hypertable_id)
           WHEN 'timestamp without time zone'::regtype
               THEN (_timescaledb_internal.to_interval(cagg.max_interval_per_job))::text
           WHEN 'timestamp with time zone'::regtype THEN (_timescaledb_internal.to_interval(cagg.max_interval_per_job))::text
           WHEN 'date'::regtype THEN (_timescaledb_internal.to_interval(cagg.max_interval_per_job))::text
           ELSE (cagg.max_interval_per_job)::text
           END                                                                           AS max_interval_per_job,
       (format('%1$I.%2$I'::text, ht.schema_name, ht.table_name))::regclass              AS materialization_hypertable,
       directview.viewdefinition                                                         AS view_definition
FROM _timescaledb_catalog.continuous_agg cagg,
     _timescaledb_catalog.hypertable ht,
     LATERAL ( SELECT c.oid,
                      pg_get_userbyid(c.relowner) AS viewowner
               FROM (pg_class c
                        LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
               WHERE ((c.relkind = 'v'::"char") AND (c.relname = cagg.user_view_name) AND
                      (n.nspname = cagg.user_view_schema))) viewinfo,
     LATERAL ( SELECT bgw_job.schedule_interval
               FROM _timescaledb_config.bgw_job
               WHERE (bgw_job.id = cagg.job_id)) bgwjob,
     LATERAL ( SELECT pg_get_viewdef(c.oid) AS viewdefinition
               FROM (pg_class c
                        LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
               WHERE ((c.relkind = 'v'::"char") AND (c.relname = cagg.direct_view_name) AND
                      (n.nspname = cagg.direct_view_schema))) directview
WHERE (cagg.mat_hypertable_id = ht.id);

alter table timescaledb_information.continuous_aggregates
    owner to postgres;

create view timescaledb_information.continuous_aggregate_stats(view_name, completed_threshold, invalidation_threshold,
                                                               job_id, last_run_started_at, last_run_status, job_status,
                                                               last_run_duration, next_scheduled_run, total_runs,
                                                               total_successes, total_failures, total_crashes) as
SELECT (format('%1$I.%2$I'::text, cagg.user_view_schema, cagg.user_view_name))::regclass AS view_name,
       CASE _timescaledb_internal.get_time_type(cagg.raw_hypertable_id)
           WHEN 'timestamp without time zone'::regtype
               THEN (_timescaledb_internal.to_timestamp_without_timezone(ct.watermark))::text
           WHEN 'timestamp with time zone'::regtype THEN (_timescaledb_internal.to_timestamp(ct.watermark))::text
           WHEN 'date'::regtype THEN (_timescaledb_internal.to_date(ct.watermark))::text
           ELSE (ct.watermark)::text
           END                                                                           AS completed_threshold,
       CASE _timescaledb_internal.get_time_type(cagg.raw_hypertable_id)
           WHEN 'timestamp without time zone'::regtype
               THEN (_timescaledb_internal.to_timestamp_without_timezone(it.watermark))::text
           WHEN 'timestamp with time zone'::regtype THEN (_timescaledb_internal.to_timestamp(it.watermark))::text
           WHEN 'date'::regtype THEN (_timescaledb_internal.to_date(it.watermark))::text
           ELSE (it.watermark)::text
           END                                                                           AS invalidation_threshold,
       cagg.job_id,
       bgw_job_stat.last_start                                                           AS last_run_started_at,
       CASE
           WHEN (bgw_job_stat.last_run_success = true) THEN 'Success'::text
           WHEN (bgw_job_stat.last_run_success = false) THEN 'Failed'::text
           ELSE NULL::text
           END                                                                           AS last_run_status,
       CASE
           WHEN (bgw_job_stat.last_finish < '4714-11-24 00:00:00+00 BC'::timestamp with time zone) THEN 'running'::text
           WHEN (bgw_job_stat.next_start IS NOT NULL) THEN 'scheduled'::text
           ELSE NULL::text
           END                                                                           AS job_status,
       CASE
           WHEN (bgw_job_stat.last_finish > bgw_job_stat.last_start)
               THEN (bgw_job_stat.last_finish - bgw_job_stat.last_start)
           ELSE NULL::interval
           END                                                                           AS last_run_duration,
       bgw_job_stat.next_start                                                           AS next_scheduled_run,
       bgw_job_stat.total_runs,
       bgw_job_stat.total_successes,
       bgw_job_stat.total_failures,
       bgw_job_stat.total_crashes
FROM (((_timescaledb_catalog.continuous_agg cagg
    LEFT JOIN _timescaledb_internal.bgw_job_stat bgw_job_stat ON ((cagg.job_id = bgw_job_stat.job_id)))
    LEFT JOIN _timescaledb_catalog.continuous_aggs_invalidation_threshold it ON ((cagg.raw_hypertable_id = it.hypertable_id)))
         LEFT JOIN _timescaledb_catalog.continuous_aggs_completed_threshold ct
                   ON ((cagg.mat_hypertable_id = ct.materialization_id)));

alter table timescaledb_information.continuous_aggregate_stats
    owner to postgres;

create function pg_catalog.byteaout(bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteaout(bytea) is 'I/O';

alter function pg_catalog.byteaout(bytea) owner to postgres;

create function pg_catalog.charout("char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.charout("char") is 'I/O';

alter function pg_catalog.charout("char") owner to postgres;

create function pg_catalog.namein(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namein(cstring) is 'I/O';

alter function pg_catalog.namein(cstring) owner to postgres;

create function pg_catalog.nameout(name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nameout(name) is 'I/O';

alter function pg_catalog.nameout(name) owner to postgres;

create function pg_catalog.int2in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2in(cstring) is 'I/O';

alter function pg_catalog.int2in(cstring) owner to postgres;

create function pg_catalog.int2out(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2out(smallint) is 'I/O';

alter function pg_catalog.int2out(smallint) owner to postgres;

create function pg_catalog.int2vectorin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2vectorin(cstring) is 'I/O';

alter function pg_catalog.int2vectorin(cstring) owner to postgres;

create function pg_catalog.int2vectorout(int2vector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2vectorout(int2vector) is 'I/O';

alter function pg_catalog.int2vectorout(int2vector) owner to postgres;

create function pg_catalog.int4in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4in(cstring) is 'I/O';

alter function pg_catalog.int4in(cstring) owner to postgres;

create function pg_catalog.int4out(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4out(integer) is 'I/O';

alter function pg_catalog.int4out(integer) owner to postgres;

create function pg_catalog.regprocin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regprocin(cstring) is 'I/O';

alter function pg_catalog.regprocin(cstring) owner to postgres;

create function pg_catalog.regprocout(regproc)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regprocout(regproc) is 'I/O';

alter function pg_catalog.regprocout(regproc) owner to postgres;

create function pg_catalog.textin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textin(cstring) is 'I/O';

alter function pg_catalog.textin(cstring) owner to postgres;

create function pg_catalog.textout(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textout(text) is 'I/O';

alter function pg_catalog.textout(text) owner to postgres;

create function pg_catalog.tidin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidin(cstring) is 'I/O';

alter function pg_catalog.tidin(cstring) owner to postgres;

create function pg_catalog.tidout(tid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidout(tid) is 'I/O';

alter function pg_catalog.tidout(tid) owner to postgres;

create function pg_catalog.xidin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xidin(cstring) is 'I/O';

alter function pg_catalog.xidin(cstring) owner to postgres;

create function pg_catalog.xidout(xid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xidout(xid) is 'I/O';

alter function pg_catalog.xidout(xid) owner to postgres;

create function pg_catalog.cidin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidin(cstring) is 'I/O';

alter function pg_catalog.cidin(cstring) owner to postgres;

create function pg_catalog.cidout(cid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidout(cid) is 'I/O';

alter function pg_catalog.cidout(cid) owner to postgres;

create function pg_catalog.oidvectorin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorin(cstring) is 'I/O';

alter function pg_catalog.oidvectorin(cstring) owner to postgres;

create function pg_catalog.oidvectorout(oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorout(oidvector) is 'I/O';

alter function pg_catalog.oidvectorout(oidvector) owner to postgres;

create function pg_catalog.boollt(boolean, boolean)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boollt(boolean, boolean) is 'implementation of < operator';

alter function pg_catalog.boollt(boolean, boolean) owner to postgres;

create function pg_catalog.boolgt(boolean, boolean)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolgt(boolean, boolean) is 'implementation of > operator';

alter function pg_catalog.boolgt(boolean, boolean) owner to postgres;

create function pg_catalog.booleq(boolean, boolean)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.booleq(boolean, boolean) is 'implementation of = operator';

alter function pg_catalog.booleq(boolean, boolean) owner to postgres;

create function pg_catalog.chareq("char", "char")
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.chareq("char", "char") is 'implementation of = operator';

alter function pg_catalog.chareq("char", "char") owner to postgres;

create function pg_catalog.nameeq(name, name)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nameeq(name, name) is 'implementation of = operator';

alter function pg_catalog.nameeq(name, name) owner to postgres;

create function pg_catalog.int2eq(smallint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2eq(smallint, smallint) is 'implementation of = operator';

alter function pg_catalog.int2eq(smallint, smallint) owner to postgres;

create function pg_catalog.int2lt(smallint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2lt(smallint, smallint) is 'implementation of < operator';

alter function pg_catalog.int2lt(smallint, smallint) owner to postgres;

create function pg_catalog.int4eq(integer, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4eq(integer, integer) is 'implementation of = operator';

alter function pg_catalog.int4eq(integer, integer) owner to postgres;

create function pg_catalog.int4lt(integer, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4lt(integer, integer) is 'implementation of < operator';

alter function pg_catalog.int4lt(integer, integer) owner to postgres;

create function pg_catalog.texteq(text, text)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.texteq(text, text) is 'implementation of = operator';

alter function pg_catalog.texteq(text, text) owner to postgres;

create function pg_catalog.xideq(xid, xid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xideq(xid, xid) is 'implementation of = operator';

alter function pg_catalog.xideq(xid, xid) owner to postgres;

create function pg_catalog.cideq(cid, cid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cideq(cid, cid) is 'implementation of = operator';

alter function pg_catalog.cideq(cid, cid) owner to postgres;

create function pg_catalog.charne("char", "char")
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.charne("char", "char") is 'implementation of <> operator';

alter function pg_catalog.charne("char", "char") owner to postgres;

create function pg_catalog.charle("char", "char")
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.charle("char", "char") is 'implementation of <= operator';

alter function pg_catalog.charle("char", "char") owner to postgres;

create function pg_catalog.chargt("char", "char")
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.chargt("char", "char") is 'implementation of > operator';

alter function pg_catalog.chargt("char", "char") owner to postgres;

create function pg_catalog.charge("char", "char")
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.charge("char", "char") is 'implementation of >= operator';

alter function pg_catalog.charge("char", "char") owner to postgres;

create function pg_catalog.int4("char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4("char") is 'convert char to int4';

alter function pg_catalog.int4("char") owner to postgres;

create function pg_catalog.char(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.char(integer) is 'convert int4 to char';

alter function pg_catalog.char(integer) owner to postgres;

create function pg_catalog.nameregexeq(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nameregexeq(name, text) is 'implementation of ~ operator';

alter function pg_catalog.nameregexeq(name, text) owner to postgres;

create function pg_catalog.boolne(boolean, boolean)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolne(boolean, boolean) is 'implementation of <> operator';

alter function pg_catalog.boolne(boolean, boolean) owner to postgres;

create function pg_catalog.pg_ddl_command_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ddl_command_in(cstring) is 'I/O';

alter function pg_catalog.pg_ddl_command_in(cstring) owner to postgres;

create function pg_catalog.pg_ddl_command_out(pg_ddl_command)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ddl_command_out(pg_ddl_command) is 'I/O';

alter function pg_catalog.pg_ddl_command_out(pg_ddl_command) owner to postgres;

create function pg_catalog.pg_ddl_command_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ddl_command_recv(internal) is 'I/O';

alter function pg_catalog.pg_ddl_command_recv(internal) owner to postgres;

create function pg_catalog.version()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.version() is 'PostgreSQL version string';

alter function pg_catalog.version() owner to postgres;

create function pg_catalog.pg_ddl_command_send(pg_ddl_command)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ddl_command_send(pg_ddl_command) is 'I/O';

alter function pg_catalog.pg_ddl_command_send(pg_ddl_command) owner to postgres;

create function pg_catalog.eqsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.eqsel(internal, oid, internal, integer) is 'restriction selectivity of = and related operators';

alter function pg_catalog.eqsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.neqsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.neqsel(internal, oid, internal, integer) is 'restriction selectivity of <> and related operators';

alter function pg_catalog.neqsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.scalarltsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.scalarltsel(internal, oid, internal, integer) is 'restriction selectivity of < and related operators on scalar datatypes';

alter function pg_catalog.scalarltsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.scalargtsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.scalargtsel(internal, oid, internal, integer) is 'restriction selectivity of > and related operators on scalar datatypes';

alter function pg_catalog.scalargtsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of = and related operators';

alter function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of <> and related operators';

alter function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of < and related operators on scalar datatypes';

alter function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of > and related operators on scalar datatypes';

alter function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.unknownin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.unknownin(cstring) is 'I/O';

alter function pg_catalog.unknownin(cstring) owner to postgres;

create function pg_catalog.unknownout(unknown)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.unknownout(unknown) is 'I/O';

alter function pg_catalog.unknownout(unknown) owner to postgres;

create function pg_catalog.numeric_fac(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_fac(bigint) is 'implementation of ! operator';

alter function pg_catalog.numeric_fac(bigint) owner to postgres;

create function pg_catalog.box_above_eq(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_above_eq(box, box) is 'implementation of >^ operator';

alter function pg_catalog.box_above_eq(box, box) owner to postgres;

create function pg_catalog.box_below_eq(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_below_eq(box, box) is 'implementation of <^ operator';

alter function pg_catalog.box_below_eq(box, box) owner to postgres;

create function pg_catalog.point_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_in(cstring) is 'I/O';

alter function pg_catalog.point_in(cstring) owner to postgres;

create function pg_catalog.point_out(point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_out(point) is 'I/O';

alter function pg_catalog.point_out(point) owner to postgres;

create function pg_catalog.lseg_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_in(cstring) is 'I/O';

alter function pg_catalog.lseg_in(cstring) owner to postgres;

create function pg_catalog.lseg_out(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_out(lseg) is 'I/O';

alter function pg_catalog.lseg_out(lseg) owner to postgres;

create function pg_catalog.path_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_in(cstring) is 'I/O';

alter function pg_catalog.path_in(cstring) owner to postgres;

create function pg_catalog.path_out(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_out(path) is 'I/O';

alter function pg_catalog.path_out(path) owner to postgres;

create function pg_catalog.box_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_in(cstring) is 'I/O';

alter function pg_catalog.box_in(cstring) owner to postgres;

create function pg_catalog.box_out(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_out(box) is 'I/O';

alter function pg_catalog.box_out(box) owner to postgres;

create function pg_catalog.box_overlap(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_overlap(box, box) is 'implementation of && operator';

alter function pg_catalog.box_overlap(box, box) owner to postgres;

create function pg_catalog.box_ge(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_ge(box, box) is 'implementation of >= operator';

alter function pg_catalog.box_ge(box, box) owner to postgres;

create function pg_catalog.box_gt(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_gt(box, box) is 'implementation of > operator';

alter function pg_catalog.box_gt(box, box) owner to postgres;

create function pg_catalog.box_eq(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_eq(box, box) is 'implementation of = operator';

alter function pg_catalog.box_eq(box, box) owner to postgres;

create function pg_catalog.box_lt(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_lt(box, box) is 'implementation of < operator';

alter function pg_catalog.box_lt(box, box) owner to postgres;

create function pg_catalog.box_le(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_le(box, box) is 'implementation of <= operator';

alter function pg_catalog.box_le(box, box) owner to postgres;

create function pg_catalog.point_above(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_above(point, point) is 'implementation of >^ operator';

alter function pg_catalog.point_above(point, point) owner to postgres;

create function pg_catalog.point_left(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_left(point, point) is 'implementation of << operator';

alter function pg_catalog.point_left(point, point) owner to postgres;

create function pg_catalog.point_right(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_right(point, point) is 'implementation of >> operator';

alter function pg_catalog.point_right(point, point) owner to postgres;

create function pg_catalog.point_below(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_below(point, point) is 'implementation of <^ operator';

alter function pg_catalog.point_below(point, point) owner to postgres;

create function pg_catalog.point_eq(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_eq(point, point) is 'implementation of ~= operator';

alter function pg_catalog.point_eq(point, point) owner to postgres;

create function pg_catalog.on_pb(point, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.on_pb(point, box) is 'implementation of <@ operator';

alter function pg_catalog.on_pb(point, box) owner to postgres;

create function pg_catalog.on_ppath(point, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.on_ppath(point, path) is 'implementation of <@ operator';

alter function pg_catalog.on_ppath(point, path) owner to postgres;

create function pg_catalog.box_center(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_center(box) is 'implementation of @@ operator';

alter function pg_catalog.box_center(box) owner to postgres;

create function pg_catalog.areasel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.areasel(internal, oid, internal, integer) is 'restriction selectivity for area-comparison operators';

alter function pg_catalog.areasel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for area-comparison operators';

alter function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.int4mul(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4mul(integer, integer) is 'implementation of * operator';

alter function pg_catalog.int4mul(integer, integer) owner to postgres;

create function pg_catalog.int4ne(integer, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4ne(integer, integer) is 'implementation of <> operator';

alter function pg_catalog.int4ne(integer, integer) owner to postgres;

create function pg_catalog.int2ne(smallint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2ne(smallint, smallint) is 'implementation of <> operator';

alter function pg_catalog.int2ne(smallint, smallint) owner to postgres;

create function pg_catalog.int2gt(smallint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2gt(smallint, smallint) is 'implementation of > operator';

alter function pg_catalog.int2gt(smallint, smallint) owner to postgres;

create function pg_catalog.int4gt(integer, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4gt(integer, integer) is 'implementation of > operator';

alter function pg_catalog.int4gt(integer, integer) owner to postgres;

create function pg_catalog.int2le(smallint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2le(smallint, smallint) is 'implementation of <= operator';

alter function pg_catalog.int2le(smallint, smallint) owner to postgres;

create function pg_catalog.int4le(integer, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4le(integer, integer) is 'implementation of <= operator';

alter function pg_catalog.int4le(integer, integer) owner to postgres;

create function pg_catalog.int4ge(integer, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4ge(integer, integer) is 'implementation of >= operator';

alter function pg_catalog.int4ge(integer, integer) owner to postgres;

create function pg_catalog.int2ge(smallint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2ge(smallint, smallint) is 'implementation of >= operator';

alter function pg_catalog.int2ge(smallint, smallint) owner to postgres;

create function pg_catalog.int2mul(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2mul(smallint, smallint) is 'implementation of * operator';

alter function pg_catalog.int2mul(smallint, smallint) owner to postgres;

create function pg_catalog.int2div(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2div(smallint, smallint) is 'implementation of / operator';

alter function pg_catalog.int2div(smallint, smallint) owner to postgres;

create function pg_catalog.int4div(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4div(integer, integer) is 'implementation of / operator';

alter function pg_catalog.int4div(integer, integer) owner to postgres;

create function pg_catalog.int2mod(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2mod(smallint, smallint) is 'implementation of % operator';

alter function pg_catalog.int2mod(smallint, smallint) owner to postgres;

create function pg_catalog.int4mod(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4mod(integer, integer) is 'implementation of % operator';

alter function pg_catalog.int4mod(integer, integer) owner to postgres;

create function pg_catalog.textne(text, text)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textne(text, text) is 'implementation of <> operator';

alter function pg_catalog.textne(text, text) owner to postgres;

create function pg_catalog.int24eq(smallint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24eq(smallint, integer) is 'implementation of = operator';

alter function pg_catalog.int24eq(smallint, integer) owner to postgres;

create function pg_catalog.int42eq(integer, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42eq(integer, smallint) is 'implementation of = operator';

alter function pg_catalog.int42eq(integer, smallint) owner to postgres;

create function pg_catalog.int24lt(smallint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24lt(smallint, integer) is 'implementation of < operator';

alter function pg_catalog.int24lt(smallint, integer) owner to postgres;

create function pg_catalog.int42lt(integer, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42lt(integer, smallint) is 'implementation of < operator';

alter function pg_catalog.int42lt(integer, smallint) owner to postgres;

create function pg_catalog.int24gt(smallint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24gt(smallint, integer) is 'implementation of > operator';

alter function pg_catalog.int24gt(smallint, integer) owner to postgres;

create function pg_catalog.int42gt(integer, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42gt(integer, smallint) is 'implementation of > operator';

alter function pg_catalog.int42gt(integer, smallint) owner to postgres;

create function pg_catalog.int24ne(smallint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24ne(smallint, integer) is 'implementation of <> operator';

alter function pg_catalog.int24ne(smallint, integer) owner to postgres;

create function pg_catalog.int42ne(integer, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42ne(integer, smallint) is 'implementation of <> operator';

alter function pg_catalog.int42ne(integer, smallint) owner to postgres;

create function pg_catalog.int24le(smallint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24le(smallint, integer) is 'implementation of <= operator';

alter function pg_catalog.int24le(smallint, integer) owner to postgres;

create function pg_catalog.int42le(integer, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42le(integer, smallint) is 'implementation of <= operator';

alter function pg_catalog.int42le(integer, smallint) owner to postgres;

create function pg_catalog.int24ge(smallint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24ge(smallint, integer) is 'implementation of >= operator';

alter function pg_catalog.int24ge(smallint, integer) owner to postgres;

create function pg_catalog.int42ge(integer, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42ge(integer, smallint) is 'implementation of >= operator';

alter function pg_catalog.int42ge(integer, smallint) owner to postgres;

create function pg_catalog.int24mul(smallint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24mul(smallint, integer) is 'implementation of * operator';

alter function pg_catalog.int24mul(smallint, integer) owner to postgres;

create function pg_catalog.int42mul(integer, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42mul(integer, smallint) is 'implementation of * operator';

alter function pg_catalog.int42mul(integer, smallint) owner to postgres;

create function pg_catalog.int24div(smallint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24div(smallint, integer) is 'implementation of / operator';

alter function pg_catalog.int24div(smallint, integer) owner to postgres;

create function pg_catalog.int42div(integer, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42div(integer, smallint) is 'implementation of / operator';

alter function pg_catalog.int42div(integer, smallint) owner to postgres;

create function pg_catalog.int2pl(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2pl(smallint, smallint) is 'implementation of + operator';

alter function pg_catalog.int2pl(smallint, smallint) owner to postgres;

create function pg_catalog.int4pl(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4pl(integer, integer) is 'implementation of + operator';

alter function pg_catalog.int4pl(integer, integer) owner to postgres;

create function pg_catalog.int24pl(smallint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24pl(smallint, integer) is 'implementation of + operator';

alter function pg_catalog.int24pl(smallint, integer) owner to postgres;

create function pg_catalog.int42pl(integer, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42pl(integer, smallint) is 'implementation of + operator';

alter function pg_catalog.int42pl(integer, smallint) owner to postgres;

create function pg_catalog.int2mi(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2mi(smallint, smallint) is 'implementation of - operator';

alter function pg_catalog.int2mi(smallint, smallint) owner to postgres;

create function pg_catalog.int4mi(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4mi(integer, integer) is 'implementation of - operator';

alter function pg_catalog.int4mi(integer, integer) owner to postgres;

create function pg_catalog.int24mi(smallint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int24mi(smallint, integer) is 'implementation of - operator';

alter function pg_catalog.int24mi(smallint, integer) owner to postgres;

create function pg_catalog.int42mi(integer, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int42mi(integer, smallint) is 'implementation of - operator';

alter function pg_catalog.int42mi(integer, smallint) owner to postgres;

create function pg_catalog.oideq(oid, oid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oideq(oid, oid) is 'implementation of = operator';

alter function pg_catalog.oideq(oid, oid) owner to postgres;

create function pg_catalog.oidne(oid, oid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidne(oid, oid) is 'implementation of <> operator';

alter function pg_catalog.oidne(oid, oid) owner to postgres;

create function pg_catalog.box_same(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_same(box, box) is 'implementation of ~= operator';

alter function pg_catalog.box_same(box, box) owner to postgres;

create function pg_catalog.box_contain(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_contain(box, box) is 'implementation of @> operator';

alter function pg_catalog.box_contain(box, box) owner to postgres;

create function pg_catalog.box_left(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_left(box, box) is 'implementation of << operator';

alter function pg_catalog.box_left(box, box) owner to postgres;

create function pg_catalog.box_overleft(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_overleft(box, box) is 'implementation of &< operator';

alter function pg_catalog.box_overleft(box, box) owner to postgres;

create function pg_catalog.box_overright(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_overright(box, box) is 'implementation of &> operator';

alter function pg_catalog.box_overright(box, box) owner to postgres;

create function pg_catalog.box_right(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_right(box, box) is 'implementation of >> operator';

alter function pg_catalog.box_right(box, box) owner to postgres;

create function pg_catalog.box_contained(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_contained(box, box) is 'implementation of <@ operator';

alter function pg_catalog.box_contained(box, box) owner to postgres;

create function pg_catalog.box_contain_pt(box, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_contain_pt(box, point) is 'implementation of @> operator';

alter function pg_catalog.box_contain_pt(box, point) owner to postgres;

create function pg_catalog.pg_node_tree_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_node_tree_in(cstring) is 'I/O';

alter function pg_catalog.pg_node_tree_in(cstring) owner to postgres;

create function pg_catalog.pg_node_tree_out(pg_node_tree)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_node_tree_out(pg_node_tree) is 'I/O';

alter function pg_catalog.pg_node_tree_out(pg_node_tree) owner to postgres;

create function pg_catalog.pg_node_tree_recv(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_node_tree_recv(internal) is 'I/O';

alter function pg_catalog.pg_node_tree_recv(internal) owner to postgres;

create function pg_catalog.pg_node_tree_send(pg_node_tree)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_node_tree_send(pg_node_tree) is 'I/O';

alter function pg_catalog.pg_node_tree_send(pg_node_tree) owner to postgres;

create function pg_catalog.float4in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4in(cstring) is 'I/O';

alter function pg_catalog.float4in(cstring) owner to postgres;

create function pg_catalog.float4out(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4out(real) is 'I/O';

alter function pg_catalog.float4out(real) owner to postgres;

create function pg_catalog.float4mul(real, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4mul(real, real) is 'implementation of * operator';

alter function pg_catalog.float4mul(real, real) owner to postgres;

create function pg_catalog.float4div(real, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4div(real, real) is 'implementation of / operator';

alter function pg_catalog.float4div(real, real) owner to postgres;

create function pg_catalog.float4pl(real, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4pl(real, real) is 'implementation of + operator';

alter function pg_catalog.float4pl(real, real) owner to postgres;

create function pg_catalog.float4mi(real, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4mi(real, real) is 'implementation of - operator';

alter function pg_catalog.float4mi(real, real) owner to postgres;

create function pg_catalog.float4um(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4um(real) is 'implementation of - operator';

alter function pg_catalog.float4um(real) owner to postgres;

create function pg_catalog.float4abs(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4abs(real) is 'implementation of @ operator';

alter function pg_catalog.float4abs(real) owner to postgres;

create function pg_catalog.float4_accum(double precision[], real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4_accum(double precision[], real) is 'aggregate transition function';

alter function pg_catalog.float4_accum(double precision[], real) owner to postgres;

create function pg_catalog.float4larger(real, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4larger(real, real) is 'larger of two';

alter function pg_catalog.float4larger(real, real) owner to postgres;

create function pg_catalog.float4smaller(real, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4smaller(real, real) is 'smaller of two';

alter function pg_catalog.float4smaller(real, real) owner to postgres;

create function pg_catalog.int4um(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4um(integer) is 'implementation of - operator';

alter function pg_catalog.int4um(integer) owner to postgres;

create function pg_catalog.int2um(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2um(smallint) is 'implementation of - operator';

alter function pg_catalog.int2um(smallint) owner to postgres;

create function pg_catalog.float8in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8in(cstring) is 'I/O';

alter function pg_catalog.float8in(cstring) owner to postgres;

create function pg_catalog.float8out(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8out(double precision) is 'I/O';

alter function pg_catalog.float8out(double precision) owner to postgres;

create function pg_catalog.float8mul(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8mul(double precision, double precision) is 'implementation of * operator';

alter function pg_catalog.float8mul(double precision, double precision) owner to postgres;

create function pg_catalog.float8div(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8div(double precision, double precision) is 'implementation of / operator';

alter function pg_catalog.float8div(double precision, double precision) owner to postgres;

create function pg_catalog.float8pl(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8pl(double precision, double precision) is 'implementation of + operator';

alter function pg_catalog.float8pl(double precision, double precision) owner to postgres;

create function pg_catalog.float8mi(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8mi(double precision, double precision) is 'implementation of - operator';

alter function pg_catalog.float8mi(double precision, double precision) owner to postgres;

create function pg_catalog.float8um(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8um(double precision) is 'implementation of - operator';

alter function pg_catalog.float8um(double precision) owner to postgres;

create function pg_catalog.float8abs(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8abs(double precision) is 'implementation of @ operator';

alter function pg_catalog.float8abs(double precision) owner to postgres;

create function pg_catalog.float8_accum(double precision[], double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_accum(double precision[], double precision) is 'aggregate transition function';

alter function pg_catalog.float8_accum(double precision[], double precision) owner to postgres;

create function pg_catalog.float8larger(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8larger(double precision, double precision) is 'larger of two';

alter function pg_catalog.float8larger(double precision, double precision) owner to postgres;

create function pg_catalog.float8smaller(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8smaller(double precision, double precision) is 'smaller of two';

alter function pg_catalog.float8smaller(double precision, double precision) owner to postgres;

create function pg_catalog.lseg_center(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_center(lseg) is 'implementation of @@ operator';

alter function pg_catalog.lseg_center(lseg) owner to postgres;

create function pg_catalog.path_center(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_center(path) is 'implementation of @@ operator';

alter function pg_catalog.path_center(path) owner to postgres;

create function pg_catalog.poly_center(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_center(polygon) is 'implementation of @@ operator';

alter function pg_catalog.poly_center(polygon) owner to postgres;

create function pg_catalog.dround(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dround(double precision) is 'round to nearest integer';

alter function pg_catalog.dround(double precision) owner to postgres;

create function pg_catalog.dtrunc(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dtrunc(double precision) is 'truncate to integer';

alter function pg_catalog.dtrunc(double precision) owner to postgres;

create function pg_catalog.dsqrt(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dsqrt(double precision) is 'implementation of |/ operator';

alter function pg_catalog.dsqrt(double precision) owner to postgres;

create function pg_catalog.dcbrt(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dcbrt(double precision) is 'implementation of ||/ operator';

alter function pg_catalog.dcbrt(double precision) owner to postgres;

create function pg_catalog.dpow(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dpow(double precision, double precision) is 'implementation of ^ operator';

alter function pg_catalog.dpow(double precision, double precision) owner to postgres;

create function pg_catalog.dexp(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dexp(double precision) is 'natural exponential (e^x)';

alter function pg_catalog.dexp(double precision) owner to postgres;

create function pg_catalog.dlog1(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dlog1(double precision) is 'natural logarithm';

alter function pg_catalog.dlog1(double precision) owner to postgres;

create function pg_catalog.float8(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8(smallint) is 'convert int2 to float8';

alter function pg_catalog.float8(smallint) owner to postgres;

create function pg_catalog.float4(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4(smallint) is 'convert int2 to float4';

alter function pg_catalog.float4(smallint) owner to postgres;

create function pg_catalog.int2(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2(double precision) is 'convert float8 to int2';

alter function pg_catalog.int2(double precision) owner to postgres;

create function pg_catalog.int2(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2(real) is 'convert float4 to int2';

alter function pg_catalog.int2(real) owner to postgres;

create function pg_catalog.line_distance(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_distance(line, line) is 'implementation of <-> operator';

alter function pg_catalog.line_distance(line, line) owner to postgres;

create function pg_catalog.abstimein(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimein(cstring) is 'I/O';

alter function pg_catalog.abstimein(cstring) owner to postgres;

create function pg_catalog.abstimeout(abstime)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimeout(abstime) is 'I/O';

alter function pg_catalog.abstimeout(abstime) owner to postgres;

create function pg_catalog.reltimein(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimein(cstring) is 'I/O';

alter function pg_catalog.reltimein(cstring) owner to postgres;

create function pg_catalog.reltimeout(reltime)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimeout(reltime) is 'I/O';

alter function pg_catalog.reltimeout(reltime) owner to postgres;

create function pg_catalog.timepl(abstime, reltime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timepl(abstime, reltime) is 'implementation of + operator';

alter function pg_catalog.timepl(abstime, reltime) owner to postgres;

create function pg_catalog.timemi(abstime, reltime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timemi(abstime, reltime) is 'implementation of - operator';

alter function pg_catalog.timemi(abstime, reltime) owner to postgres;

create function pg_catalog.tintervalin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalin(cstring) is 'I/O';

alter function pg_catalog.tintervalin(cstring) owner to postgres;

create function pg_catalog.tintervalout(tinterval)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalout(tinterval) is 'I/O';

alter function pg_catalog.tintervalout(tinterval) owner to postgres;

create function pg_catalog.intinterval(abstime, tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.intinterval(abstime, tinterval) is 'implementation of <?> operator';

alter function pg_catalog.intinterval(abstime, tinterval) owner to postgres;

create function pg_catalog.tintervalrel(tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalrel(tinterval) is 'tinterval to reltime';

alter function pg_catalog.tintervalrel(tinterval) owner to postgres;

create function pg_catalog.timenow()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timenow() is 'current date and time (abstime)';

alter function pg_catalog.timenow() owner to postgres;

create function pg_catalog.abstimeeq(abstime, abstime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimeeq(abstime, abstime) is 'implementation of = operator';

alter function pg_catalog.abstimeeq(abstime, abstime) owner to postgres;

create function pg_catalog.abstimene(abstime, abstime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimene(abstime, abstime) is 'implementation of <> operator';

alter function pg_catalog.abstimene(abstime, abstime) owner to postgres;

create function pg_catalog.abstimelt(abstime, abstime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimelt(abstime, abstime) is 'implementation of < operator';

alter function pg_catalog.abstimelt(abstime, abstime) owner to postgres;

create function pg_catalog.abstimegt(abstime, abstime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimegt(abstime, abstime) is 'implementation of > operator';

alter function pg_catalog.abstimegt(abstime, abstime) owner to postgres;

create function pg_catalog.abstimele(abstime, abstime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimele(abstime, abstime) is 'implementation of <= operator';

alter function pg_catalog.abstimele(abstime, abstime) owner to postgres;

create function pg_catalog.abstimege(abstime, abstime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimege(abstime, abstime) is 'implementation of >= operator';

alter function pg_catalog.abstimege(abstime, abstime) owner to postgres;

create function pg_catalog.reltimeeq(reltime, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimeeq(reltime, reltime) is 'implementation of = operator';

alter function pg_catalog.reltimeeq(reltime, reltime) owner to postgres;

create function pg_catalog.reltimene(reltime, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimene(reltime, reltime) is 'implementation of <> operator';

alter function pg_catalog.reltimene(reltime, reltime) owner to postgres;

create function pg_catalog.reltimelt(reltime, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimelt(reltime, reltime) is 'implementation of < operator';

alter function pg_catalog.reltimelt(reltime, reltime) owner to postgres;

create function pg_catalog.reltimegt(reltime, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimegt(reltime, reltime) is 'implementation of > operator';

alter function pg_catalog.reltimegt(reltime, reltime) owner to postgres;

create function pg_catalog.reltimele(reltime, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimele(reltime, reltime) is 'implementation of <= operator';

alter function pg_catalog.reltimele(reltime, reltime) owner to postgres;

create function pg_catalog.reltimege(reltime, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimege(reltime, reltime) is 'implementation of >= operator';

alter function pg_catalog.reltimege(reltime, reltime) owner to postgres;

create function pg_catalog.tintervalsame(tinterval, tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalsame(tinterval, tinterval) is 'implementation of ~= operator';

alter function pg_catalog.tintervalsame(tinterval, tinterval) owner to postgres;

create function pg_catalog.tintervalct(tinterval, tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalct(tinterval, tinterval) is 'implementation of << operator';

alter function pg_catalog.tintervalct(tinterval, tinterval) owner to postgres;

create function pg_catalog.tintervalov(tinterval, tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalov(tinterval, tinterval) is 'implementation of && operator';

alter function pg_catalog.tintervalov(tinterval, tinterval) owner to postgres;

create function pg_catalog.tintervalleneq(tinterval, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalleneq(tinterval, reltime) is 'implementation of #= operator';

alter function pg_catalog.tintervalleneq(tinterval, reltime) owner to postgres;

create function pg_catalog.tintervallenne(tinterval, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervallenne(tinterval, reltime) is 'implementation of #<> operator';

alter function pg_catalog.tintervallenne(tinterval, reltime) owner to postgres;

create function pg_catalog.tintervallenlt(tinterval, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervallenlt(tinterval, reltime) is 'implementation of #< operator';

alter function pg_catalog.tintervallenlt(tinterval, reltime) owner to postgres;

create function pg_catalog.tintervallengt(tinterval, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervallengt(tinterval, reltime) is 'implementation of #> operator';

alter function pg_catalog.tintervallengt(tinterval, reltime) owner to postgres;

create function pg_catalog.tintervallenle(tinterval, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervallenle(tinterval, reltime) is 'implementation of #<= operator';

alter function pg_catalog.tintervallenle(tinterval, reltime) owner to postgres;

create function pg_catalog.tintervallenge(tinterval, reltime)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervallenge(tinterval, reltime) is 'implementation of #>= operator';

alter function pg_catalog.tintervallenge(tinterval, reltime) owner to postgres;

create function pg_catalog.tintervalstart(tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalstart(tinterval) is 'implementation of | operator';

alter function pg_catalog.tintervalstart(tinterval) owner to postgres;

create function pg_catalog.tintervalend(tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalend(tinterval) is 'end of interval';

alter function pg_catalog.tintervalend(tinterval) owner to postgres;

create function pg_catalog.timeofday()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timeofday() is 'current date and time - increments during transactions';

alter function pg_catalog.timeofday() owner to postgres;

create function pg_catalog.isfinite(abstime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isfinite(abstime) is 'finite abstime?';

alter function pg_catalog.isfinite(abstime) owner to postgres;

create function pg_catalog.float8_combine(double precision[], double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_combine(double precision[], double precision[]) is 'aggregate combine function';

alter function pg_catalog.float8_combine(double precision[], double precision[]) owner to postgres;

create function pg_catalog.inter_sl(lseg, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inter_sl(lseg, line) is 'implementation of ?# operator';

alter function pg_catalog.inter_sl(lseg, line) owner to postgres;

create function pg_catalog.inter_lb(line, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inter_lb(line, box) is 'implementation of ?# operator';

alter function pg_catalog.inter_lb(line, box) owner to postgres;

create function pg_catalog.float48mul(real, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48mul(real, double precision) is 'implementation of * operator';

alter function pg_catalog.float48mul(real, double precision) owner to postgres;

create function pg_catalog.float48div(real, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48div(real, double precision) is 'implementation of / operator';

alter function pg_catalog.float48div(real, double precision) owner to postgres;

create function pg_catalog.float48pl(real, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48pl(real, double precision) is 'implementation of + operator';

alter function pg_catalog.float48pl(real, double precision) owner to postgres;

create function pg_catalog.float48mi(real, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48mi(real, double precision) is 'implementation of - operator';

alter function pg_catalog.float48mi(real, double precision) owner to postgres;

create function pg_catalog.float84mul(double precision, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84mul(double precision, real) is 'implementation of * operator';

alter function pg_catalog.float84mul(double precision, real) owner to postgres;

create function pg_catalog.float84div(double precision, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84div(double precision, real) is 'implementation of / operator';

alter function pg_catalog.float84div(double precision, real) owner to postgres;

create function pg_catalog.float84pl(double precision, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84pl(double precision, real) is 'implementation of + operator';

alter function pg_catalog.float84pl(double precision, real) owner to postgres;

create function pg_catalog.float84mi(double precision, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84mi(double precision, real) is 'implementation of - operator';

alter function pg_catalog.float84mi(double precision, real) owner to postgres;

create function pg_catalog.float4eq(real, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4eq(real, real) is 'implementation of = operator';

alter function pg_catalog.float4eq(real, real) owner to postgres;

create function pg_catalog.float4ne(real, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4ne(real, real) is 'implementation of <> operator';

alter function pg_catalog.float4ne(real, real) owner to postgres;

create function pg_catalog.float4lt(real, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4lt(real, real) is 'implementation of < operator';

alter function pg_catalog.float4lt(real, real) owner to postgres;

create function pg_catalog.float4le(real, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4le(real, real) is 'implementation of <= operator';

alter function pg_catalog.float4le(real, real) owner to postgres;

create function pg_catalog.float4gt(real, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4gt(real, real) is 'implementation of > operator';

alter function pg_catalog.float4gt(real, real) owner to postgres;

create function pg_catalog.float4ge(real, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4ge(real, real) is 'implementation of >= operator';

alter function pg_catalog.float4ge(real, real) owner to postgres;

create function pg_catalog.float8eq(double precision, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8eq(double precision, double precision) is 'implementation of = operator';

alter function pg_catalog.float8eq(double precision, double precision) owner to postgres;

create function pg_catalog.float8ne(double precision, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8ne(double precision, double precision) is 'implementation of <> operator';

alter function pg_catalog.float8ne(double precision, double precision) owner to postgres;

create function pg_catalog.float8lt(double precision, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8lt(double precision, double precision) is 'implementation of < operator';

alter function pg_catalog.float8lt(double precision, double precision) owner to postgres;

create function pg_catalog.float8le(double precision, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8le(double precision, double precision) is 'implementation of <= operator';

alter function pg_catalog.float8le(double precision, double precision) owner to postgres;

create function pg_catalog.float8gt(double precision, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8gt(double precision, double precision) is 'implementation of > operator';

alter function pg_catalog.float8gt(double precision, double precision) owner to postgres;

create function pg_catalog.float8ge(double precision, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8ge(double precision, double precision) is 'implementation of >= operator';

alter function pg_catalog.float8ge(double precision, double precision) owner to postgres;

create function pg_catalog.float48eq(real, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48eq(real, double precision) is 'implementation of = operator';

alter function pg_catalog.float48eq(real, double precision) owner to postgres;

create function pg_catalog.float48ne(real, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48ne(real, double precision) is 'implementation of <> operator';

alter function pg_catalog.float48ne(real, double precision) owner to postgres;

create function pg_catalog.float48lt(real, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48lt(real, double precision) is 'implementation of < operator';

alter function pg_catalog.float48lt(real, double precision) owner to postgres;

create function pg_catalog.float48le(real, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48le(real, double precision) is 'implementation of <= operator';

alter function pg_catalog.float48le(real, double precision) owner to postgres;

create function pg_catalog.float48gt(real, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48gt(real, double precision) is 'implementation of > operator';

alter function pg_catalog.float48gt(real, double precision) owner to postgres;

create function pg_catalog.float48ge(real, double precision)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float48ge(real, double precision) is 'implementation of >= operator';

alter function pg_catalog.float48ge(real, double precision) owner to postgres;

create function pg_catalog.float84eq(double precision, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84eq(double precision, real) is 'implementation of = operator';

alter function pg_catalog.float84eq(double precision, real) owner to postgres;

create function pg_catalog.float84ne(double precision, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84ne(double precision, real) is 'implementation of <> operator';

alter function pg_catalog.float84ne(double precision, real) owner to postgres;

create function pg_catalog.float84lt(double precision, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84lt(double precision, real) is 'implementation of < operator';

alter function pg_catalog.float84lt(double precision, real) owner to postgres;

create function pg_catalog.float84le(double precision, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84le(double precision, real) is 'implementation of <= operator';

alter function pg_catalog.float84le(double precision, real) owner to postgres;

create function pg_catalog.float84gt(double precision, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84gt(double precision, real) is 'implementation of > operator';

alter function pg_catalog.float84gt(double precision, real) owner to postgres;

create function pg_catalog.float84ge(double precision, real)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float84ge(double precision, real) is 'implementation of >= operator';

alter function pg_catalog.float84ge(double precision, real) owner to postgres;

create function pg_catalog.float8(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8(real) is 'convert float4 to float8';

alter function pg_catalog.float8(real) owner to postgres;

create function pg_catalog.float4(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4(double precision) is 'convert float8 to float4';

alter function pg_catalog.float4(double precision) owner to postgres;

create function pg_catalog.int4(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4(smallint) is 'convert int2 to int4';

alter function pg_catalog.int4(smallint) owner to postgres;

create function pg_catalog.int2(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2(integer) is 'convert int4 to int2';

alter function pg_catalog.int2(integer) owner to postgres;

create function pg_catalog.int2vectoreq(int2vector, int2vector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2vectoreq(int2vector, int2vector) is 'implementation of = operator';

alter function pg_catalog.int2vectoreq(int2vector, int2vector) owner to postgres;

create function pg_catalog.float8(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8(integer) is 'convert int4 to float8';

alter function pg_catalog.float8(integer) owner to postgres;

create function pg_catalog.int4(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4(double precision) is 'convert float8 to int4';

alter function pg_catalog.int4(double precision) owner to postgres;

create function pg_catalog.float4(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4(integer) is 'convert int4 to float4';

alter function pg_catalog.float4(integer) owner to postgres;

create function pg_catalog.int4(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4(real) is 'convert float4 to int4';

alter function pg_catalog.int4(real) owner to postgres;

create function pg_catalog.width_bucket(double precision, double precision, double precision, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.width_bucket(double precision, double precision, double precision, integer) is 'bucket number of operand in equal-width histogram';

alter function pg_catalog.width_bucket(double precision, double precision, double precision, integer) owner to postgres;

create function pg_catalog.json_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_in(cstring) is 'I/O';

alter function pg_catalog.json_in(cstring) owner to postgres;

create function pg_catalog.json_out(json)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_out(json) is 'I/O';

alter function pg_catalog.json_out(json) owner to postgres;

create function pg_catalog.json_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_recv(internal) is 'I/O';

alter function pg_catalog.json_recv(internal) owner to postgres;

create function pg_catalog.json_send(json)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_send(json) is 'I/O';

alter function pg_catalog.json_send(json) owner to postgres;

create function pg_catalog.index_am_handler_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.index_am_handler_in(cstring) is 'I/O';

alter function pg_catalog.index_am_handler_in(cstring) owner to postgres;

create function pg_catalog.index_am_handler_out(index_am_handler)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.index_am_handler_out(index_am_handler) is 'I/O';

alter function pg_catalog.index_am_handler_out(index_am_handler) owner to postgres;

create function pg_catalog.hash_aclitem(aclitem)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hash_aclitem(aclitem) is 'hash';

alter function pg_catalog.hash_aclitem(aclitem) owner to postgres;

create function pg_catalog.bthandler(internal)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bthandler(internal) is 'btree index access method handler';

alter function pg_catalog.bthandler(internal) owner to postgres;

create function pg_catalog.hashhandler(internal)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashhandler(internal) is 'hash index access method handler';

alter function pg_catalog.hashhandler(internal) owner to postgres;

create function pg_catalog.gisthandler(internal)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gisthandler(internal) is 'gist index access method handler';

alter function pg_catalog.gisthandler(internal) owner to postgres;

create function pg_catalog.ginhandler(internal)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ginhandler(internal) is 'gin index access method handler';

alter function pg_catalog.ginhandler(internal) owner to postgres;

create function pg_catalog.spghandler(internal)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spghandler(internal) is 'spgist index access method handler';

alter function pg_catalog.spghandler(internal) owner to postgres;

create function pg_catalog.brinhandler(internal)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brinhandler(internal) is 'brin index access method handler';

alter function pg_catalog.brinhandler(internal) owner to postgres;

create function pg_catalog.amvalidate(oid)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.amvalidate(oid) is 'validate an operator class';

alter function pg_catalog.amvalidate(oid) owner to postgres;

create function pg_catalog.poly_same(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_same(polygon, polygon) is 'implementation of ~= operator';

alter function pg_catalog.poly_same(polygon, polygon) owner to postgres;

create function pg_catalog.poly_contain(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_contain(polygon, polygon) is 'implementation of @> operator';

alter function pg_catalog.poly_contain(polygon, polygon) owner to postgres;

create function pg_catalog.poly_left(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_left(polygon, polygon) is 'implementation of << operator';

alter function pg_catalog.poly_left(polygon, polygon) owner to postgres;

create function pg_catalog.poly_overleft(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_overleft(polygon, polygon) is 'implementation of &< operator';

alter function pg_catalog.poly_overleft(polygon, polygon) owner to postgres;

create function pg_catalog.poly_overright(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_overright(polygon, polygon) is 'implementation of &> operator';

alter function pg_catalog.poly_overright(polygon, polygon) owner to postgres;

create function pg_catalog.poly_right(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_right(polygon, polygon) is 'implementation of >> operator';

alter function pg_catalog.poly_right(polygon, polygon) owner to postgres;

create function pg_catalog.poly_contained(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_contained(polygon, polygon) is 'implementation of <@ operator';

alter function pg_catalog.poly_contained(polygon, polygon) owner to postgres;

create function pg_catalog.poly_overlap(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_overlap(polygon, polygon) is 'implementation of && operator';

alter function pg_catalog.poly_overlap(polygon, polygon) owner to postgres;

create function pg_catalog.poly_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_in(cstring) is 'I/O';

alter function pg_catalog.poly_in(cstring) owner to postgres;

create function pg_catalog.poly_out(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_out(polygon) is 'I/O';

alter function pg_catalog.poly_out(polygon) owner to postgres;

create function pg_catalog.btint2cmp(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint2cmp(smallint, smallint) is 'less-equal-greater';

alter function pg_catalog.btint2cmp(smallint, smallint) owner to postgres;

create function pg_catalog.btint4cmp(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint4cmp(integer, integer) is 'less-equal-greater';

alter function pg_catalog.btint4cmp(integer, integer) owner to postgres;

create function pg_catalog.btfloat4cmp(real, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btfloat4cmp(real, real) is 'less-equal-greater';

alter function pg_catalog.btfloat4cmp(real, real) owner to postgres;

create function pg_catalog.btfloat8cmp(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btfloat8cmp(double precision, double precision) is 'less-equal-greater';

alter function pg_catalog.btfloat8cmp(double precision, double precision) owner to postgres;

create function pg_catalog.btoidcmp(oid, oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btoidcmp(oid, oid) is 'less-equal-greater';

alter function pg_catalog.btoidcmp(oid, oid) owner to postgres;

create function pg_catalog.btabstimecmp(abstime, abstime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btabstimecmp(abstime, abstime) is 'less-equal-greater';

alter function pg_catalog.btabstimecmp(abstime, abstime) owner to postgres;

create function pg_catalog.btcharcmp("char", "char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btcharcmp("char", "char") is 'less-equal-greater';

alter function pg_catalog.btcharcmp("char", "char") owner to postgres;

create function pg_catalog.btnamecmp(name, name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btnamecmp(name, name) is 'less-equal-greater';

alter function pg_catalog.btnamecmp(name, name) owner to postgres;

create function pg_catalog.bttextcmp(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bttextcmp(text, text) is 'less-equal-greater';

alter function pg_catalog.bttextcmp(text, text) owner to postgres;

create function pg_catalog.lseg_distance(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_distance(lseg, lseg) is 'implementation of <-> operator';

alter function pg_catalog.lseg_distance(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_interpt(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_interpt(lseg, lseg) is 'implementation of # operator';

alter function pg_catalog.lseg_interpt(lseg, lseg) owner to postgres;

create function pg_catalog.dist_ps(point, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_ps(point, lseg) is 'implementation of <-> operator';

alter function pg_catalog.dist_ps(point, lseg) owner to postgres;

create function pg_catalog.dist_pb(point, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_pb(point, box) is 'implementation of <-> operator';

alter function pg_catalog.dist_pb(point, box) owner to postgres;

create function pg_catalog.dist_sb(lseg, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_sb(lseg, box) is 'implementation of <-> operator';

alter function pg_catalog.dist_sb(lseg, box) owner to postgres;

create function pg_catalog.close_ps(point, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.close_ps(point, lseg) is 'implementation of ## operator';

alter function pg_catalog.close_ps(point, lseg) owner to postgres;

create function pg_catalog.close_pb(point, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.close_pb(point, box) is 'implementation of ## operator';

alter function pg_catalog.close_pb(point, box) owner to postgres;

create function pg_catalog.close_sb(lseg, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.close_sb(lseg, box) is 'implementation of ## operator';

alter function pg_catalog.close_sb(lseg, box) owner to postgres;

create function pg_catalog.on_ps(point, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.on_ps(point, lseg) is 'implementation of <@ operator';

alter function pg_catalog.on_ps(point, lseg) owner to postgres;

create function pg_catalog.path_distance(path, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_distance(path, path) is 'implementation of <-> operator';

alter function pg_catalog.path_distance(path, path) owner to postgres;

create function pg_catalog.dist_ppath(point, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_ppath(point, path) is 'implementation of <-> operator';

alter function pg_catalog.dist_ppath(point, path) owner to postgres;

create function pg_catalog.on_sb(lseg, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.on_sb(lseg, box) is 'implementation of <@ operator';

alter function pg_catalog.on_sb(lseg, box) owner to postgres;

create function pg_catalog.inter_sb(lseg, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inter_sb(lseg, box) is 'implementation of ?# operator';

alter function pg_catalog.inter_sb(lseg, box) owner to postgres;

create function pg_catalog.string_to_array(text, text, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.string_to_array(text, text, text) is 'split delimited text into text[], with null string';

alter function pg_catalog.string_to_array(text, text, text) owner to postgres;

create function pg_catalog.cash_cmp(money, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_cmp(money, money) is 'less-equal-greater';

alter function pg_catalog.cash_cmp(money, money) owner to postgres;

create function pg_catalog.array_append(anyarray, anyelement)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_append(anyarray, anyelement) is 'append element onto end of array';

alter function pg_catalog.array_append(anyarray, anyelement) owner to postgres;

create function pg_catalog.array_prepend(anyelement, anyarray)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_prepend(anyelement, anyarray) is 'prepend element onto front of array';

alter function pg_catalog.array_prepend(anyelement, anyarray) owner to postgres;

create function pg_catalog.btreltimecmp(reltime, reltime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btreltimecmp(reltime, reltime) is 'less-equal-greater';

alter function pg_catalog.btreltimecmp(reltime, reltime) owner to postgres;

create function pg_catalog.bttintervalcmp(tinterval, tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bttintervalcmp(tinterval, tinterval) is 'less-equal-greater';

alter function pg_catalog.bttintervalcmp(tinterval, tinterval) owner to postgres;

create function pg_catalog.btarraycmp(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btarraycmp(anyarray, anyarray) is 'less-equal-greater';

alter function pg_catalog.btarraycmp(anyarray, anyarray) owner to postgres;

create function pg_catalog.array_cat(anyarray, anyarray)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_cat(anyarray, anyarray) is 'implementation of || operator';

alter function pg_catalog.array_cat(anyarray, anyarray) owner to postgres;

create function pg_catalog.array_to_string(anyarray, text, text)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_to_string(anyarray, text, text) is 'concatenate array elements, using delimiter and null string, into text';

alter function pg_catalog.array_to_string(anyarray, text, text) owner to postgres;

create function pg_catalog.array_ne(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_ne(anyarray, anyarray) is 'implementation of <> operator';

alter function pg_catalog.array_ne(anyarray, anyarray) owner to postgres;

create function pg_catalog.array_lt(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_lt(anyarray, anyarray) is 'implementation of < operator';

alter function pg_catalog.array_lt(anyarray, anyarray) owner to postgres;

create function pg_catalog.array_gt(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_gt(anyarray, anyarray) is 'implementation of > operator';

alter function pg_catalog.array_gt(anyarray, anyarray) owner to postgres;

create function pg_catalog.array_le(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_le(anyarray, anyarray) is 'implementation of <= operator';

alter function pg_catalog.array_le(anyarray, anyarray) owner to postgres;

create function pg_catalog.string_to_array(text, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.string_to_array(text, text) is 'split delimited text into text[]';

alter function pg_catalog.string_to_array(text, text) owner to postgres;

create function pg_catalog.array_to_string(anyarray, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_to_string(anyarray, text) is 'concatenate array elements, using delimiter, into text';

alter function pg_catalog.array_to_string(anyarray, text) owner to postgres;

create function pg_catalog.array_ge(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_ge(anyarray, anyarray) is 'implementation of >= operator';

alter function pg_catalog.array_ge(anyarray, anyarray) owner to postgres;

create function pg_catalog.hashint2vector(int2vector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashint2vector(int2vector) is 'hash';

alter function pg_catalog.hashint2vector(int2vector) owner to postgres;

create function pg_catalog.hashmacaddr(macaddr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashmacaddr(macaddr) is 'hash';

alter function pg_catalog.hashmacaddr(macaddr) owner to postgres;

create function pg_catalog.hashtext(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashtext(text) is 'hash';

alter function pg_catalog.hashtext(text) owner to postgres;

create function pg_catalog.text(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text(char) is 'convert char(n) to text';

alter function pg_catalog.text(char) owner to postgres;

create function pg_catalog.btoidvectorcmp(oidvector, oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btoidvectorcmp(oidvector, oidvector) is 'less-equal-greater';

alter function pg_catalog.btoidvectorcmp(oidvector, oidvector) owner to postgres;

create function pg_catalog.text(name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text(name) is 'convert name to text';

alter function pg_catalog.text(name) owner to postgres;

create function pg_catalog.name(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.name(text) is 'convert text to name';

alter function pg_catalog.name(text) owner to postgres;

create function pg_catalog.bpchar(name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar(name) is 'convert name to char(n)';

alter function pg_catalog.bpchar(name) owner to postgres;

create function pg_catalog.name(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.name(char) is 'convert char(n) to name';

alter function pg_catalog.name(char) owner to postgres;

create function pg_catalog.hashinet(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashinet(inet) is 'hash';

alter function pg_catalog.hashinet(inet) owner to postgres;

create function pg_catalog.hash_numeric(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hash_numeric(numeric) is 'hash';

alter function pg_catalog.hash_numeric(numeric) owner to postgres;

create function pg_catalog.macaddr_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_in(cstring) is 'I/O';

alter function pg_catalog.macaddr_in(cstring) owner to postgres;

create function pg_catalog.macaddr_out(macaddr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_out(macaddr) is 'I/O';

alter function pg_catalog.macaddr_out(macaddr) owner to postgres;

create function pg_catalog.num_nulls("any")
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.num_nulls("any") is 'count the number of NULL arguments';

alter function pg_catalog.num_nulls("any") owner to postgres;

create function pg_catalog.num_nonnulls("any")
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.num_nonnulls("any") is 'count the number of non-NULL arguments';

alter function pg_catalog.num_nonnulls("any") owner to postgres;

create function pg_catalog.hashint2(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashint2(smallint) is 'hash';

alter function pg_catalog.hashint2(smallint) owner to postgres;

create function pg_catalog.hashint4(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashint4(integer) is 'hash';

alter function pg_catalog.hashint4(integer) owner to postgres;

create function pg_catalog.hashfloat4(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashfloat4(real) is 'hash';

alter function pg_catalog.hashfloat4(real) owner to postgres;

create function pg_catalog.hashfloat8(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashfloat8(double precision) is 'hash';

alter function pg_catalog.hashfloat8(double precision) owner to postgres;

create function pg_catalog.hashoid(oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashoid(oid) is 'hash';

alter function pg_catalog.hashoid(oid) owner to postgres;

create function pg_catalog.hashchar("char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashchar("char") is 'hash';

alter function pg_catalog.hashchar("char") owner to postgres;

create function pg_catalog.hashname(name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashname(name) is 'hash';

alter function pg_catalog.hashname(name) owner to postgres;

create function pg_catalog.hashvarlena(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashvarlena(internal) is 'hash';

alter function pg_catalog.hashvarlena(internal) owner to postgres;

create function pg_catalog.hashoidvector(oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashoidvector(oidvector) is 'hash';

alter function pg_catalog.hashoidvector(oidvector) owner to postgres;

create function pg_catalog.text_larger(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_larger(text, text) is 'larger of two';

alter function pg_catalog.text_larger(text, text) owner to postgres;

create function pg_catalog.text_smaller(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_smaller(text, text) is 'smaller of two';

alter function pg_catalog.text_smaller(text, text) owner to postgres;

create function pg_catalog.int8in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8in(cstring) is 'I/O';

alter function pg_catalog.int8in(cstring) owner to postgres;

create function pg_catalog.int8out(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8out(bigint) is 'I/O';

alter function pg_catalog.int8out(bigint) owner to postgres;

create function pg_catalog.int8um(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8um(bigint) is 'implementation of - operator';

alter function pg_catalog.int8um(bigint) owner to postgres;

create function pg_catalog.int8pl(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8pl(bigint, bigint) is 'implementation of + operator';

alter function pg_catalog.int8pl(bigint, bigint) owner to postgres;

create function pg_catalog.int8mi(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8mi(bigint, bigint) is 'implementation of - operator';

alter function pg_catalog.int8mi(bigint, bigint) owner to postgres;

create function pg_catalog.int8mul(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8mul(bigint, bigint) is 'implementation of * operator';

alter function pg_catalog.int8mul(bigint, bigint) owner to postgres;

create function pg_catalog.int8div(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8div(bigint, bigint) is 'implementation of / operator';

alter function pg_catalog.int8div(bigint, bigint) owner to postgres;

create function pg_catalog.int8eq(bigint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8eq(bigint, bigint) is 'implementation of = operator';

alter function pg_catalog.int8eq(bigint, bigint) owner to postgres;

create function pg_catalog.int8ne(bigint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8ne(bigint, bigint) is 'implementation of <> operator';

alter function pg_catalog.int8ne(bigint, bigint) owner to postgres;

create function pg_catalog.int8lt(bigint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8lt(bigint, bigint) is 'implementation of < operator';

alter function pg_catalog.int8lt(bigint, bigint) owner to postgres;

create function pg_catalog.int8gt(bigint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8gt(bigint, bigint) is 'implementation of > operator';

alter function pg_catalog.int8gt(bigint, bigint) owner to postgres;

create function pg_catalog.int8le(bigint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8le(bigint, bigint) is 'implementation of <= operator';

alter function pg_catalog.int8le(bigint, bigint) owner to postgres;

create function pg_catalog.int8ge(bigint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8ge(bigint, bigint) is 'implementation of >= operator';

alter function pg_catalog.int8ge(bigint, bigint) owner to postgres;

create function pg_catalog.int84eq(bigint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84eq(bigint, integer) is 'implementation of = operator';

alter function pg_catalog.int84eq(bigint, integer) owner to postgres;

create function pg_catalog.int84ne(bigint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84ne(bigint, integer) is 'implementation of <> operator';

alter function pg_catalog.int84ne(bigint, integer) owner to postgres;

create function pg_catalog.int84lt(bigint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84lt(bigint, integer) is 'implementation of < operator';

alter function pg_catalog.int84lt(bigint, integer) owner to postgres;

create function pg_catalog.int84gt(bigint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84gt(bigint, integer) is 'implementation of > operator';

alter function pg_catalog.int84gt(bigint, integer) owner to postgres;

create function pg_catalog.int84le(bigint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84le(bigint, integer) is 'implementation of <= operator';

alter function pg_catalog.int84le(bigint, integer) owner to postgres;

create function pg_catalog.int84ge(bigint, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84ge(bigint, integer) is 'implementation of >= operator';

alter function pg_catalog.int84ge(bigint, integer) owner to postgres;

create function pg_catalog.int4(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4(bigint) is 'convert int8 to int4';

alter function pg_catalog.int4(bigint) owner to postgres;

create function pg_catalog.int8(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8(integer) is 'convert int4 to int8';

alter function pg_catalog.int8(integer) owner to postgres;

create function pg_catalog.float8(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8(bigint) is 'convert int8 to float8';

alter function pg_catalog.float8(bigint) owner to postgres;

create function pg_catalog.int8(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8(double precision) is 'convert float8 to int8';

alter function pg_catalog.int8(double precision) owner to postgres;

create function pg_catalog.array_larger(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_larger(anyarray, anyarray) is 'larger of two';

alter function pg_catalog.array_larger(anyarray, anyarray) owner to postgres;

create function pg_catalog.array_smaller(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_smaller(anyarray, anyarray) is 'smaller of two';

alter function pg_catalog.array_smaller(anyarray, anyarray) owner to postgres;

create function pg_catalog.abbrev(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abbrev(inet) is 'abbreviated display of inet value';

alter function pg_catalog.abbrev(inet) owner to postgres;

create function pg_catalog.abbrev(cidr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abbrev(cidr) is 'abbreviated display of cidr value';

alter function pg_catalog.abbrev(cidr) owner to postgres;

create function pg_catalog.set_masklen(inet, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.set_masklen(inet, integer) is 'change netmask of inet';

alter function pg_catalog.set_masklen(inet, integer) owner to postgres;

create function pg_catalog.oidvectorne(oidvector, oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorne(oidvector, oidvector) is 'implementation of <> operator';

alter function pg_catalog.oidvectorne(oidvector, oidvector) owner to postgres;

create function pg_catalog.hash_array(anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hash_array(anyarray) is 'hash';

alter function pg_catalog.hash_array(anyarray) owner to postgres;

create function pg_catalog.set_masklen(cidr, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.set_masklen(cidr, integer) is 'change netmask of cidr';

alter function pg_catalog.set_masklen(cidr, integer) owner to postgres;

create function pg_catalog.pg_indexam_has_property(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_indexam_has_property(oid, text) is 'test property of an index access method';

alter function pg_catalog.pg_indexam_has_property(oid, text) owner to postgres;

create function pg_catalog.pg_index_has_property(regclass, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_index_has_property(regclass, text) is 'test property of an index';

alter function pg_catalog.pg_index_has_property(regclass, text) owner to postgres;

create function pg_catalog.pg_index_column_has_property(regclass, integer, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_index_column_has_property(regclass, integer, text) is 'test property of an index column';

alter function pg_catalog.pg_index_column_has_property(regclass, integer, text) owner to postgres;

create function pg_catalog.float4(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4(bigint) is 'convert int8 to float4';

alter function pg_catalog.float4(bigint) owner to postgres;

create function pg_catalog.int8(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8(real) is 'convert float4 to int8';

alter function pg_catalog.int8(real) owner to postgres;

create function pg_catalog.namelt(name, name)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namelt(name, name) is 'implementation of < operator';

alter function pg_catalog.namelt(name, name) owner to postgres;

create function pg_catalog.namele(name, name)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namele(name, name) is 'implementation of <= operator';

alter function pg_catalog.namele(name, name) owner to postgres;

create function pg_catalog.namegt(name, name)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namegt(name, name) is 'implementation of > operator';

alter function pg_catalog.namegt(name, name) owner to postgres;

create function pg_catalog.namege(name, name)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namege(name, name) is 'implementation of >= operator';

alter function pg_catalog.namege(name, name) owner to postgres;

create function pg_catalog.namene(name, name)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namene(name, name) is 'implementation of <> operator';

alter function pg_catalog.namene(name, name) owner to postgres;

create function pg_catalog.bpchar(char, integer, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar(char, integer, boolean) is 'adjust char() to typmod length';

alter function pg_catalog.bpchar(char, integer, boolean) owner to postgres;

create function pg_catalog.varchar(varchar, integer, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varchar(varchar, integer, boolean) is 'adjust varchar() to typmod length';

alter function pg_catalog.varchar(varchar, integer, boolean) owner to postgres;

create function pg_catalog.mktinterval(abstime, abstime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.mktinterval(abstime, abstime) is 'implementation of <#> operator';

alter function pg_catalog.mktinterval(abstime, abstime) owner to postgres;

create function pg_catalog.oidvectorlt(oidvector, oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorlt(oidvector, oidvector) is 'implementation of < operator';

alter function pg_catalog.oidvectorlt(oidvector, oidvector) owner to postgres;

create function pg_catalog.oidvectorle(oidvector, oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorle(oidvector, oidvector) is 'implementation of <= operator';

alter function pg_catalog.oidvectorle(oidvector, oidvector) owner to postgres;

create function pg_catalog.oidvectoreq(oidvector, oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectoreq(oidvector, oidvector) is 'implementation of = operator';

alter function pg_catalog.oidvectoreq(oidvector, oidvector) owner to postgres;

create function pg_catalog.oidvectorge(oidvector, oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorge(oidvector, oidvector) is 'implementation of >= operator';

alter function pg_catalog.oidvectorge(oidvector, oidvector) owner to postgres;

create function pg_catalog.oidvectorgt(oidvector, oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorgt(oidvector, oidvector) is 'implementation of > operator';

alter function pg_catalog.oidvectorgt(oidvector, oidvector) owner to postgres;

create function pg_catalog.network(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network(inet) is 'network part of address';

alter function pg_catalog.network(inet) owner to postgres;

create function pg_catalog.netmask(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.netmask(inet) is 'netmask of address';

alter function pg_catalog.netmask(inet) owner to postgres;

create function pg_catalog.masklen(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.masklen(inet) is 'netmask length';

alter function pg_catalog.masklen(inet) owner to postgres;

create function pg_catalog.broadcast(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.broadcast(inet) is 'broadcast address of network';

alter function pg_catalog.broadcast(inet) owner to postgres;

create function pg_catalog.host(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.host(inet) is 'show address octets only';

alter function pg_catalog.host(inet) owner to postgres;

create function pg_catalog.getpgusername()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.getpgusername() is 'deprecated, use current_user instead';

alter function pg_catalog.getpgusername() owner to postgres;

create function pg_catalog.family(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.family(inet) is 'address family (4 for IPv4, 6 for IPv6)';

alter function pg_catalog.family(inet) owner to postgres;

create function pg_catalog.int2(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2(bigint) is 'convert int8 to int2';

alter function pg_catalog.int2(bigint) owner to postgres;

create function pg_catalog.lo_create(oid)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_create(oid) is 'large object create';

alter function pg_catalog.lo_create(oid) owner to postgres;

create function pg_catalog.oidlt(oid, oid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidlt(oid, oid) is 'implementation of < operator';

alter function pg_catalog.oidlt(oid, oid) owner to postgres;

create function pg_catalog.oidle(oid, oid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidle(oid, oid) is 'implementation of <= operator';

alter function pg_catalog.oidle(oid, oid) owner to postgres;

create function pg_catalog.octet_length(bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.octet_length(bytea) is 'octet length';

alter function pg_catalog.octet_length(bytea) owner to postgres;

create function pg_catalog.get_byte(bytea, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.get_byte(bytea, integer) is 'get byte';

alter function pg_catalog.get_byte(bytea, integer) owner to postgres;

create function pg_catalog.set_byte(bytea, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.set_byte(bytea, integer, integer) is 'set byte';

alter function pg_catalog.set_byte(bytea, integer, integer) owner to postgres;

create function pg_catalog.get_bit(bytea, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.get_bit(bytea, integer) is 'get bit';

alter function pg_catalog.get_bit(bytea, integer) owner to postgres;

create function pg_catalog.set_bit(bytea, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.set_bit(bytea, integer, integer) is 'set bit';

alter function pg_catalog.set_bit(bytea, integer, integer) owner to postgres;

create function pg_catalog.dist_pl(point, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_pl(point, line) is 'implementation of <-> operator';

alter function pg_catalog.dist_pl(point, line) owner to postgres;

create function pg_catalog.dist_lb(line, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_lb(line, box) is 'implementation of <-> operator';

alter function pg_catalog.dist_lb(line, box) owner to postgres;

create function pg_catalog.dist_sl(lseg, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_sl(lseg, line) is 'implementation of <-> operator';

alter function pg_catalog.dist_sl(lseg, line) owner to postgres;

create function pg_catalog.dist_cpoly(circle, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_cpoly(circle, polygon) is 'implementation of <-> operator';

alter function pg_catalog.dist_cpoly(circle, polygon) owner to postgres;

create function pg_catalog.poly_distance(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_distance(polygon, polygon) is 'implementation of <-> operator';

alter function pg_catalog.poly_distance(polygon, polygon) owner to postgres;

create function pg_catalog.text(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text(inet) is 'show all parts of inet/cidr value';

alter function pg_catalog.text(inet) owner to postgres;

create function pg_catalog.text_lt(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_lt(text, text) is 'implementation of < operator';

alter function pg_catalog.text_lt(text, text) owner to postgres;

create function pg_catalog.text_le(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_le(text, text) is 'implementation of <= operator';

alter function pg_catalog.text_le(text, text) owner to postgres;

create function pg_catalog.text_gt(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_gt(text, text) is 'implementation of > operator';

alter function pg_catalog.text_gt(text, text) owner to postgres;

create function pg_catalog.text_ge(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_ge(text, text) is 'implementation of >= operator';

alter function pg_catalog.text_ge(text, text) owner to postgres;

create function pg_catalog.array_eq(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_eq(anyarray, anyarray) is 'implementation of = operator';

alter function pg_catalog.array_eq(anyarray, anyarray) owner to postgres;

create function pg_catalog."current_user"()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."current_user"() is 'current user name';

alter function pg_catalog."current_user"() owner to postgres;

create function pg_catalog."session_user"()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."session_user"() is 'session user name';

alter function pg_catalog."session_user"() owner to postgres;

create function pg_catalog.array_dims(anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_dims(anyarray) is 'array dimensions';

alter function pg_catalog.array_dims(anyarray) owner to postgres;

create function pg_catalog.array_ndims(anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_ndims(anyarray) is 'number of array dimensions';

alter function pg_catalog.array_ndims(anyarray) owner to postgres;

create function pg_catalog.overlay(bytea, bytea, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.overlay(bytea, bytea, integer, integer) is 'substitute portion of string';

alter function pg_catalog.overlay(bytea, bytea, integer, integer) owner to postgres;

create function pg_catalog.array_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.array_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.array_out(anyarray)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_out(anyarray) is 'I/O';

alter function pg_catalog.array_out(anyarray) owner to postgres;

create function pg_catalog.overlay(bytea, bytea, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.overlay(bytea, bytea, integer) is 'substitute portion of string';

alter function pg_catalog.overlay(bytea, bytea, integer) owner to postgres;

create function pg_catalog.trunc(macaddr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.trunc(macaddr) is 'MAC manufacturer fields';

alter function pg_catalog.trunc(macaddr) owner to postgres;

create function pg_catalog.int8(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8(smallint) is 'convert int2 to int8';

alter function pg_catalog.int8(smallint) owner to postgres;

create function pg_catalog.smgrin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.smgrin(cstring) is 'I/O';

alter function pg_catalog.smgrin(cstring) owner to postgres;

create function pg_catalog.smgrout(smgr)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.smgrout(smgr) is 'I/O';

alter function pg_catalog.smgrout(smgr) owner to postgres;

create function pg_catalog.smgreq(smgr, smgr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.smgreq(smgr, smgr) is 'storage manager';

alter function pg_catalog.smgreq(smgr, smgr) owner to postgres;

create function pg_catalog.smgrne(smgr, smgr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.smgrne(smgr, smgr) is 'storage manager';

alter function pg_catalog.smgrne(smgr, smgr) owner to postgres;

create function pg_catalog.lo_import(text)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_import(text) is 'large object import';

alter function pg_catalog.lo_import(text) owner to postgres;

create function pg_catalog.lo_export(oid, text)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_export(oid, text) is 'large object export';

alter function pg_catalog.lo_export(oid, text) owner to postgres;

create function pg_catalog.int4inc(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4inc(integer) is 'increment';

alter function pg_catalog.int4inc(integer) owner to postgres;

create function pg_catalog.lo_import(text, oid)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_import(text, oid) is 'large object import';

alter function pg_catalog.lo_import(text, oid) owner to postgres;

create function pg_catalog.int4larger(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4larger(integer, integer) is 'larger of two';

alter function pg_catalog.int4larger(integer, integer) owner to postgres;

create function pg_catalog.int4smaller(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4smaller(integer, integer) is 'smaller of two';

alter function pg_catalog.int4smaller(integer, integer) owner to postgres;

create function pg_catalog.int2larger(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2larger(smallint, smallint) is 'larger of two';

alter function pg_catalog.int2larger(smallint, smallint) owner to postgres;

create function pg_catalog.int2smaller(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2smaller(smallint, smallint) is 'smaller of two';

alter function pg_catalog.int2smaller(smallint, smallint) owner to postgres;

create function pg_catalog.tintervaleq(tinterval, tinterval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervaleq(tinterval, tinterval) is 'implementation of = operator';

alter function pg_catalog.tintervaleq(tinterval, tinterval) owner to postgres;

create function pg_catalog.tintervalne(tinterval, tinterval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalne(tinterval, tinterval) is 'implementation of <> operator';

alter function pg_catalog.tintervalne(tinterval, tinterval) owner to postgres;

create function pg_catalog.tintervallt(tinterval, tinterval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervallt(tinterval, tinterval) is 'implementation of < operator';

alter function pg_catalog.tintervallt(tinterval, tinterval) owner to postgres;

create function pg_catalog.tintervalgt(tinterval, tinterval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalgt(tinterval, tinterval) is 'implementation of > operator';

alter function pg_catalog.tintervalgt(tinterval, tinterval) owner to postgres;

create function pg_catalog.tintervalle(tinterval, tinterval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalle(tinterval, tinterval) is 'implementation of <= operator';

alter function pg_catalog.tintervalle(tinterval, tinterval) owner to postgres;

create function pg_catalog.tintervalge(tinterval, tinterval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalge(tinterval, tinterval) is 'implementation of >= operator';

alter function pg_catalog.tintervalge(tinterval, tinterval) owner to postgres;

create function pg_catalog.pg_client_encoding()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_client_encoding() is 'encoding name of current database';

alter function pg_catalog.pg_client_encoding() owner to postgres;

create function pg_catalog.current_query()
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.current_query() is 'get the currently executing query';

alter function pg_catalog.current_query() owner to postgres;

create function pg_catalog.macaddr_eq(macaddr, macaddr)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_eq(macaddr, macaddr) is 'implementation of = operator';

alter function pg_catalog.macaddr_eq(macaddr, macaddr) owner to postgres;

create function pg_catalog.macaddr_lt(macaddr, macaddr)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_lt(macaddr, macaddr) is 'implementation of < operator';

alter function pg_catalog.macaddr_lt(macaddr, macaddr) owner to postgres;

create function pg_catalog.macaddr_le(macaddr, macaddr)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_le(macaddr, macaddr) is 'implementation of <= operator';

alter function pg_catalog.macaddr_le(macaddr, macaddr) owner to postgres;

create function pg_catalog.macaddr_gt(macaddr, macaddr)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_gt(macaddr, macaddr) is 'implementation of > operator';

alter function pg_catalog.macaddr_gt(macaddr, macaddr) owner to postgres;

create function pg_catalog.macaddr_ge(macaddr, macaddr)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_ge(macaddr, macaddr) is 'implementation of >= operator';

alter function pg_catalog.macaddr_ge(macaddr, macaddr) owner to postgres;

create function pg_catalog.macaddr_ne(macaddr, macaddr)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_ne(macaddr, macaddr) is 'implementation of <> operator';

alter function pg_catalog.macaddr_ne(macaddr, macaddr) owner to postgres;

create function pg_catalog.macaddr_cmp(macaddr, macaddr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_cmp(macaddr, macaddr) is 'less-equal-greater';

alter function pg_catalog.macaddr_cmp(macaddr, macaddr) owner to postgres;

create function pg_catalog.int82pl(bigint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82pl(bigint, smallint) is 'implementation of + operator';

alter function pg_catalog.int82pl(bigint, smallint) owner to postgres;

create function pg_catalog.int82mi(bigint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82mi(bigint, smallint) is 'implementation of - operator';

alter function pg_catalog.int82mi(bigint, smallint) owner to postgres;

create function pg_catalog.int82mul(bigint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82mul(bigint, smallint) is 'implementation of * operator';

alter function pg_catalog.int82mul(bigint, smallint) owner to postgres;

create function pg_catalog.int82div(bigint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82div(bigint, smallint) is 'implementation of / operator';

alter function pg_catalog.int82div(bigint, smallint) owner to postgres;

create function pg_catalog.int28pl(smallint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28pl(smallint, bigint) is 'implementation of + operator';

alter function pg_catalog.int28pl(smallint, bigint) owner to postgres;

create function pg_catalog.btint8cmp(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint8cmp(bigint, bigint) is 'less-equal-greater';

alter function pg_catalog.btint8cmp(bigint, bigint) owner to postgres;

create function pg_catalog.cash_mul_flt4(money, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_mul_flt4(money, real) is 'implementation of * operator';

alter function pg_catalog.cash_mul_flt4(money, real) owner to postgres;

create function pg_catalog.cash_div_flt4(money, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_div_flt4(money, real) is 'implementation of / operator';

alter function pg_catalog.cash_div_flt4(money, real) owner to postgres;

create function pg_catalog.flt4_mul_cash(real, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.flt4_mul_cash(real, money) is 'implementation of * operator';

alter function pg_catalog.flt4_mul_cash(real, money) owner to postgres;

create function pg_catalog.position(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.position(text, text) is 'position of substring';

alter function pg_catalog.position(text, text) owner to postgres;

create function pg_catalog.textlike(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textlike(text, text) is 'implementation of ~~ operator';

alter function pg_catalog.textlike(text, text) owner to postgres;

create function pg_catalog.textnlike(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textnlike(text, text) is 'implementation of !~~ operator';

alter function pg_catalog.textnlike(text, text) owner to postgres;

create function pg_catalog.int48eq(integer, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48eq(integer, bigint) is 'implementation of = operator';

alter function pg_catalog.int48eq(integer, bigint) owner to postgres;

create function pg_catalog.int48ne(integer, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48ne(integer, bigint) is 'implementation of <> operator';

alter function pg_catalog.int48ne(integer, bigint) owner to postgres;

create function pg_catalog.int48lt(integer, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48lt(integer, bigint) is 'implementation of < operator';

alter function pg_catalog.int48lt(integer, bigint) owner to postgres;

create function pg_catalog.int48gt(integer, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48gt(integer, bigint) is 'implementation of > operator';

alter function pg_catalog.int48gt(integer, bigint) owner to postgres;

create function pg_catalog.int48le(integer, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48le(integer, bigint) is 'implementation of <= operator';

alter function pg_catalog.int48le(integer, bigint) owner to postgres;

create function pg_catalog.int48ge(integer, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48ge(integer, bigint) is 'implementation of >= operator';

alter function pg_catalog.int48ge(integer, bigint) owner to postgres;

create function pg_catalog.namelike(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namelike(name, text) is 'implementation of ~~ operator';

alter function pg_catalog.namelike(name, text) owner to postgres;

create function pg_catalog.namenlike(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namenlike(name, text) is 'implementation of !~~ operator';

alter function pg_catalog.namenlike(name, text) owner to postgres;

create function pg_catalog.bpchar("char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar("char") is 'convert char to char(n)';

alter function pg_catalog.bpchar("char") owner to postgres;

create function pg_catalog.current_database()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.current_database() is 'name of the current database';

alter function pg_catalog.current_database() owner to postgres;

create function pg_catalog.int4_mul_cash(integer, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4_mul_cash(integer, money) is 'implementation of * operator';

alter function pg_catalog.int4_mul_cash(integer, money) owner to postgres;

create function pg_catalog.int2_mul_cash(smallint, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2_mul_cash(smallint, money) is 'implementation of * operator';

alter function pg_catalog.int2_mul_cash(smallint, money) owner to postgres;

create function pg_catalog.cash_mul_int4(money, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_mul_int4(money, integer) is 'implementation of * operator';

alter function pg_catalog.cash_mul_int4(money, integer) owner to postgres;

create function pg_catalog.cash_div_int4(money, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_div_int4(money, integer) is 'implementation of / operator';

alter function pg_catalog.cash_div_int4(money, integer) owner to postgres;

create function pg_catalog.cash_mul_int2(money, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_mul_int2(money, smallint) is 'implementation of * operator';

alter function pg_catalog.cash_mul_int2(money, smallint) owner to postgres;

create function pg_catalog.cash_div_int2(money, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_div_int2(money, smallint) is 'implementation of / operator';

alter function pg_catalog.cash_div_int2(money, smallint) owner to postgres;

create function pg_catalog.strpos(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.strpos(text, text) is 'position of substring';

alter function pg_catalog.strpos(text, text) owner to postgres;

create function pg_catalog.lower(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lower(text) is 'lowercase';

alter function pg_catalog.lower(text) owner to postgres;

create function pg_catalog.upper(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.upper(text) is 'uppercase';

alter function pg_catalog.upper(text) owner to postgres;

create function pg_catalog.initcap(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.initcap(text) is 'capitalize each word';

alter function pg_catalog.initcap(text) owner to postgres;

create function pg_catalog.lpad(text, integer, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lpad(text, integer, text) is 'left-pad string to length';

alter function pg_catalog.lpad(text, integer, text) owner to postgres;

create function pg_catalog.rpad(text, integer, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.rpad(text, integer, text) is 'right-pad string to length';

alter function pg_catalog.rpad(text, integer, text) owner to postgres;

create function pg_catalog.ltrim(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ltrim(text, text) is 'trim selected characters from left end of string';

alter function pg_catalog.ltrim(text, text) owner to postgres;

create function pg_catalog.rtrim(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.rtrim(text, text) is 'trim selected characters from right end of string';

alter function pg_catalog.rtrim(text, text) owner to postgres;

create function pg_catalog.substr(text, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substr(text, integer, integer) is 'extract portion of string';

alter function pg_catalog.substr(text, integer, integer) owner to postgres;

create function pg_catalog.translate(text, text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.translate(text, text, text) is 'map a set of characters appearing in string';

alter function pg_catalog.translate(text, text, text) owner to postgres;

create function pg_catalog.lpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.lpad($1, $2, ' ')
$$;

comment on function pg_catalog.lpad(text, integer) is 'left-pad string to length';

alter function pg_catalog.lpad(text, integer) owner to postgres;

create function pg_catalog.rpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.rpad($1, $2, ' ')
$$;

comment on function pg_catalog.rpad(text, integer) is 'right-pad string to length';

alter function pg_catalog.rpad(text, integer) owner to postgres;

create function pg_catalog.ltrim(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ltrim(text) is 'trim spaces from left end of string';

alter function pg_catalog.ltrim(text) owner to postgres;

create function pg_catalog.rtrim(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.rtrim(text) is 'trim spaces from right end of string';

alter function pg_catalog.rtrim(text) owner to postgres;

create function pg_catalog.substr(text, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substr(text, integer) is 'extract portion of string';

alter function pg_catalog.substr(text, integer) owner to postgres;

create function pg_catalog.btrim(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btrim(text, text) is 'trim selected characters from both ends of string';

alter function pg_catalog.btrim(text, text) owner to postgres;

create function pg_catalog.btrim(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btrim(text) is 'trim spaces from both ends of string';

alter function pg_catalog.btrim(text) owner to postgres;

create function pg_catalog.cash_in(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_in(cstring) is 'I/O';

alter function pg_catalog.cash_in(cstring) owner to postgres;

create function pg_catalog.cash_out(money)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_out(money) is 'I/O';

alter function pg_catalog.cash_out(money) owner to postgres;

create function pg_catalog.cash_eq(money, money)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_eq(money, money) is 'implementation of = operator';

alter function pg_catalog.cash_eq(money, money) owner to postgres;

create function pg_catalog.cash_ne(money, money)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_ne(money, money) is 'implementation of <> operator';

alter function pg_catalog.cash_ne(money, money) owner to postgres;

create function pg_catalog.cash_lt(money, money)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_lt(money, money) is 'implementation of < operator';

alter function pg_catalog.cash_lt(money, money) owner to postgres;

create function pg_catalog.cash_le(money, money)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_le(money, money) is 'implementation of <= operator';

alter function pg_catalog.cash_le(money, money) owner to postgres;

create function pg_catalog.cash_gt(money, money)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_gt(money, money) is 'implementation of > operator';

alter function pg_catalog.cash_gt(money, money) owner to postgres;

create function pg_catalog.cash_ge(money, money)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_ge(money, money) is 'implementation of >= operator';

alter function pg_catalog.cash_ge(money, money) owner to postgres;

create function pg_catalog.cash_pl(money, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_pl(money, money) is 'implementation of + operator';

alter function pg_catalog.cash_pl(money, money) owner to postgres;

create function pg_catalog.cash_mi(money, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_mi(money, money) is 'implementation of - operator';

alter function pg_catalog.cash_mi(money, money) owner to postgres;

create function pg_catalog.cash_mul_flt8(money, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_mul_flt8(money, double precision) is 'implementation of * operator';

alter function pg_catalog.cash_mul_flt8(money, double precision) owner to postgres;

create function pg_catalog.cash_div_flt8(money, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_div_flt8(money, double precision) is 'implementation of / operator';

alter function pg_catalog.cash_div_flt8(money, double precision) owner to postgres;

create function pg_catalog.cashlarger(money, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cashlarger(money, money) is 'larger of two';

alter function pg_catalog.cashlarger(money, money) owner to postgres;

create function pg_catalog.cashsmaller(money, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cashsmaller(money, money) is 'smaller of two';

alter function pg_catalog.cashsmaller(money, money) owner to postgres;

create function pg_catalog.inet_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_in(cstring) is 'I/O';

alter function pg_catalog.inet_in(cstring) owner to postgres;

create function pg_catalog.inet_out(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_out(inet) is 'I/O';

alter function pg_catalog.inet_out(inet) owner to postgres;

create function pg_catalog.flt8_mul_cash(double precision, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.flt8_mul_cash(double precision, money) is 'implementation of * operator';

alter function pg_catalog.flt8_mul_cash(double precision, money) owner to postgres;

create function pg_catalog.network_eq(inet, inet)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_eq(inet, inet) is 'implementation of = operator';

alter function pg_catalog.network_eq(inet, inet) owner to postgres;

create function pg_catalog.network_lt(inet, inet)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_lt(inet, inet) is 'implementation of < operator';

alter function pg_catalog.network_lt(inet, inet) owner to postgres;

create function pg_catalog.network_le(inet, inet)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_le(inet, inet) is 'implementation of <= operator';

alter function pg_catalog.network_le(inet, inet) owner to postgres;

create function pg_catalog.network_gt(inet, inet)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_gt(inet, inet) is 'implementation of > operator';

alter function pg_catalog.network_gt(inet, inet) owner to postgres;

create function pg_catalog.network_ge(inet, inet)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_ge(inet, inet) is 'implementation of >= operator';

alter function pg_catalog.network_ge(inet, inet) owner to postgres;

create function pg_catalog.network_ne(inet, inet)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_ne(inet, inet) is 'implementation of <> operator';

alter function pg_catalog.network_ne(inet, inet) owner to postgres;

create function pg_catalog.network_cmp(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_cmp(inet, inet) is 'less-equal-greater';

alter function pg_catalog.network_cmp(inet, inet) owner to postgres;

create function pg_catalog.network_sub(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_sub(inet, inet) is 'implementation of << operator';

alter function pg_catalog.network_sub(inet, inet) owner to postgres;

create function pg_catalog.network_subeq(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_subeq(inet, inet) is 'implementation of <<= operator';

alter function pg_catalog.network_subeq(inet, inet) owner to postgres;

create function pg_catalog.network_sup(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_sup(inet, inet) is 'implementation of >> operator';

alter function pg_catalog.network_sup(inet, inet) owner to postgres;

create function pg_catalog.network_supeq(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_supeq(inet, inet) is 'implementation of >>= operator';

alter function pg_catalog.network_supeq(inet, inet) owner to postgres;

create function pg_catalog.cash_words(money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_words(money) is 'output money amount as words';

alter function pg_catalog.cash_words(money) owner to postgres;

create function pg_catalog.substring(text, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substring(text, integer, integer) is 'extract portion of string';

alter function pg_catalog.substring(text, integer, integer) owner to postgres;

create function pg_catalog.substring(text, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substring(text, integer) is 'extract portion of string';

alter function pg_catalog.substring(text, integer) owner to postgres;

create function pg_catalog.generate_series(timestamp, timestamp, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_series(timestamp, timestamp, interval) is 'non-persistent series generator';

alter function pg_catalog.generate_series(timestamp, timestamp, interval) owner to postgres;

create function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) is 'non-persistent series generator';

alter function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) owner to postgres;

create function pg_catalog.mod(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.mod(smallint, smallint) is 'modulus';

alter function pg_catalog.mod(smallint, smallint) owner to postgres;

create function pg_catalog.mod(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.mod(integer, integer) is 'modulus';

alter function pg_catalog.mod(integer, integer) owner to postgres;

create function pg_catalog.int28mi(smallint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28mi(smallint, bigint) is 'implementation of - operator';

alter function pg_catalog.int28mi(smallint, bigint) owner to postgres;

create function pg_catalog.int28mul(smallint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28mul(smallint, bigint) is 'implementation of * operator';

alter function pg_catalog.int28mul(smallint, bigint) owner to postgres;

create function pg_catalog.char(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.char(text) is 'convert text to char';

alter function pg_catalog.char(text) owner to postgres;

create function pg_catalog.int8mod(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8mod(bigint, bigint) is 'implementation of % operator';

alter function pg_catalog.int8mod(bigint, bigint) owner to postgres;

create function pg_catalog.text("char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text("char") is 'convert char to text';

alter function pg_catalog.text("char") owner to postgres;

create function pg_catalog.mod(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.mod(bigint, bigint) is 'modulus';

alter function pg_catalog.mod(bigint, bigint) owner to postgres;

create function pg_catalog.int28div(smallint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28div(smallint, bigint) is 'implementation of / operator';

alter function pg_catalog.int28div(smallint, bigint) owner to postgres;

create function pg_catalog.hashint8(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashint8(bigint) is 'hash';

alter function pg_catalog.hashint8(bigint) owner to postgres;

create function pg_catalog.lo_open(oid, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_open(oid, integer) is 'large object open';

alter function pg_catalog.lo_open(oid, integer) owner to postgres;

create function pg_catalog.lo_close(integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_close(integer) is 'large object close';

alter function pg_catalog.lo_close(integer) owner to postgres;

create function pg_catalog.loread(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.loread(integer, integer) is 'large object read';

alter function pg_catalog.loread(integer, integer) owner to postgres;

create function pg_catalog.lowrite(integer, bytea)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lowrite(integer, bytea) is 'large object write';

alter function pg_catalog.lowrite(integer, bytea) owner to postgres;

create function pg_catalog.lo_lseek(integer, integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_lseek(integer, integer, integer) is 'large object seek';

alter function pg_catalog.lo_lseek(integer, integer, integer) owner to postgres;

create function pg_catalog.lo_creat(integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_creat(integer) is 'large object create';

alter function pg_catalog.lo_creat(integer) owner to postgres;

create function pg_catalog.lo_tell(integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_tell(integer) is 'large object position';

alter function pg_catalog.lo_tell(integer) owner to postgres;

create function pg_catalog.on_pl(point, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.on_pl(point, line) is 'implementation of <@ operator';

alter function pg_catalog.on_pl(point, line) owner to postgres;

create function pg_catalog.on_sl(lseg, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.on_sl(lseg, line) is 'implementation of <@ operator';

alter function pg_catalog.on_sl(lseg, line) owner to postgres;

create function pg_catalog.close_pl(point, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.close_pl(point, line) is 'implementation of ## operator';

alter function pg_catalog.close_pl(point, line) owner to postgres;

create function pg_catalog.close_sl(lseg, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.close_sl(lseg, line) is 'implementation of ## operator';

alter function pg_catalog.close_sl(lseg, line) owner to postgres;

create function pg_catalog.close_lb(line, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.close_lb(line, box) is 'implementation of ## operator';

alter function pg_catalog.close_lb(line, box) owner to postgres;

create function pg_catalog.lo_unlink(oid)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_unlink(oid) is 'large object unlink (delete)';

alter function pg_catalog.lo_unlink(oid) owner to postgres;

create function pg_catalog.path_inter(path, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_inter(path, path) is 'implementation of ?# operator';

alter function pg_catalog.path_inter(path, path) owner to postgres;

create function pg_catalog.area(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.area(box) is 'box area';

alter function pg_catalog.area(box) owner to postgres;

create function pg_catalog.width(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.width(box) is 'box width';

alter function pg_catalog.width(box) owner to postgres;

create function pg_catalog.height(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.height(box) is 'box height';

alter function pg_catalog.height(box) owner to postgres;

create function pg_catalog.box_distance(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_distance(box, box) is 'implementation of <-> operator';

alter function pg_catalog.box_distance(box, box) owner to postgres;

create function pg_catalog.area(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.area(path) is 'area of a closed path';

alter function pg_catalog.area(path) owner to postgres;

create function pg_catalog.box_intersect(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_intersect(box, box) is 'implementation of # operator';

alter function pg_catalog.box_intersect(box, box) owner to postgres;

create function pg_catalog.diagonal(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.diagonal(box) is 'box diagonal';

alter function pg_catalog.diagonal(box) owner to postgres;

create function pg_catalog.path_n_lt(path, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_n_lt(path, path) is 'implementation of < operator';

alter function pg_catalog.path_n_lt(path, path) owner to postgres;

create function pg_catalog.path_n_gt(path, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_n_gt(path, path) is 'implementation of > operator';

alter function pg_catalog.path_n_gt(path, path) owner to postgres;

create function pg_catalog.path_n_eq(path, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_n_eq(path, path) is 'implementation of = operator';

alter function pg_catalog.path_n_eq(path, path) owner to postgres;

create function pg_catalog.path_n_le(path, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_n_le(path, path) is 'implementation of <= operator';

alter function pg_catalog.path_n_le(path, path) owner to postgres;

create function pg_catalog.path_n_ge(path, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_n_ge(path, path) is 'implementation of >= operator';

alter function pg_catalog.path_n_ge(path, path) owner to postgres;

create function pg_catalog.path_length(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_length(path) is 'implementation of @-@ operator';

alter function pg_catalog.path_length(path) owner to postgres;

create function pg_catalog.point_ne(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_ne(point, point) is 'implementation of <> operator';

alter function pg_catalog.point_ne(point, point) owner to postgres;

create function pg_catalog.point_vert(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_vert(point, point) is 'implementation of ?| operator';

alter function pg_catalog.point_vert(point, point) owner to postgres;

create function pg_catalog.point_horiz(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_horiz(point, point) is 'implementation of ?- operator';

alter function pg_catalog.point_horiz(point, point) owner to postgres;

create function pg_catalog.point_distance(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_distance(point, point) is 'implementation of <-> operator';

alter function pg_catalog.point_distance(point, point) owner to postgres;

create function pg_catalog.slope(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.slope(point, point) is 'slope between points';

alter function pg_catalog.slope(point, point) owner to postgres;

create function pg_catalog.lseg(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg(point, point) is 'convert points to line segment';

alter function pg_catalog.lseg(point, point) owner to postgres;

create function pg_catalog.lseg_intersect(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_intersect(lseg, lseg) is 'implementation of ?# operator';

alter function pg_catalog.lseg_intersect(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_parallel(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_parallel(lseg, lseg) is 'implementation of ?|| operator';

alter function pg_catalog.lseg_parallel(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_perp(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_perp(lseg, lseg) is 'implementation of ?-| operator';

alter function pg_catalog.lseg_perp(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_vertical(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_vertical(lseg) is 'implementation of ?| operator';

alter function pg_catalog.lseg_vertical(lseg) owner to postgres;

create function pg_catalog.lseg_horizontal(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_horizontal(lseg) is 'implementation of ?- operator';

alter function pg_catalog.lseg_horizontal(lseg) owner to postgres;

create function pg_catalog.lseg_eq(lseg, lseg)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_eq(lseg, lseg) is 'implementation of = operator';

alter function pg_catalog.lseg_eq(lseg, lseg) owner to postgres;

create function pg_catalog.lo_truncate(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_truncate(integer, integer) is 'truncate large object';

alter function pg_catalog.lo_truncate(integer, integer) owner to postgres;

create function pg_catalog.timezone(interval, timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timezone(interval, timestamp with time zone) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(interval, timestamp with time zone) owner to postgres;

create function pg_catalog.gist_point_compress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_point_compress(internal) is 'GiST support';

alter function pg_catalog.gist_point_compress(internal) owner to postgres;

create function pg_catalog.aclitemin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.aclitemin(cstring) is 'I/O';

alter function pg_catalog.aclitemin(cstring) owner to postgres;

create function pg_catalog.aclitemout(aclitem)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.aclitemout(aclitem) is 'I/O';

alter function pg_catalog.aclitemout(aclitem) owner to postgres;

create function pg_catalog.aclinsert(aclitem[], aclitem)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.aclinsert(aclitem[], aclitem) is 'add/update ACL item';

alter function pg_catalog.aclinsert(aclitem[], aclitem) owner to postgres;

create function pg_catalog.aclremove(aclitem[], aclitem)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.aclremove(aclitem[], aclitem) is 'remove ACL item';

alter function pg_catalog.aclremove(aclitem[], aclitem) owner to postgres;

create function pg_catalog.aclcontains(aclitem[], aclitem)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.aclcontains(aclitem[], aclitem) is 'contains';

alter function pg_catalog.aclcontains(aclitem[], aclitem) owner to postgres;

create function pg_catalog.getdatabaseencoding()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.getdatabaseencoding() is 'encoding name of current database';

alter function pg_catalog.getdatabaseencoding() owner to postgres;

create function pg_catalog.bpcharin(cstring, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharin(cstring, oid, integer) is 'I/O';

alter function pg_catalog.bpcharin(cstring, oid, integer) owner to postgres;

create function pg_catalog.bpcharout(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharout(char) is 'I/O';

alter function pg_catalog.bpcharout(char) owner to postgres;

create function pg_catalog.varcharin(cstring, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varcharin(cstring, oid, integer) is 'I/O';

alter function pg_catalog.varcharin(cstring, oid, integer) owner to postgres;

create function pg_catalog.varcharout(varchar)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varcharout(varchar) is 'I/O';

alter function pg_catalog.varcharout(varchar) owner to postgres;

create function pg_catalog.bpchareq(char, char)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchareq(char, char) is 'implementation of = operator';

alter function pg_catalog.bpchareq(char, char) owner to postgres;

create function pg_catalog.bpcharlt(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharlt(char, char) is 'implementation of < operator';

alter function pg_catalog.bpcharlt(char, char) owner to postgres;

create function pg_catalog.bpcharle(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharle(char, char) is 'implementation of <= operator';

alter function pg_catalog.bpcharle(char, char) owner to postgres;

create function pg_catalog.bpchargt(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchargt(char, char) is 'implementation of > operator';

alter function pg_catalog.bpchargt(char, char) owner to postgres;

create function pg_catalog.bpcharge(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharge(char, char) is 'implementation of >= operator';

alter function pg_catalog.bpcharge(char, char) owner to postgres;

create function pg_catalog.bpcharne(char, char)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharne(char, char) is 'implementation of <> operator';

alter function pg_catalog.bpcharne(char, char) owner to postgres;

create function pg_catalog.aclitemeq(aclitem, aclitem)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.aclitemeq(aclitem, aclitem) is 'implementation of = operator';

alter function pg_catalog.aclitemeq(aclitem, aclitem) owner to postgres;

create function pg_catalog.bpchar_larger(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar_larger(char, char) is 'larger of two';

alter function pg_catalog.bpchar_larger(char, char) owner to postgres;

create function pg_catalog.bpchar_smaller(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar_smaller(char, char) is 'smaller of two';

alter function pg_catalog.bpchar_smaller(char, char) owner to postgres;

create function pg_catalog.pg_prepared_xact(out transaction xid, out gid text, out prepared timestamp with time zone,
                                            out ownerid oid, out dbid oid)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_prepared_xact(out xid, out text, out timestamp with time zone, out oid, out oid) is 'view two-phase transactions';

alter function pg_catalog.pg_prepared_xact(out xid, out text, out timestamp with time zone, out oid, out oid) owner to postgres;

create function pg_catalog.generate_series(integer, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_series(integer, integer, integer) is 'non-persistent series generator';

alter function pg_catalog.generate_series(integer, integer, integer) owner to postgres;

create function pg_catalog.generate_series(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_series(integer, integer) is 'non-persistent series generator';

alter function pg_catalog.generate_series(integer, integer) owner to postgres;

create function pg_catalog.generate_series(bigint, bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_series(bigint, bigint, bigint) is 'non-persistent series generator';

alter function pg_catalog.generate_series(bigint, bigint, bigint) owner to postgres;

create function pg_catalog.generate_series(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_series(bigint, bigint) is 'non-persistent series generator';

alter function pg_catalog.generate_series(bigint, bigint) owner to postgres;

create function pg_catalog.bpcharcmp(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharcmp(char, char) is 'less-equal-greater';

alter function pg_catalog.bpcharcmp(char, char) owner to postgres;

create function pg_catalog.regclass(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regclass(text) is 'convert text to regclass';

alter function pg_catalog.regclass(text) owner to postgres;

create function pg_catalog.hashbpchar(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashbpchar(char) is 'hash';

alter function pg_catalog.hashbpchar(char) owner to postgres;

create function pg_catalog.format_type(oid, integer)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.format_type(oid, integer) is 'format a type oid and atttypmod to canonical SQL';

alter function pg_catalog.format_type(oid, integer) owner to postgres;

create function pg_catalog.date_in(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_in(cstring) is 'I/O';

alter function pg_catalog.date_in(cstring) owner to postgres;

create function pg_catalog.date_out(date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_out(date) is 'I/O';

alter function pg_catalog.date_out(date) owner to postgres;

create function pg_catalog.date_eq(date, date)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_eq(date, date) is 'implementation of = operator';

alter function pg_catalog.date_eq(date, date) owner to postgres;

create function pg_catalog.date_lt(date, date)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_lt(date, date) is 'implementation of < operator';

alter function pg_catalog.date_lt(date, date) owner to postgres;

create function pg_catalog.date_le(date, date)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_le(date, date) is 'implementation of <= operator';

alter function pg_catalog.date_le(date, date) owner to postgres;

create function pg_catalog.date_gt(date, date)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_gt(date, date) is 'implementation of > operator';

alter function pg_catalog.date_gt(date, date) owner to postgres;

create function pg_catalog.date_ge(date, date)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_ge(date, date) is 'implementation of >= operator';

alter function pg_catalog.date_ge(date, date) owner to postgres;

create function pg_catalog.date_ne(date, date)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_ne(date, date) is 'implementation of <> operator';

alter function pg_catalog.date_ne(date, date) owner to postgres;

create function pg_catalog.date_cmp(date, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_cmp(date, date) is 'less-equal-greater';

alter function pg_catalog.date_cmp(date, date) owner to postgres;

create function pg_catalog.time_lt(time, time)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_lt(time, time) is 'implementation of < operator';

alter function pg_catalog.time_lt(time, time) owner to postgres;

create function pg_catalog.time_le(time, time)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_le(time, time) is 'implementation of <= operator';

alter function pg_catalog.time_le(time, time) owner to postgres;

create function pg_catalog.time_gt(time, time)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_gt(time, time) is 'implementation of > operator';

alter function pg_catalog.time_gt(time, time) owner to postgres;

create function pg_catalog.time_ge(time, time)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_ge(time, time) is 'implementation of >= operator';

alter function pg_catalog.time_ge(time, time) owner to postgres;

create function pg_catalog.time_ne(time, time)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_ne(time, time) is 'implementation of <> operator';

alter function pg_catalog.time_ne(time, time) owner to postgres;

create function pg_catalog.time_cmp(time, time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_cmp(time, time) is 'less-equal-greater';

alter function pg_catalog.time_cmp(time, time) owner to postgres;

create function pg_catalog.date_larger(date, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_larger(date, date) is 'larger of two';

alter function pg_catalog.date_larger(date, date) owner to postgres;

create function pg_catalog.date_smaller(date, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_smaller(date, date) is 'smaller of two';

alter function pg_catalog.date_smaller(date, date) owner to postgres;

create function pg_catalog.date_mi(date, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_mi(date, date) is 'implementation of - operator';

alter function pg_catalog.date_mi(date, date) owner to postgres;

create function pg_catalog.date_pli(date, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_pli(date, integer) is 'implementation of + operator';

alter function pg_catalog.date_pli(date, integer) owner to postgres;

create function pg_catalog.date_mii(date, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_mii(date, integer) is 'implementation of - operator';

alter function pg_catalog.date_mii(date, integer) owner to postgres;

create function pg_catalog.time_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.time_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.time_out(time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_out(time) is 'I/O';

alter function pg_catalog.time_out(time) owner to postgres;

create function pg_catalog.time_eq(time, time)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_eq(time, time) is 'implementation of = operator';

alter function pg_catalog.time_eq(time, time) owner to postgres;

create function pg_catalog.circle_add_pt(circle, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_add_pt(circle, point) is 'implementation of + operator';

alter function pg_catalog.circle_add_pt(circle, point) owner to postgres;

create function pg_catalog.circle_sub_pt(circle, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_sub_pt(circle, point) is 'implementation of - operator';

alter function pg_catalog.circle_sub_pt(circle, point) owner to postgres;

create function pg_catalog.circle_mul_pt(circle, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_mul_pt(circle, point) is 'implementation of * operator';

alter function pg_catalog.circle_mul_pt(circle, point) owner to postgres;

create function pg_catalog.circle_div_pt(circle, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_div_pt(circle, point) is 'implementation of / operator';

alter function pg_catalog.circle_div_pt(circle, point) owner to postgres;

create function pg_catalog.timestamptz_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.timestamptz_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.timestamptz_out(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_out(timestamp with time zone) is 'I/O';

alter function pg_catalog.timestamptz_out(timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.to_timestamp(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_timestamp(double precision) is 'convert UNIX epoch to timestamptz';

alter function pg_catalog.to_timestamp(double precision) owner to postgres;

create function pg_catalog.timezone(text, timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timezone(text, timestamp with time zone) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(text, timestamp with time zone) owner to postgres;

create function pg_catalog.interval_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.interval_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.interval_out(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_out(interval) is 'I/O';

alter function pg_catalog.interval_out(interval) owner to postgres;

create function pg_catalog.interval_eq(interval, interval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_eq(interval, interval) is 'implementation of = operator';

alter function pg_catalog.interval_eq(interval, interval) owner to postgres;

create function pg_catalog.interval_ne(interval, interval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_ne(interval, interval) is 'implementation of <> operator';

alter function pg_catalog.interval_ne(interval, interval) owner to postgres;

create function pg_catalog.interval_lt(interval, interval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_lt(interval, interval) is 'implementation of < operator';

alter function pg_catalog.interval_lt(interval, interval) owner to postgres;

create function pg_catalog.interval_le(interval, interval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_le(interval, interval) is 'implementation of <= operator';

alter function pg_catalog.interval_le(interval, interval) owner to postgres;

create function pg_catalog.interval_ge(interval, interval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_ge(interval, interval) is 'implementation of >= operator';

alter function pg_catalog.interval_ge(interval, interval) owner to postgres;

create function pg_catalog.interval_gt(interval, interval)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_gt(interval, interval) is 'implementation of > operator';

alter function pg_catalog.interval_gt(interval, interval) owner to postgres;

create function pg_catalog.interval_um(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_um(interval) is 'implementation of - operator';

alter function pg_catalog.interval_um(interval) owner to postgres;

create function pg_catalog.interval_pl(interval, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_pl(interval, interval) is 'implementation of + operator';

alter function pg_catalog.interval_pl(interval, interval) owner to postgres;

create function pg_catalog.interval_mi(interval, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_mi(interval, interval) is 'implementation of - operator';

alter function pg_catalog.interval_mi(interval, interval) owner to postgres;

create function pg_catalog.date_part(text, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_part(text, timestamp with time zone) is 'extract field from timestamp with time zone';

alter function pg_catalog.date_part(text, timestamp with time zone) owner to postgres;

create function pg_catalog.date_part(text, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_part(text, interval) is 'extract field from interval';

alter function pg_catalog.date_part(text, interval) owner to postgres;

create function pg_catalog.timestamptz(abstime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz(abstime) is 'convert abstime to timestamp with time zone';

alter function pg_catalog.timestamptz(abstime) owner to postgres;

create function pg_catalog.timestamptz(date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz(date) is 'convert date to timestamp with time zone';

alter function pg_catalog.timestamptz(date) owner to postgres;

create function pg_catalog.justify_hours(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.justify_hours(interval) is 'promote groups of 24 hours to numbers of days';

alter function pg_catalog.justify_hours(interval) owner to postgres;

create function pg_catalog.timestamptz(date, time without time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select cast(($1 + $2) as timestamp with time zone)
$$;

comment on function pg_catalog.timestamptz(date, time) is 'convert date and time to timestamp with time zone';

alter function pg_catalog.timestamptz(date, time) owner to postgres;

create function pg_catalog.interval(reltime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval(reltime) is 'convert reltime to interval';

alter function pg_catalog.interval(reltime) owner to postgres;

create function pg_catalog.date(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date(timestamp with time zone) is 'convert timestamp with time zone to date';

alter function pg_catalog.date(timestamp with time zone) owner to postgres;

create function pg_catalog.date(abstime)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date(abstime) is 'convert abstime to date';

alter function pg_catalog.date(abstime) owner to postgres;

create function pg_catalog.abstime(timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstime(timestamp with time zone) is 'convert timestamp with time zone to abstime';

alter function pg_catalog.abstime(timestamp with time zone) owner to postgres;

create function pg_catalog.age(xid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.age(xid) is 'age of a transaction ID, in transactions before current transaction';

alter function pg_catalog.age(xid) owner to postgres;

create function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) is 'implementation of - operator';

alter function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) is 'implementation of + operator';

alter function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) owner to postgres;

create function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) is 'implementation of - operator';

alter function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) owner to postgres;

create function pg_catalog.generate_subscripts(anyarray, integer, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_subscripts(anyarray, integer, boolean) is 'array subscripts generator';

alter function pg_catalog.generate_subscripts(anyarray, integer, boolean) owner to postgres;

create function pg_catalog.generate_subscripts(anyarray, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_subscripts(anyarray, integer) is 'array subscripts generator';

alter function pg_catalog.generate_subscripts(anyarray, integer) owner to postgres;

create function pg_catalog.array_fill(anyelement, integer[])
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_fill(anyelement, integer[]) is 'array constructor with value';

alter function pg_catalog.array_fill(anyelement, integer[]) owner to postgres;

create function pg_catalog.reltime(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltime(interval) is 'convert interval to reltime';

alter function pg_catalog.reltime(interval) owner to postgres;

create function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) is 'smaller of two';

alter function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) is 'larger of two';

alter function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.interval_smaller(interval, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_smaller(interval, interval) is 'smaller of two';

alter function pg_catalog.interval_smaller(interval, interval) owner to postgres;

create function pg_catalog.interval_larger(interval, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_larger(interval, interval) is 'larger of two';

alter function pg_catalog.interval_larger(interval, interval) owner to postgres;

create function pg_catalog.age(timestamp with time zone, timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.age(timestamp with time zone, timestamp with time zone) is 'date difference preserving months and years';

alter function pg_catalog.age(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.interval(interval, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval(interval, integer) is 'adjust interval precision';

alter function pg_catalog.interval(interval, integer) owner to postgres;

create function pg_catalog.obj_description(oid, name) returns text
    stable
    strict
    parallel safe
    language sql
as
$$
select description
from pg_catalog.pg_description
where objoid = $1
  and classoid = (select oid from pg_catalog.pg_class where relname = $2 and relnamespace = 11)
  and objsubid = 0
$$;

comment on function pg_catalog.obj_description(oid, name) is 'get description for object id and catalog name';

alter function pg_catalog.obj_description(oid, name) owner to postgres;

create function pg_catalog.col_description(oid, integer) returns text
    stable
    strict
    parallel safe
    language sql
as
$$
select description
from pg_catalog.pg_description
where objoid = $1
  and classoid = 'pg_catalog.pg_class'::pg_catalog.regclass
  and objsubid = $2
$$;

comment on function pg_catalog.col_description(oid, integer) is 'get description for table column';

alter function pg_catalog.col_description(oid, integer) owner to postgres;

create function pg_catalog.date_trunc(text, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_trunc(text, timestamp with time zone) is 'truncate timestamp with time zone to specified units';

alter function pg_catalog.date_trunc(text, timestamp with time zone) owner to postgres;

create function pg_catalog.date_trunc(text, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_trunc(text, interval) is 'truncate interval to specified units';

alter function pg_catalog.date_trunc(text, interval) owner to postgres;

create function pg_catalog.int8inc(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8inc(bigint) is 'increment';

alter function pg_catalog.int8inc(bigint) owner to postgres;

create function pg_catalog.int8abs(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8abs(bigint) is 'implementation of @ operator';

alter function pg_catalog.int8abs(bigint) owner to postgres;

create function pg_catalog.int8larger(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8larger(bigint, bigint) is 'larger of two';

alter function pg_catalog.int8larger(bigint, bigint) owner to postgres;

create function pg_catalog.int8smaller(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8smaller(bigint, bigint) is 'smaller of two';

alter function pg_catalog.int8smaller(bigint, bigint) owner to postgres;

create function pg_catalog.texticregexeq(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.texticregexeq(text, text) is 'implementation of ~* operator';

alter function pg_catalog.texticregexeq(text, text) owner to postgres;

create function pg_catalog.texticregexne(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.texticregexne(text, text) is 'implementation of !~* operator';

alter function pg_catalog.texticregexne(text, text) owner to postgres;

create function pg_catalog.nameicregexeq(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nameicregexeq(name, text) is 'implementation of ~* operator';

alter function pg_catalog.nameicregexeq(name, text) owner to postgres;

create function pg_catalog.nameicregexne(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nameicregexne(name, text) is 'implementation of !~* operator';

alter function pg_catalog.nameicregexne(name, text) owner to postgres;

create function pg_catalog.boolin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolin(cstring) is 'I/O';

alter function pg_catalog.boolin(cstring) owner to postgres;

create function pg_catalog.boolout(boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolout(boolean) is 'I/O';

alter function pg_catalog.boolout(boolean) owner to postgres;

create function pg_catalog.byteain(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteain(cstring) is 'I/O';

alter function pg_catalog.byteain(cstring) owner to postgres;

create function pg_catalog.charin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.charin(cstring) is 'I/O';

alter function pg_catalog.charin(cstring) owner to postgres;

create function pg_catalog.charlt("char", "char")
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.charlt("char", "char") is 'implementation of < operator';

alter function pg_catalog.charlt("char", "char") owner to postgres;

create function pg_catalog.unique_key_recheck()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.unique_key_recheck() is 'deferred UNIQUE constraint check';

alter function pg_catalog.unique_key_recheck() owner to postgres;

create function pg_catalog.int4abs(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4abs(integer) is 'implementation of @ operator';

alter function pg_catalog.int4abs(integer) owner to postgres;

create function pg_catalog.nameregexne(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nameregexne(name, text) is 'implementation of !~ operator';

alter function pg_catalog.nameregexne(name, text) owner to postgres;

create function pg_catalog.int2abs(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2abs(smallint) is 'implementation of @ operator';

alter function pg_catalog.int2abs(smallint) owner to postgres;

create function pg_catalog.textregexeq(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textregexeq(text, text) is 'implementation of ~ operator';

alter function pg_catalog.textregexeq(text, text) owner to postgres;

create function pg_catalog.textregexne(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textregexne(text, text) is 'implementation of !~ operator';

alter function pg_catalog.textregexne(text, text) owner to postgres;

create function pg_catalog.textlen(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textlen(text) is 'length';

alter function pg_catalog.textlen(text) owner to postgres;

create function pg_catalog.textcat(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textcat(text, text) is 'implementation of || operator';

alter function pg_catalog.textcat(text, text) owner to postgres;

create function pg_catalog.pg_char_to_encoding(name)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_char_to_encoding(name) is 'convert encoding name to encoding id';

alter function pg_catalog.pg_char_to_encoding(name) owner to postgres;

create function pg_catalog.tidne(tid, tid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidne(tid, tid) is 'implementation of <> operator';

alter function pg_catalog.tidne(tid, tid) owner to postgres;

create function pg_catalog.cidr_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidr_in(cstring) is 'I/O';

alter function pg_catalog.cidr_in(cstring) owner to postgres;

create function pg_catalog.parse_ident(str text, strict boolean default true)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.parse_ident(text, boolean) is 'parse qualified identifier to array of identifiers';

alter function pg_catalog.parse_ident(text, boolean) owner to postgres;

create function pg_catalog.pg_column_size("any")
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_column_size("any") is 'bytes required to store the value, perhaps with compression';

alter function pg_catalog.pg_column_size("any") owner to postgres;

create function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone,
                                      time with time zone)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone) owner to postgres;

create function pg_catalog.datetime_pl(date, time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.datetime_pl(date, time) is 'implementation of + operator';

alter function pg_catalog.datetime_pl(date, time) owner to postgres;

create function pg_catalog.date_part(text, time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_part(text, time with time zone) is 'extract field from time with time zone';

alter function pg_catalog.date_part(text, time with time zone) owner to postgres;

create function pg_catalog.int84pl(bigint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84pl(bigint, integer) is 'implementation of + operator';

alter function pg_catalog.int84pl(bigint, integer) owner to postgres;

create function pg_catalog.int84mi(bigint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84mi(bigint, integer) is 'implementation of - operator';

alter function pg_catalog.int84mi(bigint, integer) owner to postgres;

create function pg_catalog.int84mul(bigint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84mul(bigint, integer) is 'implementation of * operator';

alter function pg_catalog.int84mul(bigint, integer) owner to postgres;

create function pg_catalog.int84div(bigint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int84div(bigint, integer) is 'implementation of / operator';

alter function pg_catalog.int84div(bigint, integer) owner to postgres;

create function pg_catalog.int48pl(integer, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48pl(integer, bigint) is 'implementation of + operator';

alter function pg_catalog.int48pl(integer, bigint) owner to postgres;

create function pg_catalog.int48mi(integer, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48mi(integer, bigint) is 'implementation of - operator';

alter function pg_catalog.int48mi(integer, bigint) owner to postgres;

create function pg_catalog.int48mul(integer, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48mul(integer, bigint) is 'implementation of * operator';

alter function pg_catalog.int48mul(integer, bigint) owner to postgres;

create function pg_catalog.int48div(integer, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int48div(integer, bigint) is 'implementation of / operator';

alter function pg_catalog.int48div(integer, bigint) owner to postgres;

create function pg_catalog.quote_ident(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.quote_ident(text) is 'quote an identifier for usage in a querystring';

alter function pg_catalog.quote_ident(text) owner to postgres;

create function pg_catalog.quote_literal(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.quote_literal(text) is 'quote a literal for usage in a querystring';

alter function pg_catalog.quote_literal(text) owner to postgres;

create function pg_catalog.quote_literal(anyelement) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.quote_literal($1::pg_catalog.text)
$$;

comment on function pg_catalog.quote_literal(anyelement) is 'quote a data value for usage in a querystring';

alter function pg_catalog.quote_literal(anyelement) owner to postgres;

create function pg_catalog.array_fill(anyelement, integer[], integer[])
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_fill(anyelement, integer[], integer[]) is 'array constructor with value';

alter function pg_catalog.array_fill(anyelement, integer[], integer[]) owner to postgres;

create function pg_catalog.oid(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oid(bigint) is 'convert int8 to oid';

alter function pg_catalog.oid(bigint) owner to postgres;

create function pg_catalog.int8(oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8(oid) is 'convert oid to int8';

alter function pg_catalog.int8(oid) owner to postgres;

create function pg_catalog.quote_nullable(text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.quote_nullable(text) is 'quote a possibly-null literal for usage in a querystring';

alter function pg_catalog.quote_nullable(text) owner to postgres;

create function pg_catalog.quote_nullable(anyelement) returns text
    stable
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.quote_nullable($1::pg_catalog.text)
$$;

comment on function pg_catalog.quote_nullable(anyelement) is 'quote a possibly-null data value for usage in a querystring';

alter function pg_catalog.quote_nullable(anyelement) owner to postgres;

create function pg_catalog.suppress_redundant_updates_trigger()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.suppress_redundant_updates_trigger() is 'trigger to suppress updates when new and old records match';

alter function pg_catalog.suppress_redundant_updates_trigger() owner to postgres;

create function pg_catalog.tideq(tid, tid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tideq(tid, tid) is 'implementation of = operator';

alter function pg_catalog.tideq(tid, tid) owner to postgres;

create function pg_catalog.currtid(oid, tid)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.currtid(oid, tid) is 'latest tid of a tuple';

alter function pg_catalog.currtid(oid, tid) owner to postgres;

create function pg_catalog.currtid2(text, tid)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.currtid2(text, tid) is 'latest tid of a tuple';

alter function pg_catalog.currtid2(text, tid) owner to postgres;

create function pg_catalog.justify_days(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.justify_days(interval) is 'promote groups of 30 days to numbers of months';

alter function pg_catalog.justify_days(interval) owner to postgres;

create function pg_catalog.timedate_pl(time without time zone, date) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select ($2 + $1)
$$;

comment on function pg_catalog.timedate_pl(time, date) is 'implementation of + operator';

alter function pg_catalog.timedate_pl(time, date) owner to postgres;

create function pg_catalog.datetimetz_pl(date, time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.datetimetz_pl(date, time with time zone) is 'implementation of + operator';

alter function pg_catalog.datetimetz_pl(date, time with time zone) owner to postgres;

create function pg_catalog.timetzdate_pl(time with time zone, date) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select ($2 + $1)
$$;

comment on function pg_catalog.timetzdate_pl(time with time zone, date) is 'implementation of + operator';

alter function pg_catalog.timetzdate_pl(time with time zone, date) owner to postgres;

create function pg_catalog.now()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.now() is 'current transaction time';

alter function pg_catalog.now() owner to postgres;

create function pg_catalog.positionsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.positionsel(internal, oid, internal, integer) is 'restriction selectivity for position-comparison operators';

alter function pg_catalog.positionsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for position-comparison operators';

alter function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.contsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.contsel(internal, oid, internal, integer) is 'restriction selectivity for containment comparison operators';

alter function pg_catalog.contsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for containment comparison operators';

alter function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                      timestamp with time zone)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) returns boolean
    stable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone,
                                      interval) returns boolean
    stable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) owner to postgres;

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone,
                                      timestamp with time zone) returns boolean
    stable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog."overlaps"(time, time, time, time)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."overlaps"(time, time, time, time) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, time, time, time) owner to postgres;

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(time, interval, time, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, interval, time, interval) owner to postgres;

create function pg_catalog."overlaps"(time without time zone, time without time zone, time without time zone,
                                      interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(time, time, time, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, time, time, interval) owner to postgres;

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone,
                                      time without time zone) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(time, interval, time, time) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, interval, time, time) owner to postgres;

create function pg_catalog.timestamp_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.timestamp_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.timestamp_out(timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_out(timestamp) is 'I/O';

alter function pg_catalog.timestamp_out(timestamp) owner to postgres;

create function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.interval_cmp(interval, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_cmp(interval, interval) is 'less-equal-greater';

alter function pg_catalog.interval_cmp(interval, interval) owner to postgres;

create function pg_catalog.time(timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time(timestamp) is 'convert timestamp to time';

alter function pg_catalog.time(timestamp) owner to postgres;

create function pg_catalog.length(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.length(text) is 'length';

alter function pg_catalog.length(text) owner to postgres;

create function pg_catalog.length(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.length(char) is 'character length';

alter function pg_catalog.length(char) owner to postgres;

create function pg_catalog.xideqint4(xid, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xideqint4(xid, integer) is 'implementation of = operator';

alter function pg_catalog.xideqint4(xid, integer) owner to postgres;

create function pg_catalog.interval_div(interval, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_div(interval, double precision) is 'implementation of / operator';

alter function pg_catalog.interval_div(interval, double precision) owner to postgres;

create function pg_catalog.dlog10(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dlog10(double precision) is 'base 10 logarithm';

alter function pg_catalog.dlog10(double precision) owner to postgres;

create function pg_catalog.log(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.log(double precision) is 'base 10 logarithm';

alter function pg_catalog.log(double precision) owner to postgres;

create function pg_catalog.ln(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ln(double precision) is 'natural logarithm';

alter function pg_catalog.ln(double precision) owner to postgres;

create function pg_catalog.round(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.round(double precision) is 'round to nearest integer';

alter function pg_catalog.round(double precision) owner to postgres;

create function pg_catalog.trunc(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.trunc(double precision) is 'truncate to integer';

alter function pg_catalog.trunc(double precision) owner to postgres;

create function pg_catalog.sqrt(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.sqrt(double precision) is 'square root';

alter function pg_catalog.sqrt(double precision) owner to postgres;

create function pg_catalog.cbrt(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cbrt(double precision) is 'cube root';

alter function pg_catalog.cbrt(double precision) owner to postgres;

create function pg_catalog.pow(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pow(double precision, double precision) is 'exponentiation';

alter function pg_catalog.pow(double precision, double precision) owner to postgres;

create function pg_catalog.exp(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.exp(double precision) is 'natural exponential (e^x)';

alter function pg_catalog.exp(double precision) owner to postgres;

create function pg_catalog.obj_description(oid) returns text
    stable
    strict
    parallel safe
    language sql
as
$$
select description
from pg_catalog.pg_description
where objoid = $1
  and objsubid = 0
$$;

comment on function pg_catalog.obj_description(oid) is 'deprecated, use two-argument form instead';

alter function pg_catalog.obj_description(oid) owner to postgres;

create function pg_catalog.oidvectortypes(oidvector)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectortypes(oidvector) is 'print type names of oidvector field';

alter function pg_catalog.oidvectortypes(oidvector) owner to postgres;

create function pg_catalog.timetz_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.timetz_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.timetz_out(time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_out(time with time zone) is 'I/O';

alter function pg_catalog.timetz_out(time with time zone) owner to postgres;

create function pg_catalog.timetz_eq(time with time zone, time with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_eq(time with time zone, time with time zone) is 'implementation of = operator';

alter function pg_catalog.timetz_eq(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.timetz_ne(time with time zone, time with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_ne(time with time zone, time with time zone) is 'implementation of <> operator';

alter function pg_catalog.timetz_ne(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.timetz_lt(time with time zone, time with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_lt(time with time zone, time with time zone) is 'implementation of < operator';

alter function pg_catalog.timetz_lt(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.timetz_le(time with time zone, time with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_le(time with time zone, time with time zone) is 'implementation of <= operator';

alter function pg_catalog.timetz_le(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.timetz_ge(time with time zone, time with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_ge(time with time zone, time with time zone) is 'implementation of >= operator';

alter function pg_catalog.timetz_ge(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.timetz_gt(time with time zone, time with time zone)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_gt(time with time zone, time with time zone) is 'implementation of > operator';

alter function pg_catalog.timetz_gt(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.timetz_cmp(time with time zone, time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_cmp(time with time zone, time with time zone) is 'less-equal-greater';

alter function pg_catalog.timetz_cmp(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.timestamptz(date, time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz(date, time with time zone) is 'convert date and time with time zone to timestamp with time zone';

alter function pg_catalog.timestamptz(date, time with time zone) owner to postgres;

create function pg_catalog.hostmask(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hostmask(inet) is 'hostmask of address';

alter function pg_catalog.hostmask(inet) owner to postgres;

create function pg_catalog.time(abstime) returns time without time zone
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select cast(cast($1 as timestamp without time zone) as pg_catalog.time)
$$;

comment on function pg_catalog.time(abstime) is 'convert abstime to time';

alter function pg_catalog.time(abstime) owner to postgres;

create function pg_catalog.makeaclitem(oid, oid, text, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.makeaclitem(oid, oid, text, boolean) is 'make ACL item';

alter function pg_catalog.makeaclitem(oid, oid, text, boolean) owner to postgres;

create function pg_catalog.character_length(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.character_length(char) is 'character length';

alter function pg_catalog.character_length(char) owner to postgres;

create function pg_catalog.power(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.power(double precision, double precision) is 'exponentiation';

alter function pg_catalog.power(double precision, double precision) owner to postgres;

create function pg_catalog.character_length(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.character_length(text) is 'character length';

alter function pg_catalog.character_length(text) owner to postgres;

create function pg_catalog.interval(time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval(time) is 'convert time to interval';

alter function pg_catalog.interval(time) owner to postgres;

create function pg_catalog.pg_lock_status(out locktype text, out database oid, out relation oid, out page integer,
                                          out tuple smallint, out virtualxid text, out transactionid xid,
                                          out classid oid, out objid oid, out objsubid smallint,
                                          out virtualtransaction text, out pid integer, out mode text,
                                          out granted boolean, out fastpath boolean)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lock_status(out text, out oid, out oid, out integer, out smallint, out text, out xid, out oid, out oid, out smallint, out text, out integer, out text, out boolean, out boolean) is 'view system lock information';

alter function pg_catalog.pg_lock_status(out text, out oid, out oid, out integer, out smallint, out text, out xid, out oid, out oid, out smallint, out text, out integer, out text, out boolean, out boolean) owner to postgres;

create function pg_catalog.char_length(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.char_length(char) is 'character length';

alter function pg_catalog.char_length(char) owner to postgres;

create function pg_catalog.isfinite(date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isfinite(date) is 'finite date?';

alter function pg_catalog.isfinite(date) owner to postgres;

create function pg_catalog.octet_length(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.octet_length(text) is 'octet length';

alter function pg_catalog.octet_length(text) owner to postgres;

create function pg_catalog.octet_length(char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.octet_length(char) is 'octet length';

alter function pg_catalog.octet_length(char) owner to postgres;

create function pg_catalog.factorial(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.factorial(bigint) is 'factorial';

alter function pg_catalog.factorial(bigint) owner to postgres;

create function pg_catalog.time_larger(time, time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_larger(time, time) is 'larger of two';

alter function pg_catalog.time_larger(time, time) owner to postgres;

create function pg_catalog.time_smaller(time, time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_smaller(time, time) is 'smaller of two';

alter function pg_catalog.time_smaller(time, time) owner to postgres;

create function pg_catalog.timetz_larger(time with time zone, time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_larger(time with time zone, time with time zone) is 'larger of two';

alter function pg_catalog.timetz_larger(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.timetz_smaller(time with time zone, time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_smaller(time with time zone, time with time zone) is 'smaller of two';

alter function pg_catalog.timetz_smaller(time with time zone, time with time zone) owner to postgres;

create function pg_catalog.char_length(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.char_length(text) is 'character length';

alter function pg_catalog.char_length(text) owner to postgres;

create function pg_catalog.date_part(text, abstime) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.date_part($1, cast($2 as timestamp with time zone))
$$;

comment on function pg_catalog.date_part(text, abstime) is 'extract field from abstime';

alter function pg_catalog.date_part(text, abstime) owner to postgres;

create function pg_catalog.date_part(text, reltime) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.date_part($1, cast($2 as pg_catalog.interval))
$$;

comment on function pg_catalog.date_part(text, reltime) is 'extract field from reltime';

alter function pg_catalog.date_part(text, reltime) owner to postgres;

create function pg_catalog.date_part(text, date) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.date_part($1, cast($2 as timestamp without time zone))
$$;

comment on function pg_catalog.date_part(text, date) is 'extract field from date';

alter function pg_catalog.date_part(text, date) owner to postgres;

create function pg_catalog.date_part(text, time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_part(text, time) is 'extract field from time';

alter function pg_catalog.date_part(text, time) owner to postgres;

create function pg_catalog.age(timestamp with time zone) returns interval
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.age(cast(current_date as timestamp with time zone), $1)
$$;

comment on function pg_catalog.age(timestamp with time zone) is 'date difference from today preserving months and years';

alter function pg_catalog.age(timestamp with time zone) owner to postgres;

create function pg_catalog.pg_get_constraintdef(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_constraintdef(oid) is 'constraint description';

alter function pg_catalog.pg_get_constraintdef(oid) owner to postgres;

create function pg_catalog.timetz(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz(timestamp with time zone) is 'convert timestamp with time zone to time with time zone';

alter function pg_catalog.timetz(timestamp with time zone) owner to postgres;

create function pg_catalog.isfinite(timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isfinite(timestamp with time zone) is 'finite timestamp?';

alter function pg_catalog.isfinite(timestamp with time zone) owner to postgres;

create function pg_catalog.isfinite(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isfinite(interval) is 'finite interval?';

alter function pg_catalog.isfinite(interval) owner to postgres;

create function pg_catalog.pg_stat_get_backend_start(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_start(integer) is 'statistics: start time for current backend session';

alter function pg_catalog.pg_stat_get_backend_start(integer) owner to postgres;

create function pg_catalog.pg_stat_get_backend_client_addr(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_client_addr(integer) is 'statistics: address of client connected to backend';

alter function pg_catalog.pg_stat_get_backend_client_addr(integer) owner to postgres;

create function pg_catalog.pg_stat_get_backend_client_port(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_client_port(integer) is 'statistics: port number of client connected to backend';

alter function pg_catalog.pg_stat_get_backend_client_port(integer) owner to postgres;

create function pg_catalog.abs(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abs(real) is 'absolute value';

alter function pg_catalog.abs(real) owner to postgres;

create function pg_catalog.abs(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abs(double precision) is 'absolute value';

alter function pg_catalog.abs(double precision) owner to postgres;

create function pg_catalog.abs(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abs(bigint) is 'absolute value';

alter function pg_catalog.abs(bigint) owner to postgres;

create function pg_catalog.abs(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abs(integer) is 'absolute value';

alter function pg_catalog.abs(integer) owner to postgres;

create function pg_catalog.abs(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abs(smallint) is 'absolute value';

alter function pg_catalog.abs(smallint) owner to postgres;

create function pg_catalog.name(varchar)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.name(varchar) is 'convert varchar to name';

alter function pg_catalog.name(varchar) owner to postgres;

create function pg_catalog.varchar(name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varchar(name) is 'convert name to varchar';

alter function pg_catalog.varchar(name) owner to postgres;

create function pg_catalog."current_schema"()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."current_schema"() is 'current schema name';

alter function pg_catalog."current_schema"() owner to postgres;

create function pg_catalog.current_schemas(boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.current_schemas(boolean) is 'current schema search list';

alter function pg_catalog.current_schemas(boolean) owner to postgres;

create function pg_catalog.overlay(text, text, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.overlay(text, text, integer, integer) is 'substitute portion of string';

alter function pg_catalog.overlay(text, text, integer, integer) owner to postgres;

create function pg_catalog.overlay(text, text, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.overlay(text, text, integer) is 'substitute portion of string';

alter function pg_catalog.overlay(text, text, integer) owner to postgres;

create function pg_catalog.isvertical(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isvertical(point, point) is 'vertically aligned';

alter function pg_catalog.isvertical(point, point) owner to postgres;

create function pg_catalog.ishorizontal(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ishorizontal(point, point) is 'horizontally aligned';

alter function pg_catalog.ishorizontal(point, point) owner to postgres;

create function pg_catalog.isparallel(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isparallel(lseg, lseg) is 'parallel';

alter function pg_catalog.isparallel(lseg, lseg) owner to postgres;

create function pg_catalog.isperp(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isperp(lseg, lseg) is 'perpendicular';

alter function pg_catalog.isperp(lseg, lseg) owner to postgres;

create function pg_catalog.isvertical(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isvertical(lseg) is 'vertical';

alter function pg_catalog.isvertical(lseg) owner to postgres;

create function pg_catalog.ishorizontal(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ishorizontal(lseg) is 'horizontal';

alter function pg_catalog.ishorizontal(lseg) owner to postgres;

create function pg_catalog.isparallel(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isparallel(line, line) is 'parallel';

alter function pg_catalog.isparallel(line, line) owner to postgres;

create function pg_catalog.isperp(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isperp(line, line) is 'perpendicular';

alter function pg_catalog.isperp(line, line) owner to postgres;

create function pg_catalog.isvertical(line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isvertical(line) is 'vertical';

alter function pg_catalog.isvertical(line) owner to postgres;

create function pg_catalog.ishorizontal(line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ishorizontal(line) is 'horizontal';

alter function pg_catalog.ishorizontal(line) owner to postgres;

create function pg_catalog.point(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point(circle) is 'center of';

alter function pg_catalog.point(circle) owner to postgres;

create function pg_catalog.time(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time(interval) is 'convert interval to time';

alter function pg_catalog.time(interval) owner to postgres;

create function pg_catalog.box(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box(point, point) is 'convert points to box';

alter function pg_catalog.box(point, point) owner to postgres;

create function pg_catalog.box_add(box, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_add(box, point) is 'implementation of + operator';

alter function pg_catalog.box_add(box, point) owner to postgres;

create function pg_catalog.box_sub(box, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_sub(box, point) is 'implementation of - operator';

alter function pg_catalog.box_sub(box, point) owner to postgres;

create function pg_catalog.box_mul(box, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_mul(box, point) is 'implementation of * operator';

alter function pg_catalog.box_mul(box, point) owner to postgres;

create function pg_catalog.box_div(box, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_div(box, point) is 'implementation of / operator';

alter function pg_catalog.box_div(box, point) owner to postgres;

create function pg_catalog.path_contain_pt(path, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.on_ppath($2, $1)
$$;

comment on function pg_catalog.path_contain_pt(path, point) is 'implementation of @> operator';

alter function pg_catalog.path_contain_pt(path, point) owner to postgres;

create function pg_catalog.cidr_out(cidr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidr_out(cidr) is 'I/O';

alter function pg_catalog.cidr_out(cidr) owner to postgres;

create function pg_catalog.poly_contain_pt(polygon, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_contain_pt(polygon, point) is 'implementation of @> operator';

alter function pg_catalog.poly_contain_pt(polygon, point) owner to postgres;

create function pg_catalog.pt_contained_poly(point, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pt_contained_poly(point, polygon) is 'implementation of <@ operator';

alter function pg_catalog.pt_contained_poly(point, polygon) owner to postgres;

create function pg_catalog.isclosed(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isclosed(path) is 'path closed?';

alter function pg_catalog.isclosed(path) owner to postgres;

create function pg_catalog.isopen(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isopen(path) is 'path open?';

alter function pg_catalog.isopen(path) owner to postgres;

create function pg_catalog.path_npoints(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_npoints(path) is 'implementation of # operator';

alter function pg_catalog.path_npoints(path) owner to postgres;

create function pg_catalog.pclose(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pclose(path) is 'close path';

alter function pg_catalog.pclose(path) owner to postgres;

create function pg_catalog.popen(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.popen(path) is 'open path';

alter function pg_catalog.popen(path) owner to postgres;

create function pg_catalog.path_add(path, path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_add(path, path) is 'implementation of + operator';

alter function pg_catalog.path_add(path, path) owner to postgres;

create function pg_catalog.path_add_pt(path, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_add_pt(path, point) is 'implementation of + operator';

alter function pg_catalog.path_add_pt(path, point) owner to postgres;

create function pg_catalog.path_sub_pt(path, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_sub_pt(path, point) is 'implementation of - operator';

alter function pg_catalog.path_sub_pt(path, point) owner to postgres;

create function pg_catalog.path_mul_pt(path, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_mul_pt(path, point) is 'implementation of * operator';

alter function pg_catalog.path_mul_pt(path, point) owner to postgres;

create function pg_catalog.path_div_pt(path, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_div_pt(path, point) is 'implementation of / operator';

alter function pg_catalog.path_div_pt(path, point) owner to postgres;

create function pg_catalog.point(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point(double precision, double precision) is 'convert x, y to point';

alter function pg_catalog.point(double precision, double precision) owner to postgres;

create function pg_catalog.point_add(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_add(point, point) is 'implementation of + operator';

alter function pg_catalog.point_add(point, point) owner to postgres;

create function pg_catalog.point_sub(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_sub(point, point) is 'implementation of - operator';

alter function pg_catalog.point_sub(point, point) owner to postgres;

create function pg_catalog.point_mul(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_mul(point, point) is 'implementation of * operator';

alter function pg_catalog.point_mul(point, point) owner to postgres;

create function pg_catalog.point_div(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_div(point, point) is 'implementation of / operator';

alter function pg_catalog.point_div(point, point) owner to postgres;

create function pg_catalog.poly_npoints(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_npoints(polygon) is 'implementation of # operator';

alter function pg_catalog.poly_npoints(polygon) owner to postgres;

create function pg_catalog.box(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box(polygon) is 'convert polygon to bounding box';

alter function pg_catalog.box(polygon) owner to postgres;

create function pg_catalog.path(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path(polygon) is 'convert polygon to path';

alter function pg_catalog.path(polygon) owner to postgres;

create function pg_catalog.polygon(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.polygon(box) is 'convert box to polygon';

alter function pg_catalog.polygon(box) owner to postgres;

create function pg_catalog.polygon(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.polygon(path) is 'convert path to polygon';

alter function pg_catalog.polygon(path) owner to postgres;

create function pg_catalog.circle_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_in(cstring) is 'I/O';

alter function pg_catalog.circle_in(cstring) owner to postgres;

create function pg_catalog.circle_out(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_out(circle) is 'I/O';

alter function pg_catalog.circle_out(circle) owner to postgres;

create function pg_catalog.circle_same(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_same(circle, circle) is 'implementation of ~= operator';

alter function pg_catalog.circle_same(circle, circle) owner to postgres;

create function pg_catalog.circle_contain(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_contain(circle, circle) is 'implementation of @> operator';

alter function pg_catalog.circle_contain(circle, circle) owner to postgres;

create function pg_catalog.circle_left(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_left(circle, circle) is 'implementation of << operator';

alter function pg_catalog.circle_left(circle, circle) owner to postgres;

create function pg_catalog.circle_overleft(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_overleft(circle, circle) is 'implementation of &< operator';

alter function pg_catalog.circle_overleft(circle, circle) owner to postgres;

create function pg_catalog.circle_overright(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_overright(circle, circle) is 'implementation of &> operator';

alter function pg_catalog.circle_overright(circle, circle) owner to postgres;

create function pg_catalog.circle_right(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_right(circle, circle) is 'implementation of >> operator';

alter function pg_catalog.circle_right(circle, circle) owner to postgres;

create function pg_catalog.circle_contained(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_contained(circle, circle) is 'implementation of <@ operator';

alter function pg_catalog.circle_contained(circle, circle) owner to postgres;

create function pg_catalog.circle_overlap(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_overlap(circle, circle) is 'implementation of && operator';

alter function pg_catalog.circle_overlap(circle, circle) owner to postgres;

create function pg_catalog.circle_below(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_below(circle, circle) is 'implementation of <<| operator';

alter function pg_catalog.circle_below(circle, circle) owner to postgres;

create function pg_catalog.circle_above(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_above(circle, circle) is 'implementation of |>> operator';

alter function pg_catalog.circle_above(circle, circle) owner to postgres;

create function pg_catalog.circle_eq(circle, circle)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_eq(circle, circle) is 'implementation of = operator';

alter function pg_catalog.circle_eq(circle, circle) owner to postgres;

create function pg_catalog.circle_ne(circle, circle)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_ne(circle, circle) is 'implementation of <> operator';

alter function pg_catalog.circle_ne(circle, circle) owner to postgres;

create function pg_catalog.circle_lt(circle, circle)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_lt(circle, circle) is 'implementation of < operator';

alter function pg_catalog.circle_lt(circle, circle) owner to postgres;

create function pg_catalog.circle_gt(circle, circle)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_gt(circle, circle) is 'implementation of > operator';

alter function pg_catalog.circle_gt(circle, circle) owner to postgres;

create function pg_catalog.circle_le(circle, circle)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_le(circle, circle) is 'implementation of <= operator';

alter function pg_catalog.circle_le(circle, circle) owner to postgres;

create function pg_catalog.circle_ge(circle, circle)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_ge(circle, circle) is 'implementation of >= operator';

alter function pg_catalog.circle_ge(circle, circle) owner to postgres;

create function pg_catalog.area(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.area(circle) is 'area of circle';

alter function pg_catalog.area(circle) owner to postgres;

create function pg_catalog.diameter(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.diameter(circle) is 'diameter of circle';

alter function pg_catalog.diameter(circle) owner to postgres;

create function pg_catalog.radius(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.radius(circle) is 'radius of circle';

alter function pg_catalog.radius(circle) owner to postgres;

create function pg_catalog.circle_distance(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_distance(circle, circle) is 'implementation of <-> operator';

alter function pg_catalog.circle_distance(circle, circle) owner to postgres;

create function pg_catalog.circle_center(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_center(circle) is 'implementation of @@ operator';

alter function pg_catalog.circle_center(circle) owner to postgres;

create function pg_catalog.circle(point, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle(point, double precision) is 'convert point and radius to circle';

alter function pg_catalog.circle(point, double precision) owner to postgres;

create function pg_catalog.circle(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle(polygon) is 'convert polygon to circle';

alter function pg_catalog.circle(polygon) owner to postgres;

create function pg_catalog.polygon(integer, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.polygon(integer, circle) is 'convert vertex count and circle to polygon';

alter function pg_catalog.polygon(integer, circle) owner to postgres;

create function pg_catalog.dist_pc(point, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_pc(point, circle) is 'implementation of <-> operator';

alter function pg_catalog.dist_pc(point, circle) owner to postgres;

create function pg_catalog.circle_contain_pt(circle, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_contain_pt(circle, point) is 'implementation of @> operator';

alter function pg_catalog.circle_contain_pt(circle, point) owner to postgres;

create function pg_catalog.pt_contained_circle(point, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pt_contained_circle(point, circle) is 'implementation of <@ operator';

alter function pg_catalog.pt_contained_circle(point, circle) owner to postgres;

create function pg_catalog.circle(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle(box) is 'convert box to circle';

alter function pg_catalog.circle(box) owner to postgres;

create function pg_catalog.box(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box(circle) is 'convert circle to box';

alter function pg_catalog.box(circle) owner to postgres;

create function pg_catalog.tinterval(abstime, abstime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tinterval(abstime, abstime) is 'convert to tinterval';

alter function pg_catalog.tinterval(abstime, abstime) owner to postgres;

create function pg_catalog.lseg_ne(lseg, lseg)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_ne(lseg, lseg) is 'implementation of <> operator';

alter function pg_catalog.lseg_ne(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_lt(lseg, lseg)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_lt(lseg, lseg) is 'implementation of < operator';

alter function pg_catalog.lseg_lt(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_le(lseg, lseg)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_le(lseg, lseg) is 'implementation of <= operator';

alter function pg_catalog.lseg_le(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_gt(lseg, lseg)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_gt(lseg, lseg) is 'implementation of > operator';

alter function pg_catalog.lseg_gt(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_ge(lseg, lseg)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_ge(lseg, lseg) is 'implementation of >= operator';

alter function pg_catalog.lseg_ge(lseg, lseg) owner to postgres;

create function pg_catalog.lseg_length(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_length(lseg) is 'implementation of @-@ operator';

alter function pg_catalog.lseg_length(lseg) owner to postgres;

create function pg_catalog.close_ls(line, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.close_ls(line, lseg) is 'implementation of ## operator';

alter function pg_catalog.close_ls(line, lseg) owner to postgres;

create function pg_catalog.close_lseg(lseg, lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.close_lseg(lseg, lseg) is 'implementation of ## operator';

alter function pg_catalog.close_lseg(lseg, lseg) owner to postgres;

create function pg_catalog.line_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_in(cstring) is 'I/O';

alter function pg_catalog.line_in(cstring) owner to postgres;

create function pg_catalog.line_out(line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_out(line) is 'I/O';

alter function pg_catalog.line_out(line) owner to postgres;

create function pg_catalog.line_eq(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_eq(line, line) is 'implementation of = operator';

alter function pg_catalog.line_eq(line, line) owner to postgres;

create function pg_catalog.line(point, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line(point, point) is 'construct line from points';

alter function pg_catalog.line(point, point) owner to postgres;

create function pg_catalog.line_interpt(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_interpt(line, line) is 'implementation of # operator';

alter function pg_catalog.line_interpt(line, line) owner to postgres;

create function pg_catalog.line_intersect(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_intersect(line, line) is 'implementation of ?# operator';

alter function pg_catalog.line_intersect(line, line) owner to postgres;

create function pg_catalog.line_parallel(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_parallel(line, line) is 'implementation of ?|| operator';

alter function pg_catalog.line_parallel(line, line) owner to postgres;

create function pg_catalog.line_perp(line, line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_perp(line, line) is 'implementation of ?-| operator';

alter function pg_catalog.line_perp(line, line) owner to postgres;

create function pg_catalog.line_vertical(line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_vertical(line) is 'implementation of ?| operator';

alter function pg_catalog.line_vertical(line) owner to postgres;

create function pg_catalog.line_horizontal(line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_horizontal(line) is 'implementation of ?- operator';

alter function pg_catalog.line_horizontal(line) owner to postgres;

create function pg_catalog.length(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.length(lseg) is 'distance between endpoints';

alter function pg_catalog.length(lseg) owner to postgres;

create function pg_catalog.length(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.length(path) is 'sum of path segments';

alter function pg_catalog.length(path) owner to postgres;

create function pg_catalog.point(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point(lseg) is 'center of';

alter function pg_catalog.point(lseg) owner to postgres;

create function pg_catalog.point(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point(path) is 'center of';

alter function pg_catalog.point(path) owner to postgres;

create function pg_catalog.point(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point(box) is 'center of';

alter function pg_catalog.point(box) owner to postgres;

create function pg_catalog.point(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point(polygon) is 'center of';

alter function pg_catalog.point(polygon) owner to postgres;

create function pg_catalog.lseg(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg(box) is 'diagonal of';

alter function pg_catalog.lseg(box) owner to postgres;

create function pg_catalog.center(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.center(box) is 'center of';

alter function pg_catalog.center(box) owner to postgres;

create function pg_catalog.center(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.center(circle) is 'center of';

alter function pg_catalog.center(circle) owner to postgres;

create function pg_catalog.polygon(circle) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.polygon(12, $1)
$$;

comment on function pg_catalog.polygon(circle) is 'convert circle to 12-vertex polygon';

alter function pg_catalog.polygon(circle) owner to postgres;

create function pg_catalog.npoints(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.npoints(path) is 'number of points';

alter function pg_catalog.npoints(path) owner to postgres;

create function pg_catalog.npoints(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.npoints(polygon) is 'number of points';

alter function pg_catalog.npoints(polygon) owner to postgres;

create function pg_catalog.bit_in(cstring, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bit_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.bit_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.bit_out(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bit_out(bit) is 'I/O';

alter function pg_catalog.bit_out(bit) owner to postgres;

create function pg_catalog."like"(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."like"(text, text) is 'matches LIKE expression';

alter function pg_catalog."like"(text, text) owner to postgres;

create function pg_catalog.notlike(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.notlike(text, text) is 'does not match LIKE expression';

alter function pg_catalog.notlike(text, text) owner to postgres;

create function pg_catalog."like"(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."like"(name, text) is 'matches LIKE expression';

alter function pg_catalog."like"(name, text) owner to postgres;

create function pg_catalog.notlike(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.notlike(name, text) is 'does not match LIKE expression';

alter function pg_catalog.notlike(name, text) owner to postgres;

create function pg_catalog.pg_get_ruledef(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_ruledef(oid) is 'source text of a rule';

alter function pg_catalog.pg_get_ruledef(oid) owner to postgres;

create function pg_catalog.nextval(regclass)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nextval(regclass) is 'sequence next value';

alter function pg_catalog.nextval(regclass) owner to postgres;

create function pg_catalog.currval(regclass)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.currval(regclass) is 'sequence current value';

alter function pg_catalog.currval(regclass) owner to postgres;

create function pg_catalog.setval(regclass, bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.setval(regclass, bigint) is 'set sequence value';

alter function pg_catalog.setval(regclass, bigint) owner to postgres;

create function pg_catalog.varbit_in(cstring, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbit_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.varbit_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.varbit_out(bit varying)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbit_out(bit varying) is 'I/O';

alter function pg_catalog.varbit_out(bit varying) owner to postgres;

create function pg_catalog.biteq(bit, bit)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.biteq(bit, bit) is 'implementation of = operator';

alter function pg_catalog.biteq(bit, bit) owner to postgres;

create function pg_catalog.bitne(bit, bit)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitne(bit, bit) is 'implementation of <> operator';

alter function pg_catalog.bitne(bit, bit) owner to postgres;

create function pg_catalog.bitge(bit, bit)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitge(bit, bit) is 'implementation of >= operator';

alter function pg_catalog.bitge(bit, bit) owner to postgres;

create function pg_catalog.bitgt(bit, bit)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitgt(bit, bit) is 'implementation of > operator';

alter function pg_catalog.bitgt(bit, bit) owner to postgres;

create function pg_catalog.bitle(bit, bit)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitle(bit, bit) is 'implementation of <= operator';

alter function pg_catalog.bitle(bit, bit) owner to postgres;

create function pg_catalog.bitlt(bit, bit)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitlt(bit, bit) is 'implementation of < operator';

alter function pg_catalog.bitlt(bit, bit) owner to postgres;

create function pg_catalog.bitcmp(bit, bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitcmp(bit, bit) is 'less-equal-greater';

alter function pg_catalog.bitcmp(bit, bit) owner to postgres;

create function pg_catalog.pg_encoding_to_char(integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_encoding_to_char(integer) is 'convert encoding id to encoding name';

alter function pg_catalog.pg_encoding_to_char(integer) owner to postgres;

create function pg_catalog.random()
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.random() is 'random value';

alter function pg_catalog.random() owner to postgres;

create function pg_catalog.setseed(double precision)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.setseed(double precision) is 'set random seed';

alter function pg_catalog.setseed(double precision) owner to postgres;

create function pg_catalog.asin(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.asin(double precision) is 'arcsine';

alter function pg_catalog.asin(double precision) owner to postgres;

create function pg_catalog.acos(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.acos(double precision) is 'arccosine';

alter function pg_catalog.acos(double precision) owner to postgres;

create function pg_catalog.atan(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.atan(double precision) is 'arctangent';

alter function pg_catalog.atan(double precision) owner to postgres;

create function pg_catalog.atan2(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.atan2(double precision, double precision) is 'arctangent, two arguments';

alter function pg_catalog.atan2(double precision, double precision) owner to postgres;

create function pg_catalog.sin(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.sin(double precision) is 'sine';

alter function pg_catalog.sin(double precision) owner to postgres;

create function pg_catalog.cos(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cos(double precision) is 'cosine';

alter function pg_catalog.cos(double precision) owner to postgres;

create function pg_catalog.tan(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tan(double precision) is 'tangent';

alter function pg_catalog.tan(double precision) owner to postgres;

create function pg_catalog.cot(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cot(double precision) is 'cotangent';

alter function pg_catalog.cot(double precision) owner to postgres;

create function pg_catalog.degrees(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.degrees(double precision) is 'radians to degrees';

alter function pg_catalog.degrees(double precision) owner to postgres;

create function pg_catalog.radians(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.radians(double precision) is 'degrees to radians';

alter function pg_catalog.radians(double precision) owner to postgres;

create function pg_catalog.pi()
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pi() is 'PI';

alter function pg_catalog.pi() owner to postgres;

create function pg_catalog.interval_mul(interval, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_mul(interval, double precision) is 'implementation of * operator';

alter function pg_catalog.interval_mul(interval, double precision) owner to postgres;

create function pg_catalog.pg_typeof("any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_typeof("any") is 'type of the argument';

alter function pg_catalog.pg_typeof("any") owner to postgres;

create function pg_catalog.ascii(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ascii(text) is 'convert first char to int4';

alter function pg_catalog.ascii(text) owner to postgres;

create function pg_catalog.chr(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.chr(integer) is 'convert int4 to char';

alter function pg_catalog.chr(integer) owner to postgres;

create function pg_catalog.repeat(text, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.repeat(text, integer) is 'replicate string n times';

alter function pg_catalog.repeat(text, integer) owner to postgres;

create function pg_catalog.similar_escape(text, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.similar_escape(text, text) is 'convert SQL99 regexp pattern to POSIX style';

alter function pg_catalog.similar_escape(text, text) owner to postgres;

create function pg_catalog.mul_d_interval(double precision, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.mul_d_interval(double precision, interval) is 'implementation of * operator';

alter function pg_catalog.mul_d_interval(double precision, interval) owner to postgres;

create function pg_catalog.bpcharlike(char, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharlike(char, text) is 'implementation of ~~ operator';

alter function pg_catalog.bpcharlike(char, text) owner to postgres;

create function pg_catalog.bpcharnlike(char, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharnlike(char, text) is 'implementation of !~~ operator';

alter function pg_catalog.bpcharnlike(char, text) owner to postgres;

create function pg_catalog.texticlike(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.texticlike(text, text) is 'implementation of ~~* operator';

alter function pg_catalog.texticlike(text, text) owner to postgres;

create function pg_catalog.texticnlike(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.texticnlike(text, text) is 'implementation of !~~* operator';

alter function pg_catalog.texticnlike(text, text) owner to postgres;

create function pg_catalog.nameiclike(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nameiclike(name, text) is 'implementation of ~~* operator';

alter function pg_catalog.nameiclike(name, text) owner to postgres;

create function pg_catalog.nameicnlike(name, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nameicnlike(name, text) is 'implementation of !~~* operator';

alter function pg_catalog.nameicnlike(name, text) owner to postgres;

create function pg_catalog.like_escape(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.like_escape(text, text) is 'convert LIKE pattern to use backslash escapes';

alter function pg_catalog.like_escape(text, text) owner to postgres;

create function pg_catalog.oidgt(oid, oid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidgt(oid, oid) is 'implementation of > operator';

alter function pg_catalog.oidgt(oid, oid) owner to postgres;

create function pg_catalog.oidge(oid, oid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidge(oid, oid) is 'implementation of >= operator';

alter function pg_catalog.oidge(oid, oid) owner to postgres;

create function pg_catalog.pg_get_viewdef(text)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_viewdef(text) is 'select statement of a view';

alter function pg_catalog.pg_get_viewdef(text) owner to postgres;

create function pg_catalog.pg_get_viewdef(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_viewdef(oid) is 'select statement of a view';

alter function pg_catalog.pg_get_viewdef(oid) owner to postgres;

create function pg_catalog.pg_get_userbyid(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_userbyid(oid) is 'role name by OID (with fallback)';

alter function pg_catalog.pg_get_userbyid(oid) owner to postgres;

create function pg_catalog.pg_get_indexdef(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_indexdef(oid) is 'index description';

alter function pg_catalog.pg_get_indexdef(oid) owner to postgres;

create function pg_catalog."RI_FKey_check_ins"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_check_ins"() is 'referential integrity FOREIGN KEY ... REFERENCES';

alter function pg_catalog."RI_FKey_check_ins"() owner to postgres;

create function pg_catalog."RI_FKey_check_upd"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_check_upd"() is 'referential integrity FOREIGN KEY ... REFERENCES';

alter function pg_catalog."RI_FKey_check_upd"() owner to postgres;

create function pg_catalog."RI_FKey_cascade_del"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_cascade_del"() is 'referential integrity ON DELETE CASCADE';

alter function pg_catalog."RI_FKey_cascade_del"() owner to postgres;

create function pg_catalog."RI_FKey_cascade_upd"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_cascade_upd"() is 'referential integrity ON UPDATE CASCADE';

alter function pg_catalog."RI_FKey_cascade_upd"() owner to postgres;

create function pg_catalog."RI_FKey_restrict_del"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_restrict_del"() is 'referential integrity ON DELETE RESTRICT';

alter function pg_catalog."RI_FKey_restrict_del"() owner to postgres;

create function pg_catalog."RI_FKey_restrict_upd"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_restrict_upd"() is 'referential integrity ON UPDATE RESTRICT';

alter function pg_catalog."RI_FKey_restrict_upd"() owner to postgres;

create function pg_catalog."RI_FKey_setnull_del"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_setnull_del"() is 'referential integrity ON DELETE SET NULL';

alter function pg_catalog."RI_FKey_setnull_del"() owner to postgres;

create function pg_catalog."RI_FKey_setnull_upd"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_setnull_upd"() is 'referential integrity ON UPDATE SET NULL';

alter function pg_catalog."RI_FKey_setnull_upd"() owner to postgres;

create function pg_catalog."RI_FKey_setdefault_del"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_setdefault_del"() is 'referential integrity ON DELETE SET DEFAULT';

alter function pg_catalog."RI_FKey_setdefault_del"() owner to postgres;

create function pg_catalog."RI_FKey_setdefault_upd"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_setdefault_upd"() is 'referential integrity ON UPDATE SET DEFAULT';

alter function pg_catalog."RI_FKey_setdefault_upd"() owner to postgres;

create function pg_catalog."RI_FKey_noaction_del"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_noaction_del"() is 'referential integrity ON DELETE NO ACTION';

alter function pg_catalog."RI_FKey_noaction_del"() owner to postgres;

create function pg_catalog."RI_FKey_noaction_upd"()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."RI_FKey_noaction_upd"() is 'referential integrity ON UPDATE NO ACTION';

alter function pg_catalog."RI_FKey_noaction_upd"() owner to postgres;

create function pg_catalog.bpcharicregexeq(char, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharicregexeq(char, text) is 'implementation of ~* operator';

alter function pg_catalog.bpcharicregexeq(char, text) owner to postgres;

create function pg_catalog.bpcharicregexne(char, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharicregexne(char, text) is 'implementation of !~* operator';

alter function pg_catalog.bpcharicregexne(char, text) owner to postgres;

create function pg_catalog.bpcharregexeq(char, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharregexeq(char, text) is 'implementation of ~ operator';

alter function pg_catalog.bpcharregexeq(char, text) owner to postgres;

create function pg_catalog.bpcharregexne(char, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharregexne(char, text) is 'implementation of !~ operator';

alter function pg_catalog.bpcharregexne(char, text) owner to postgres;

create function pg_catalog.bpchariclike(char, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchariclike(char, text) is 'implementation of ~~* operator';

alter function pg_catalog.bpchariclike(char, text) owner to postgres;

create function pg_catalog.bpcharicnlike(char, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharicnlike(char, text) is 'implementation of !~~* operator';

alter function pg_catalog.bpcharicnlike(char, text) owner to postgres;

create function pg_catalog.pg_get_triggerdef(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_triggerdef(oid) is 'trigger description';

alter function pg_catalog.pg_get_triggerdef(oid) owner to postgres;

create function pg_catalog.pg_get_serial_sequence(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_serial_sequence(text, text) is 'name of sequence for a serial column';

alter function pg_catalog.pg_get_serial_sequence(text, text) owner to postgres;

create function pg_catalog.varbiteq(bit varying, bit varying)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbiteq(bit varying, bit varying) is 'implementation of = operator';

alter function pg_catalog.varbiteq(bit varying, bit varying) owner to postgres;

create function pg_catalog.varbitne(bit varying, bit varying)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbitne(bit varying, bit varying) is 'implementation of <> operator';

alter function pg_catalog.varbitne(bit varying, bit varying) owner to postgres;

create function pg_catalog.varbitge(bit varying, bit varying)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbitge(bit varying, bit varying) is 'implementation of >= operator';

alter function pg_catalog.varbitge(bit varying, bit varying) owner to postgres;

create function pg_catalog.varbitgt(bit varying, bit varying)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbitgt(bit varying, bit varying) is 'implementation of > operator';

alter function pg_catalog.varbitgt(bit varying, bit varying) owner to postgres;

create function pg_catalog.varbitle(bit varying, bit varying)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbitle(bit varying, bit varying) is 'implementation of <= operator';

alter function pg_catalog.varbitle(bit varying, bit varying) owner to postgres;

create function pg_catalog.varbitlt(bit varying, bit varying)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbitlt(bit varying, bit varying) is 'implementation of < operator';

alter function pg_catalog.varbitlt(bit varying, bit varying) owner to postgres;

create function pg_catalog.varbitcmp(bit varying, bit varying)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbitcmp(bit varying, bit varying) is 'less-equal-greater';

alter function pg_catalog.varbitcmp(bit varying, bit varying) owner to postgres;

create function pg_catalog.bitand(bit, bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitand(bit, bit) is 'implementation of & operator';

alter function pg_catalog.bitand(bit, bit) owner to postgres;

create function pg_catalog.bitor(bit, bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitor(bit, bit) is 'implementation of | operator';

alter function pg_catalog.bitor(bit, bit) owner to postgres;

create function pg_catalog.bitxor(bit, bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitxor(bit, bit) is 'implementation of # operator';

alter function pg_catalog.bitxor(bit, bit) owner to postgres;

create function pg_catalog.bitnot(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitnot(bit) is 'implementation of ~ operator';

alter function pg_catalog.bitnot(bit) owner to postgres;

create function pg_catalog.bitshiftleft(bit, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitshiftleft(bit, integer) is 'implementation of << operator';

alter function pg_catalog.bitshiftleft(bit, integer) owner to postgres;

create function pg_catalog.bitshiftright(bit, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitshiftright(bit, integer) is 'implementation of >> operator';

alter function pg_catalog.bitshiftright(bit, integer) owner to postgres;

create function pg_catalog.bitcat(bit varying, bit varying)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bitcat(bit varying, bit varying) is 'implementation of || operator';

alter function pg_catalog.bitcat(bit varying, bit varying) owner to postgres;

create function pg_catalog.substring(bit, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substring(bit, integer, integer) is 'extract portion of bitstring';

alter function pg_catalog.substring(bit, integer, integer) owner to postgres;

create function pg_catalog.length(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.length(bit) is 'bitstring length';

alter function pg_catalog.length(bit) owner to postgres;

create function pg_catalog.octet_length(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.octet_length(bit) is 'octet length';

alter function pg_catalog.octet_length(bit) owner to postgres;

create function pg_catalog.bit(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bit(integer, integer) is 'convert int4 to bitstring';

alter function pg_catalog.bit(integer, integer) owner to postgres;

create function pg_catalog.int4(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4(bit) is 'convert bitstring to int4';

alter function pg_catalog.int4(bit) owner to postgres;

create function pg_catalog.bit(bit, integer, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bit(bit, integer, boolean) is 'adjust bit() to typmod length';

alter function pg_catalog.bit(bit, integer, boolean) owner to postgres;

create function pg_catalog.pg_get_keywords(out word text, out catcode "char", out catdesc text)
    stable
    strict
    parallel safe
    cost 10
    rows 400
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_keywords(out text, out "char", out text) is 'list of SQL keywords';

alter function pg_catalog.pg_get_keywords(out text, out "char", out text) owner to postgres;

create function pg_catalog.varbit(bit varying, integer, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbit(bit varying, integer, boolean) is 'adjust varbit() to typmod length';

alter function pg_catalog.varbit(bit varying, integer, boolean) owner to postgres;

create function pg_catalog.time_hash(time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_hash(time) is 'hash';

alter function pg_catalog.time_hash(time) owner to postgres;

create function pg_catalog.aclexplode(acl aclitem[], out grantor oid, out grantee oid, out privilege_type text,
                                      out is_grantable boolean)
    stable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as -- missing source code
;

comment on function pg_catalog.aclexplode(aclitem[], out oid, out oid, out text, out boolean) is 'convert ACL item array to table, for use by information schema';

alter function pg_catalog.aclexplode(aclitem[], out oid, out oid, out text, out boolean) owner to postgres;

create function pg_catalog.time_mi_time(time, time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_mi_time(time, time) is 'implementation of - operator';

alter function pg_catalog.time_mi_time(time, time) owner to postgres;

create function pg_catalog.boolle(boolean, boolean)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolle(boolean, boolean) is 'implementation of <= operator';

alter function pg_catalog.boolle(boolean, boolean) owner to postgres;

create function pg_catalog.boolge(boolean, boolean)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolge(boolean, boolean) is 'implementation of >= operator';

alter function pg_catalog.boolge(boolean, boolean) owner to postgres;

create function pg_catalog.btboolcmp(boolean, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btboolcmp(boolean, boolean) is 'less-equal-greater';

alter function pg_catalog.btboolcmp(boolean, boolean) owner to postgres;

create function pg_catalog.timetz_hash(time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_hash(time with time zone) is 'hash';

alter function pg_catalog.timetz_hash(time with time zone) owner to postgres;

create function pg_catalog.interval_hash(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_hash(interval) is 'hash';

alter function pg_catalog.interval_hash(interval) owner to postgres;

create function pg_catalog.position(bit, bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.position(bit, bit) is 'position of sub-bitstring';

alter function pg_catalog.position(bit, bit) owner to postgres;

create function pg_catalog.substring(bit, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substring(bit, integer) is 'extract portion of bitstring';

alter function pg_catalog.substring(bit, integer) owner to postgres;

create function pg_catalog.numeric_in(cstring, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.numeric_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.numeric_out(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_out(numeric) is 'I/O';

alter function pg_catalog.numeric_out(numeric) owner to postgres;

create function pg_catalog.numeric(numeric, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric(numeric, integer) is 'adjust numeric to typmod precision/scale';

alter function pg_catalog.numeric(numeric, integer) owner to postgres;

create function pg_catalog.numeric_abs(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_abs(numeric) is 'implementation of @ operator';

alter function pg_catalog.numeric_abs(numeric) owner to postgres;

create function pg_catalog.abs(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abs(numeric) is 'absolute value';

alter function pg_catalog.abs(numeric) owner to postgres;

create function pg_catalog.sign(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.sign(numeric) is 'sign of value';

alter function pg_catalog.sign(numeric) owner to postgres;

create function pg_catalog.round(numeric, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.round(numeric, integer) is 'value rounded to ''scale''';

alter function pg_catalog.round(numeric, integer) owner to postgres;

create function pg_catalog.round(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.round($1, 0)
$$;

comment on function pg_catalog.round(numeric) is 'value rounded to ''scale'' of zero';

alter function pg_catalog.round(numeric) owner to postgres;

create function pg_catalog.trunc(numeric, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.trunc(numeric, integer) is 'value truncated to ''scale''';

alter function pg_catalog.trunc(numeric, integer) owner to postgres;

create function pg_catalog.trunc(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.trunc($1, 0)
$$;

comment on function pg_catalog.trunc(numeric) is 'value truncated to ''scale'' of zero';

alter function pg_catalog.trunc(numeric) owner to postgres;

create function pg_catalog.ceil(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ceil(numeric) is 'nearest integer >= value';

alter function pg_catalog.ceil(numeric) owner to postgres;

create function pg_catalog.floor(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.floor(numeric) is 'nearest integer <= value';

alter function pg_catalog.floor(numeric) owner to postgres;

create function pg_catalog.length(bytea, name)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.length(bytea, name) is 'length of string in specified encoding';

alter function pg_catalog.length(bytea, name) owner to postgres;

create function pg_catalog.convert_from(bytea, name)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.convert_from(bytea, name) is 'convert string with specified source encoding name';

alter function pg_catalog.convert_from(bytea, name) owner to postgres;

create function pg_catalog.cidr(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidr(inet) is 'convert inet to cidr';

alter function pg_catalog.cidr(inet) owner to postgres;

create function pg_catalog.pg_get_expr(pg_node_tree, oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid) is 'deparse an encoded expression';

alter function pg_catalog.pg_get_expr(pg_node_tree, oid) owner to postgres;

create function pg_catalog.convert_to(text, name)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.convert_to(text, name) is 'convert string with specified destination encoding name';

alter function pg_catalog.convert_to(text, name) owner to postgres;

create function pg_catalog.numeric_eq(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_eq(numeric, numeric) is 'implementation of = operator';

alter function pg_catalog.numeric_eq(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_ne(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_ne(numeric, numeric) is 'implementation of <> operator';

alter function pg_catalog.numeric_ne(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_gt(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_gt(numeric, numeric) is 'implementation of > operator';

alter function pg_catalog.numeric_gt(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_ge(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_ge(numeric, numeric) is 'implementation of >= operator';

alter function pg_catalog.numeric_ge(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_lt(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_lt(numeric, numeric) is 'implementation of < operator';

alter function pg_catalog.numeric_lt(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_le(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_le(numeric, numeric) is 'implementation of <= operator';

alter function pg_catalog.numeric_le(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_add(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_add(numeric, numeric) is 'implementation of + operator';

alter function pg_catalog.numeric_add(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_sub(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_sub(numeric, numeric) is 'implementation of - operator';

alter function pg_catalog.numeric_sub(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_mul(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_mul(numeric, numeric) is 'implementation of * operator';

alter function pg_catalog.numeric_mul(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_div(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_div(numeric, numeric) is 'implementation of / operator';

alter function pg_catalog.numeric_div(numeric, numeric) owner to postgres;

create function pg_catalog.mod(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.mod(numeric, numeric) is 'modulus';

alter function pg_catalog.mod(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_mod(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_mod(numeric, numeric) is 'implementation of % operator';

alter function pg_catalog.numeric_mod(numeric, numeric) owner to postgres;

create function pg_catalog.sqrt(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.sqrt(numeric) is 'square root';

alter function pg_catalog.sqrt(numeric) owner to postgres;

create function pg_catalog.numeric_sqrt(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_sqrt(numeric) is 'square root';

alter function pg_catalog.numeric_sqrt(numeric) owner to postgres;

create function pg_catalog.exp(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.exp(numeric) is 'natural exponential (e^x)';

alter function pg_catalog.exp(numeric) owner to postgres;

create function pg_catalog.numeric_exp(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_exp(numeric) is 'natural exponential (e^x)';

alter function pg_catalog.numeric_exp(numeric) owner to postgres;

create function pg_catalog.ln(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ln(numeric) is 'natural logarithm';

alter function pg_catalog.ln(numeric) owner to postgres;

create function pg_catalog.numeric_ln(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_ln(numeric) is 'natural logarithm';

alter function pg_catalog.numeric_ln(numeric) owner to postgres;

create function pg_catalog.log(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.log(numeric, numeric) is 'logarithm base m of n';

alter function pg_catalog.log(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_log(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_log(numeric, numeric) is 'logarithm base m of n';

alter function pg_catalog.numeric_log(numeric, numeric) owner to postgres;

create function pg_catalog.pow(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pow(numeric, numeric) is 'exponentiation';

alter function pg_catalog.pow(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_power(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_power(numeric, numeric) is 'implementation of ^ operator';

alter function pg_catalog.numeric_power(numeric, numeric) owner to postgres;

create function pg_catalog.numeric(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric(integer) is 'convert int4 to numeric';

alter function pg_catalog.numeric(integer) owner to postgres;

create function pg_catalog.log(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.log(10, $1)
$$;

comment on function pg_catalog.log(numeric) is 'base 10 logarithm';

alter function pg_catalog.log(numeric) owner to postgres;

create function pg_catalog.numeric(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric(real) is 'convert float4 to numeric';

alter function pg_catalog.numeric(real) owner to postgres;

create function pg_catalog.numeric(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric(double precision) is 'convert float8 to numeric';

alter function pg_catalog.numeric(double precision) owner to postgres;

create function pg_catalog.int4(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4(numeric) is 'convert numeric to int4';

alter function pg_catalog.int4(numeric) owner to postgres;

create function pg_catalog.float4(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4(numeric) is 'convert numeric to float4';

alter function pg_catalog.float4(numeric) owner to postgres;

create function pg_catalog.float8(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8(numeric) is 'convert numeric to float8';

alter function pg_catalog.float8(numeric) owner to postgres;

create function pg_catalog.time_pl_interval(time, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_pl_interval(time, interval) is 'implementation of + operator';

alter function pg_catalog.time_pl_interval(time, interval) owner to postgres;

create function pg_catalog.time_mi_interval(time, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_mi_interval(time, interval) is 'implementation of - operator';

alter function pg_catalog.time_mi_interval(time, interval) owner to postgres;

create function pg_catalog.timetz_pl_interval(time with time zone, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_pl_interval(time with time zone, interval) is 'implementation of + operator';

alter function pg_catalog.timetz_pl_interval(time with time zone, interval) owner to postgres;

create function pg_catalog.timetz_mi_interval(time with time zone, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_mi_interval(time with time zone, interval) is 'implementation of - operator';

alter function pg_catalog.timetz_mi_interval(time with time zone, interval) owner to postgres;

create function pg_catalog.numeric_inc(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_inc(numeric) is 'increment by one';

alter function pg_catalog.numeric_inc(numeric) owner to postgres;

create function pg_catalog.setval(regclass, bigint, boolean)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.setval(regclass, bigint, boolean) is 'set sequence value and is_called status';

alter function pg_catalog.setval(regclass, bigint, boolean) owner to postgres;

create function pg_catalog.numeric_smaller(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_smaller(numeric, numeric) is 'smaller of two';

alter function pg_catalog.numeric_smaller(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_larger(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_larger(numeric, numeric) is 'larger of two';

alter function pg_catalog.numeric_larger(numeric, numeric) owner to postgres;

create function pg_catalog.to_char(interval, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_char(interval, text) is 'format interval to text';

alter function pg_catalog.to_char(interval, text) owner to postgres;

create function pg_catalog.numeric_cmp(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_cmp(numeric, numeric) is 'less-equal-greater';

alter function pg_catalog.numeric_cmp(numeric, numeric) owner to postgres;

create function pg_catalog.to_char(timestamp with time zone, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_char(timestamp with time zone, text) is 'format timestamp with time zone to text';

alter function pg_catalog.to_char(timestamp with time zone, text) owner to postgres;

create function pg_catalog.numeric_uminus(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_uminus(numeric) is 'implementation of - operator';

alter function pg_catalog.numeric_uminus(numeric) owner to postgres;

create function pg_catalog.to_char(numeric, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_char(numeric, text) is 'format numeric to text';

alter function pg_catalog.to_char(numeric, text) owner to postgres;

create function pg_catalog.to_char(integer, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_char(integer, text) is 'format int4 to text';

alter function pg_catalog.to_char(integer, text) owner to postgres;

create function pg_catalog.to_char(bigint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_char(bigint, text) is 'format int8 to text';

alter function pg_catalog.to_char(bigint, text) owner to postgres;

create function pg_catalog.to_char(real, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_char(real, text) is 'format float4 to text';

alter function pg_catalog.to_char(real, text) owner to postgres;

create function pg_catalog.to_char(double precision, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_char(double precision, text) is 'format float8 to text';

alter function pg_catalog.to_char(double precision, text) owner to postgres;

create function pg_catalog.to_number(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_number(text, text) is 'convert text to numeric';

alter function pg_catalog.to_number(text, text) owner to postgres;

create function pg_catalog.to_timestamp(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_timestamp(text, text) is 'convert text to timestamp with time zone';

alter function pg_catalog.to_timestamp(text, text) owner to postgres;

create function pg_catalog.int8(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8(numeric) is 'convert numeric to int8';

alter function pg_catalog.int8(numeric) owner to postgres;

create function pg_catalog.to_date(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_date(text, text) is 'convert text to date';

alter function pg_catalog.to_date(text, text) owner to postgres;

create function pg_catalog.numeric(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric(bigint) is 'convert int8 to numeric';

alter function pg_catalog.numeric(bigint) owner to postgres;

create function pg_catalog.numeric(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric(smallint) is 'convert int2 to numeric';

alter function pg_catalog.numeric(smallint) owner to postgres;

create function pg_catalog.int2(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2(numeric) is 'convert numeric to int2';

alter function pg_catalog.int2(numeric) owner to postgres;

create function pg_catalog.oidin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidin(cstring) is 'I/O';

alter function pg_catalog.oidin(cstring) owner to postgres;

create function pg_catalog.oidout(oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidout(oid) is 'I/O';

alter function pg_catalog.oidout(oid) owner to postgres;

create function pg_catalog.bit_length(bytea) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.octet_length($1) * 8
$$;

comment on function pg_catalog.bit_length(bytea) is 'length in bits';

alter function pg_catalog.bit_length(bytea) owner to postgres;

create function pg_catalog.bit_length(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.octet_length($1) * 8
$$;

comment on function pg_catalog.bit_length(text) is 'length in bits';

alter function pg_catalog.bit_length(text) owner to postgres;

create function pg_catalog.bit_length(bit) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.length($1)
$$;

comment on function pg_catalog.bit_length(bit) is 'length in bits';

alter function pg_catalog.bit_length(bit) owner to postgres;

create function pg_catalog.convert(bytea, name, name)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.convert(bytea, name, name) is 'convert string with specified encoding names';

alter function pg_catalog.convert(bytea, name, name) owner to postgres;

create function pg_catalog.iclikesel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.iclikesel(internal, oid, internal, integer) is 'restriction selectivity of ILIKE';

alter function pg_catalog.iclikesel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.icnlikesel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.icnlikesel(internal, oid, internal, integer) is 'restriction selectivity of NOT ILIKE';

alter function pg_catalog.icnlikesel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of ILIKE';

alter function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of NOT ILIKE';

alter function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.regexeqsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexeqsel(internal, oid, internal, integer) is 'restriction selectivity of regex match';

alter function pg_catalog.regexeqsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.likesel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.likesel(internal, oid, internal, integer) is 'restriction selectivity of LIKE';

alter function pg_catalog.likesel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.icregexeqsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.icregexeqsel(internal, oid, internal, integer) is 'restriction selectivity of case-insensitive regex match';

alter function pg_catalog.icregexeqsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.regexnesel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexnesel(internal, oid, internal, integer) is 'restriction selectivity of regex non-match';

alter function pg_catalog.regexnesel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.nlikesel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nlikesel(internal, oid, internal, integer) is 'restriction selectivity of NOT LIKE';

alter function pg_catalog.nlikesel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.icregexnesel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.icregexnesel(internal, oid, internal, integer) is 'restriction selectivity of case-insensitive regex non-match';

alter function pg_catalog.icregexnesel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of regex match';

alter function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of LIKE';

alter function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of case-insensitive regex match';

alter function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of regex non-match';

alter function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of NOT LIKE';

alter function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of case-insensitive regex non-match';

alter function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.float8_avg(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_avg(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_avg(double precision[]) owner to postgres;

create function pg_catalog.float8_var_samp(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_var_samp(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_var_samp(double precision[]) owner to postgres;

create function pg_catalog.float8_stddev_samp(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_stddev_samp(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_stddev_samp(double precision[]) owner to postgres;

create function pg_catalog.numeric_accum(internal, numeric)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_accum(internal, numeric) is 'aggregate transition function';

alter function pg_catalog.numeric_accum(internal, numeric) owner to postgres;

create function pg_catalog.int2_accum(internal, smallint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2_accum(internal, smallint) is 'aggregate transition function';

alter function pg_catalog.int2_accum(internal, smallint) owner to postgres;

create function pg_catalog.int4_accum(internal, integer)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4_accum(internal, integer) is 'aggregate transition function';

alter function pg_catalog.int4_accum(internal, integer) owner to postgres;

create function pg_catalog.int8_accum(internal, bigint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_accum(internal, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_accum(internal, bigint) owner to postgres;

create function pg_catalog.numeric_avg(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_avg(internal) is 'aggregate final function';

alter function pg_catalog.numeric_avg(internal) owner to postgres;

create function pg_catalog.numeric_var_samp(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_var_samp(internal) is 'aggregate final function';

alter function pg_catalog.numeric_var_samp(internal) owner to postgres;

create function pg_catalog.numeric_stddev_samp(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_stddev_samp(internal) is 'aggregate final function';

alter function pg_catalog.numeric_stddev_samp(internal) owner to postgres;

create function pg_catalog.int2_sum(bigint, smallint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2_sum(bigint, smallint) is 'aggregate transition function';

alter function pg_catalog.int2_sum(bigint, smallint) owner to postgres;

create function pg_catalog.int4_sum(bigint, integer)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4_sum(bigint, integer) is 'aggregate transition function';

alter function pg_catalog.int4_sum(bigint, integer) owner to postgres;

create function pg_catalog.int8_sum(numeric, bigint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_sum(numeric, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_sum(numeric, bigint) owner to postgres;

create function pg_catalog.interval_accum(interval[], interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_accum(interval[], interval) is 'aggregate transition function';

alter function pg_catalog.interval_accum(interval[], interval) owner to postgres;

create function pg_catalog.interval_avg(interval[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_avg(interval[]) is 'aggregate final function';

alter function pg_catalog.interval_avg(interval[]) owner to postgres;

create function pg_catalog.to_ascii(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_ascii(text) is 'encode text from DB encoding to ASCII text';

alter function pg_catalog.to_ascii(text) owner to postgres;

create function pg_catalog.to_ascii(text, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_ascii(text, integer) is 'encode text from encoding to ASCII text';

alter function pg_catalog.to_ascii(text, integer) owner to postgres;

create function pg_catalog.to_ascii(text, name)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_ascii(text, name) is 'encode text from encoding to ASCII text';

alter function pg_catalog.to_ascii(text, name) owner to postgres;

create function pg_catalog.interval_pl_time(interval, time without time zone) returns time without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_time(interval, time) is 'implementation of + operator';

alter function pg_catalog.interval_pl_time(interval, time) owner to postgres;

create function pg_catalog.int28eq(smallint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28eq(smallint, bigint) is 'implementation of = operator';

alter function pg_catalog.int28eq(smallint, bigint) owner to postgres;

create function pg_catalog.int28ne(smallint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28ne(smallint, bigint) is 'implementation of <> operator';

alter function pg_catalog.int28ne(smallint, bigint) owner to postgres;

create function pg_catalog.int28lt(smallint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28lt(smallint, bigint) is 'implementation of < operator';

alter function pg_catalog.int28lt(smallint, bigint) owner to postgres;

create function pg_catalog.int28gt(smallint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28gt(smallint, bigint) is 'implementation of > operator';

alter function pg_catalog.int28gt(smallint, bigint) owner to postgres;

create function pg_catalog.int28le(smallint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28le(smallint, bigint) is 'implementation of <= operator';

alter function pg_catalog.int28le(smallint, bigint) owner to postgres;

create function pg_catalog.int28ge(smallint, bigint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int28ge(smallint, bigint) is 'implementation of >= operator';

alter function pg_catalog.int28ge(smallint, bigint) owner to postgres;

create function pg_catalog.int82eq(bigint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82eq(bigint, smallint) is 'implementation of = operator';

alter function pg_catalog.int82eq(bigint, smallint) owner to postgres;

create function pg_catalog.int82ne(bigint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82ne(bigint, smallint) is 'implementation of <> operator';

alter function pg_catalog.int82ne(bigint, smallint) owner to postgres;

create function pg_catalog.int82lt(bigint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82lt(bigint, smallint) is 'implementation of < operator';

alter function pg_catalog.int82lt(bigint, smallint) owner to postgres;

create function pg_catalog.int82gt(bigint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82gt(bigint, smallint) is 'implementation of > operator';

alter function pg_catalog.int82gt(bigint, smallint) owner to postgres;

create function pg_catalog.int82le(bigint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82le(bigint, smallint) is 'implementation of <= operator';

alter function pg_catalog.int82le(bigint, smallint) owner to postgres;

create function pg_catalog.int82ge(bigint, smallint)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int82ge(bigint, smallint) is 'implementation of >= operator';

alter function pg_catalog.int82ge(bigint, smallint) owner to postgres;

create function pg_catalog.int2and(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2and(smallint, smallint) is 'implementation of & operator';

alter function pg_catalog.int2and(smallint, smallint) owner to postgres;

create function pg_catalog.int2or(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2or(smallint, smallint) is 'implementation of | operator';

alter function pg_catalog.int2or(smallint, smallint) owner to postgres;

create function pg_catalog.int2xor(smallint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2xor(smallint, smallint) is 'implementation of # operator';

alter function pg_catalog.int2xor(smallint, smallint) owner to postgres;

create function pg_catalog.int2not(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2not(smallint) is 'implementation of ~ operator';

alter function pg_catalog.int2not(smallint) owner to postgres;

create function pg_catalog.int2shl(smallint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2shl(smallint, integer) is 'implementation of << operator';

alter function pg_catalog.int2shl(smallint, integer) owner to postgres;

create function pg_catalog.int2shr(smallint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2shr(smallint, integer) is 'implementation of >> operator';

alter function pg_catalog.int2shr(smallint, integer) owner to postgres;

create function pg_catalog.int4and(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4and(integer, integer) is 'implementation of & operator';

alter function pg_catalog.int4and(integer, integer) owner to postgres;

create function pg_catalog.int4or(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4or(integer, integer) is 'implementation of | operator';

alter function pg_catalog.int4or(integer, integer) owner to postgres;

create function pg_catalog.int4xor(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4xor(integer, integer) is 'implementation of # operator';

alter function pg_catalog.int4xor(integer, integer) owner to postgres;

create function pg_catalog.int4not(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4not(integer) is 'implementation of ~ operator';

alter function pg_catalog.int4not(integer) owner to postgres;

create function pg_catalog.int4shl(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4shl(integer, integer) is 'implementation of << operator';

alter function pg_catalog.int4shl(integer, integer) owner to postgres;

create function pg_catalog.int4shr(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4shr(integer, integer) is 'implementation of >> operator';

alter function pg_catalog.int4shr(integer, integer) owner to postgres;

create function pg_catalog.int8and(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8and(bigint, bigint) is 'implementation of & operator';

alter function pg_catalog.int8and(bigint, bigint) owner to postgres;

create function pg_catalog.int8or(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8or(bigint, bigint) is 'implementation of | operator';

alter function pg_catalog.int8or(bigint, bigint) owner to postgres;

create function pg_catalog.int8xor(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8xor(bigint, bigint) is 'implementation of # operator';

alter function pg_catalog.int8xor(bigint, bigint) owner to postgres;

create function pg_catalog.int8not(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8not(bigint) is 'implementation of ~ operator';

alter function pg_catalog.int8not(bigint) owner to postgres;

create function pg_catalog.int8shl(bigint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8shl(bigint, integer) is 'implementation of << operator';

alter function pg_catalog.int8shl(bigint, integer) owner to postgres;

create function pg_catalog.int8shr(bigint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8shr(bigint, integer) is 'implementation of >> operator';

alter function pg_catalog.int8shr(bigint, integer) owner to postgres;

create function pg_catalog.int8up(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8up(bigint) is 'implementation of + operator';

alter function pg_catalog.int8up(bigint) owner to postgres;

create function pg_catalog.int2up(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2up(smallint) is 'implementation of + operator';

alter function pg_catalog.int2up(smallint) owner to postgres;

create function pg_catalog.int4up(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4up(integer) is 'implementation of + operator';

alter function pg_catalog.int4up(integer) owner to postgres;

create function pg_catalog.float4up(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4up(real) is 'implementation of + operator';

alter function pg_catalog.float4up(real) owner to postgres;

create function pg_catalog.float8up(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8up(double precision) is 'implementation of + operator';

alter function pg_catalog.float8up(double precision) owner to postgres;

create function pg_catalog.numeric_uplus(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_uplus(numeric) is 'implementation of + operator';

alter function pg_catalog.numeric_uplus(numeric) owner to postgres;

create function pg_catalog.has_table_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_table_privilege(name, text, text) is 'user privilege on relation by username, rel name';

alter function pg_catalog.has_table_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_table_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_table_privilege(name, oid, text) is 'user privilege on relation by username, rel oid';

alter function pg_catalog.has_table_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_table_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_table_privilege(oid, text, text) is 'user privilege on relation by user oid, rel name';

alter function pg_catalog.has_table_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_table_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_table_privilege(oid, oid, text) is 'user privilege on relation by user oid, rel oid';

alter function pg_catalog.has_table_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_table_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_table_privilege(text, text) is 'current user privilege on relation by rel name';

alter function pg_catalog.has_table_privilege(text, text) owner to postgres;

create function pg_catalog.has_table_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_table_privilege(oid, text) is 'current user privilege on relation by rel oid';

alter function pg_catalog.has_table_privilege(oid, text) owner to postgres;

create function pg_catalog.pg_stat_get_numscans(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_numscans(oid) is 'statistics: number of scans done for table/index';

alter function pg_catalog.pg_stat_get_numscans(oid) owner to postgres;

create function pg_catalog.pg_stat_get_tuples_returned(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_tuples_returned(oid) is 'statistics: number of tuples read by seqscan';

alter function pg_catalog.pg_stat_get_tuples_returned(oid) owner to postgres;

create function pg_catalog.pg_stat_get_tuples_fetched(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_tuples_fetched(oid) is 'statistics: number of tuples fetched by idxscan';

alter function pg_catalog.pg_stat_get_tuples_fetched(oid) owner to postgres;

create function pg_catalog.pg_stat_get_tuples_inserted(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_tuples_inserted(oid) is 'statistics: number of tuples inserted';

alter function pg_catalog.pg_stat_get_tuples_inserted(oid) owner to postgres;

create function pg_catalog.pg_stat_get_tuples_updated(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_tuples_updated(oid) is 'statistics: number of tuples updated';

alter function pg_catalog.pg_stat_get_tuples_updated(oid) owner to postgres;

create function pg_catalog.pg_stat_get_tuples_deleted(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_tuples_deleted(oid) is 'statistics: number of tuples deleted';

alter function pg_catalog.pg_stat_get_tuples_deleted(oid) owner to postgres;

create function pg_catalog.pg_stat_get_blocks_fetched(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_blocks_fetched(oid) is 'statistics: number of blocks fetched';

alter function pg_catalog.pg_stat_get_blocks_fetched(oid) owner to postgres;

create function pg_catalog.pg_stat_get_blocks_hit(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_blocks_hit(oid) is 'statistics: number of blocks found in cache';

alter function pg_catalog.pg_stat_get_blocks_hit(oid) owner to postgres;

create function pg_catalog.pg_stat_get_backend_idset()
    stable
    strict
    parallel restricted
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_idset() is 'statistics: currently active backend IDs';

alter function pg_catalog.pg_stat_get_backend_idset() owner to postgres;

create function pg_catalog.pg_stat_get_backend_pid(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_pid(integer) is 'statistics: PID of backend';

alter function pg_catalog.pg_stat_get_backend_pid(integer) owner to postgres;

create function pg_catalog.pg_stat_get_backend_dbid(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_dbid(integer) is 'statistics: database ID of backend';

alter function pg_catalog.pg_stat_get_backend_dbid(integer) owner to postgres;

create function pg_catalog.pg_stat_get_backend_userid(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_userid(integer) is 'statistics: user ID of backend';

alter function pg_catalog.pg_stat_get_backend_userid(integer) owner to postgres;

create function pg_catalog.pg_stat_get_backend_activity(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_activity(integer) is 'statistics: current query of backend';

alter function pg_catalog.pg_stat_get_backend_activity(integer) owner to postgres;

create function pg_catalog.pg_stat_get_db_numbackends(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_numbackends(oid) is 'statistics: number of backends in database';

alter function pg_catalog.pg_stat_get_db_numbackends(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_xact_commit(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_xact_commit(oid) is 'statistics: transactions committed';

alter function pg_catalog.pg_stat_get_db_xact_commit(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_xact_rollback(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_xact_rollback(oid) is 'statistics: transactions rolled back';

alter function pg_catalog.pg_stat_get_db_xact_rollback(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_blocks_fetched(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_blocks_fetched(oid) is 'statistics: blocks fetched for database';

alter function pg_catalog.pg_stat_get_db_blocks_fetched(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_blocks_hit(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_blocks_hit(oid) is 'statistics: blocks found in cache for database';

alter function pg_catalog.pg_stat_get_db_blocks_hit(oid) owner to postgres;

create function pg_catalog.encode(bytea, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.encode(bytea, text) is 'convert bytea value into some ascii-only text string';

alter function pg_catalog.encode(bytea, text) owner to postgres;

create function pg_catalog.decode(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.decode(text, text) is 'convert ascii-encoded text string into bytea value';

alter function pg_catalog.decode(text, text) owner to postgres;

create function pg_catalog.byteaeq(bytea, bytea)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteaeq(bytea, bytea) is 'implementation of = operator';

alter function pg_catalog.byteaeq(bytea, bytea) owner to postgres;

create function pg_catalog.bytealt(bytea, bytea)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bytealt(bytea, bytea) is 'implementation of < operator';

alter function pg_catalog.bytealt(bytea, bytea) owner to postgres;

create function pg_catalog.byteale(bytea, bytea)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteale(bytea, bytea) is 'implementation of <= operator';

alter function pg_catalog.byteale(bytea, bytea) owner to postgres;

create function pg_catalog.byteagt(bytea, bytea)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteagt(bytea, bytea) is 'implementation of > operator';

alter function pg_catalog.byteagt(bytea, bytea) owner to postgres;

create function pg_catalog.byteage(bytea, bytea)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteage(bytea, bytea) is 'implementation of >= operator';

alter function pg_catalog.byteage(bytea, bytea) owner to postgres;

create function pg_catalog.byteane(bytea, bytea)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteane(bytea, bytea) is 'implementation of <> operator';

alter function pg_catalog.byteane(bytea, bytea) owner to postgres;

create function pg_catalog.byteacmp(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteacmp(bytea, bytea) is 'less-equal-greater';

alter function pg_catalog.byteacmp(bytea, bytea) owner to postgres;

create function pg_catalog.timestamp(timestamp, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp(timestamp, integer) is 'adjust timestamp precision';

alter function pg_catalog.timestamp(timestamp, integer) owner to postgres;

create function pg_catalog.int2_avg_accum(bigint[], smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2_avg_accum(bigint[], smallint) is 'aggregate transition function';

alter function pg_catalog.int2_avg_accum(bigint[], smallint) owner to postgres;

create function pg_catalog.int4_avg_accum(bigint[], integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4_avg_accum(bigint[], integer) is 'aggregate transition function';

alter function pg_catalog.int4_avg_accum(bigint[], integer) owner to postgres;

create function pg_catalog.int8_avg(bigint[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_avg(bigint[]) is 'aggregate final function';

alter function pg_catalog.int8_avg(bigint[]) owner to postgres;

create function pg_catalog.oidlarger(oid, oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidlarger(oid, oid) is 'larger of two';

alter function pg_catalog.oidlarger(oid, oid) owner to postgres;

create function pg_catalog.oidsmaller(oid, oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidsmaller(oid, oid) is 'smaller of two';

alter function pg_catalog.oidsmaller(oid, oid) owner to postgres;

create function pg_catalog.timestamptz(timestamp with time zone, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz(timestamp with time zone, integer) is 'adjust timestamptz precision';

alter function pg_catalog.timestamptz(timestamp with time zone, integer) owner to postgres;

create function pg_catalog.time(time, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time(time, integer) is 'adjust time precision';

alter function pg_catalog.time(time, integer) owner to postgres;

create function pg_catalog.timetz(time with time zone, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz(time with time zone, integer) is 'adjust time with time zone precision';

alter function pg_catalog.timetz(time with time zone, integer) owner to postgres;

create function pg_catalog.pg_stat_get_tuples_hot_updated(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_tuples_hot_updated(oid) is 'statistics: number of tuples hot updated';

alter function pg_catalog.pg_stat_get_tuples_hot_updated(oid) owner to postgres;

create function pg_catalog.div(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.div(numeric, numeric) is 'trunc(x/y)';

alter function pg_catalog.div(numeric, numeric) owner to postgres;

create function pg_catalog.numeric_div_trunc(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_div_trunc(numeric, numeric) is 'trunc(x/y)';

alter function pg_catalog.numeric_div_trunc(numeric, numeric) owner to postgres;

create function pg_catalog.shobj_description(oid, name) returns text
    stable
    strict
    parallel safe
    language sql
as
$$
select description
from pg_catalog.pg_shdescription
where objoid = $1
  and classoid = (select oid from pg_catalog.pg_class where relname = $2 and relnamespace = 11)
$$;

comment on function pg_catalog.shobj_description(oid, name) is 'get description for object id and shared catalog name';

alter function pg_catalog.shobj_description(oid, name) owner to postgres;

create function pg_catalog.textanycat(text, anynonarray) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $1 || $2::pg_catalog.text
$$;

comment on function pg_catalog.textanycat(text, anynonarray) is 'implementation of || operator';

alter function pg_catalog.textanycat(text, anynonarray) owner to postgres;

create function pg_catalog.anytextcat(anynonarray, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $1::pg_catalog.text || $2
$$;

comment on function pg_catalog.anytextcat(anynonarray, text) is 'implementation of || operator';

alter function pg_catalog.anytextcat(anynonarray, text) owner to postgres;

create function pg_catalog.bytealike(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bytealike(bytea, bytea) is 'implementation of ~~ operator';

alter function pg_catalog.bytealike(bytea, bytea) owner to postgres;

create function pg_catalog.byteanlike(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteanlike(bytea, bytea) is 'implementation of !~~ operator';

alter function pg_catalog.byteanlike(bytea, bytea) owner to postgres;

create function pg_catalog."like"(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."like"(bytea, bytea) is 'matches LIKE expression';

alter function pg_catalog."like"(bytea, bytea) owner to postgres;

create function pg_catalog.notlike(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.notlike(bytea, bytea) is 'does not match LIKE expression';

alter function pg_catalog.notlike(bytea, bytea) owner to postgres;

create function pg_catalog.like_escape(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.like_escape(bytea, bytea) is 'convert LIKE pattern to use backslash escapes';

alter function pg_catalog.like_escape(bytea, bytea) owner to postgres;

create function pg_catalog.length(bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.length(bytea) is 'octet length';

alter function pg_catalog.length(bytea) owner to postgres;

create function pg_catalog.byteacat(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteacat(bytea, bytea) is 'implementation of || operator';

alter function pg_catalog.byteacat(bytea, bytea) owner to postgres;

create function pg_catalog.substring(bytea, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substring(bytea, integer, integer) is 'extract portion of string';

alter function pg_catalog.substring(bytea, integer, integer) owner to postgres;

create function pg_catalog.substring(bytea, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substring(bytea, integer) is 'extract portion of string';

alter function pg_catalog.substring(bytea, integer) owner to postgres;

create function pg_catalog.position(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.position(bytea, bytea) is 'position of substring';

alter function pg_catalog.position(bytea, bytea) owner to postgres;

create function pg_catalog.btrim(bytea, bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btrim(bytea, bytea) is 'trim both ends of string';

alter function pg_catalog.btrim(bytea, bytea) owner to postgres;

create function pg_catalog.time(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time(timestamp with time zone) is 'convert timestamp with time zone to time';

alter function pg_catalog.time(timestamp with time zone) owner to postgres;

create function pg_catalog.date_trunc(text, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_trunc(text, timestamp) is 'truncate timestamp to specified units';

alter function pg_catalog.date_trunc(text, timestamp) owner to postgres;

create function pg_catalog.date_part(text, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_part(text, timestamp) is 'extract field from timestamp';

alter function pg_catalog.date_part(text, timestamp) owner to postgres;

create function pg_catalog.pg_stat_get_activity(pid integer, out datid oid, out pid integer, out usesysid oid,
                                                out application_name text, out state text, out query text,
                                                out wait_event_type text, out wait_event text,
                                                out xact_start timestamp with time zone,
                                                out query_start timestamp with time zone,
                                                out backend_start timestamp with time zone,
                                                out state_change timestamp with time zone, out client_addr inet,
                                                out client_hostname text, out client_port integer, out backend_xid xid,
                                                out backend_xmin xid, out ssl boolean, out sslversion text,
                                                out sslcipher text, out sslbits integer, out sslcompression boolean,
                                                out sslclientdn text)
    stable
    parallel restricted
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_activity(integer, out oid, out integer, out oid, out text, out text, out text, out text, out text, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out inet, out text, out integer, out xid, out xid, out boolean, out text, out text, out integer, out boolean, out text) is 'statistics: information about currently active backends';

alter function pg_catalog.pg_stat_get_activity(integer, out oid, out integer, out oid, out text, out text, out text, out text, out text, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out inet, out text, out integer, out xid, out xid, out boolean, out text, out text, out integer, out boolean, out text) owner to postgres;

create function pg_catalog.timestamp(abstime)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp(abstime) is 'convert abstime to timestamp';

alter function pg_catalog.timestamp(abstime) owner to postgres;

create function pg_catalog.timestamp(date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp(date) is 'convert date to timestamp';

alter function pg_catalog.timestamp(date) owner to postgres;

create function pg_catalog.timestamp(date, time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp(date, time) is 'convert date and time to timestamp';

alter function pg_catalog.timestamp(date, time) owner to postgres;

create function pg_catalog.pg_backend_pid()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_backend_pid() is 'statistics: current backend PID';

alter function pg_catalog.pg_backend_pid() owner to postgres;

create function pg_catalog.timestamp(timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp(timestamp with time zone) is 'convert timestamp with time zone to timestamp';

alter function pg_catalog.timestamp(timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz(timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz(timestamp) is 'convert timestamp to timestamp with time zone';

alter function pg_catalog.timestamptz(timestamp) owner to postgres;

create function pg_catalog.date(timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date(timestamp) is 'convert timestamp to date';

alter function pg_catalog.date(timestamp) owner to postgres;

create function pg_catalog.abstime(timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstime(timestamp) is 'convert timestamp to abstime';

alter function pg_catalog.abstime(timestamp) owner to postgres;

create function pg_catalog.timestamp_mi(timestamp, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_mi(timestamp, timestamp) is 'implementation of - operator';

alter function pg_catalog.timestamp_mi(timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_pl_interval(timestamp, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_pl_interval(timestamp, interval) is 'implementation of + operator';

alter function pg_catalog.timestamp_pl_interval(timestamp, interval) owner to postgres;

create function pg_catalog.timestamp_mi_interval(timestamp, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_mi_interval(timestamp, interval) is 'implementation of - operator';

alter function pg_catalog.timestamp_mi_interval(timestamp, interval) owner to postgres;

create function pg_catalog.pg_conf_load_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_conf_load_time() is 'configuration load time';

alter function pg_catalog.pg_conf_load_time() owner to postgres;

create function pg_catalog.timestamp_smaller(timestamp, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_smaller(timestamp, timestamp) is 'smaller of two';

alter function pg_catalog.timestamp_smaller(timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_larger(timestamp, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_larger(timestamp, timestamp) is 'larger of two';

alter function pg_catalog.timestamp_larger(timestamp, timestamp) owner to postgres;

create function pg_catalog.timezone(text, time with time zone)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timezone(text, time with time zone) is 'adjust time with time zone to new zone';

alter function pg_catalog.timezone(text, time with time zone) owner to postgres;

create function pg_catalog.timezone(interval, time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timezone(interval, time with time zone) is 'adjust time with time zone to new zone';

alter function pg_catalog.timezone(interval, time with time zone) owner to postgres;

create function pg_catalog.timestamp_hash(timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_hash(timestamp) is 'hash';

alter function pg_catalog.timestamp_hash(timestamp) owner to postgres;

create function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp) owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone,
                                      interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, ($1 + $2)) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, interval, timestamp, interval) owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, timestamp without time zone,
                                      timestamp without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, $2) overlaps ($3, ($3 + $4))
$$;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval) owner to postgres;

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone,
                                      timestamp without time zone) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
as
$$
select ($1, ($1 + $2)) overlaps ($3, $4)
$$;

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_cmp(timestamp, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_cmp(timestamp, timestamp) is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp(timestamp, timestamp) owner to postgres;

create function pg_catalog.time(time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time(time with time zone) is 'convert time with time zone to time';

alter function pg_catalog.time(time with time zone) owner to postgres;

create function pg_catalog.timetz(time)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz(time) is 'convert time to time with time zone';

alter function pg_catalog.timetz(time) owner to postgres;

create function pg_catalog.isfinite(timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isfinite(timestamp) is 'finite timestamp?';

alter function pg_catalog.isfinite(timestamp) owner to postgres;

create function pg_catalog.to_char(timestamp, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_char(timestamp, text) is 'format timestamp to text';

alter function pg_catalog.to_char(timestamp, text) owner to postgres;

create function pg_catalog.timestamp_eq(timestamp, timestamp)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_eq(timestamp, timestamp) is 'implementation of = operator';

alter function pg_catalog.timestamp_eq(timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_ne(timestamp, timestamp)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_ne(timestamp, timestamp) is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne(timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_lt(timestamp, timestamp)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_lt(timestamp, timestamp) is 'implementation of < operator';

alter function pg_catalog.timestamp_lt(timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_le(timestamp, timestamp)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_le(timestamp, timestamp) is 'implementation of <= operator';

alter function pg_catalog.timestamp_le(timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_ge(timestamp, timestamp)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_ge(timestamp, timestamp) is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge(timestamp, timestamp) owner to postgres;

create function pg_catalog.timestamp_gt(timestamp, timestamp)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_gt(timestamp, timestamp) is 'implementation of > operator';

alter function pg_catalog.timestamp_gt(timestamp, timestamp) owner to postgres;

create function pg_catalog.age(timestamp, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.age(timestamp, timestamp) is 'date difference preserving months and years';

alter function pg_catalog.age(timestamp, timestamp) owner to postgres;

create function pg_catalog.age(timestamp without time zone) returns interval
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.age(cast(current_date as timestamp without time zone), $1)
$$;

comment on function pg_catalog.age(timestamp) is 'date difference from today preserving months and years';

alter function pg_catalog.age(timestamp) owner to postgres;

create function pg_catalog.timezone(text, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timezone(text, timestamp) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(text, timestamp) owner to postgres;

create function pg_catalog.timezone(interval, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timezone(interval, timestamp) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(interval, timestamp) owner to postgres;

create function pg_catalog.date_pl_interval(date, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_pl_interval(date, interval) is 'implementation of + operator';

alter function pg_catalog.date_pl_interval(date, interval) owner to postgres;

create function pg_catalog.date_mi_interval(date, interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_mi_interval(date, interval) is 'implementation of - operator';

alter function pg_catalog.date_mi_interval(date, interval) owner to postgres;

create function pg_catalog.substring(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substring(text, text) is 'extract text matching regular expression';

alter function pg_catalog.substring(text, text) owner to postgres;

create function pg_catalog.substring(text, text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.substring($1, pg_catalog.similar_escape($2, $3))
$$;

comment on function pg_catalog.substring(text, text, text) is 'extract text matching SQL99 regular expression';

alter function pg_catalog.substring(text, text, text) owner to postgres;

create function pg_catalog.bit(bigint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bit(bigint, integer) is 'convert int8 to bitstring';

alter function pg_catalog.bit(bigint, integer) owner to postgres;

create function pg_catalog.int8(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8(bit) is 'convert bitstring to int8';

alter function pg_catalog.int8(bit) owner to postgres;

create function pg_catalog.current_setting(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.current_setting(text) is 'SHOW X as a function';

alter function pg_catalog.current_setting(text) owner to postgres;

create function pg_catalog.set_config(text, text, boolean)
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.set_config(text, text, boolean) is 'SET X as a function';

alter function pg_catalog.set_config(text, text, boolean) owner to postgres;

create function pg_catalog.pg_table_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_table_is_visible(oid) is 'is table visible in search path?';

alter function pg_catalog.pg_table_is_visible(oid) owner to postgres;

create function pg_catalog.pg_type_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_type_is_visible(oid) is 'is type visible in search path?';

alter function pg_catalog.pg_type_is_visible(oid) owner to postgres;

create function pg_catalog.pg_function_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_function_is_visible(oid) is 'is function visible in search path?';

alter function pg_catalog.pg_function_is_visible(oid) owner to postgres;

create function pg_catalog.pg_operator_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_operator_is_visible(oid) is 'is operator visible in search path?';

alter function pg_catalog.pg_operator_is_visible(oid) owner to postgres;

create function pg_catalog.pg_opclass_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_opclass_is_visible(oid) is 'is opclass visible in search path?';

alter function pg_catalog.pg_opclass_is_visible(oid) owner to postgres;

create function pg_catalog.pg_show_all_settings(out name text, out setting text, out unit text, out category text,
                                                out short_desc text, out extra_desc text, out context text,
                                                out vartype text, out source text, out min_val text, out max_val text,
                                                out enumvals text[], out boot_val text, out reset_val text,
                                                out sourcefile text, out sourceline integer,
                                                out pending_restart boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_show_all_settings(out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text[], out text, out text, out text, out integer, out boolean) is 'SHOW ALL as a function';

alter function pg_catalog.pg_show_all_settings(out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text[], out text, out text, out text, out integer, out boolean) owner to postgres;

create function pg_catalog.substr(bytea, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substr(bytea, integer, integer) is 'extract portion of string';

alter function pg_catalog.substr(bytea, integer, integer) owner to postgres;

create function pg_catalog.substr(bytea, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.substr(bytea, integer) is 'extract portion of string';

alter function pg_catalog.substr(bytea, integer) owner to postgres;

create function pg_catalog.replace(text, text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.replace(text, text, text) is 'replace all occurrences in string of old_substr with new_substr';

alter function pg_catalog.replace(text, text, text) owner to postgres;

create function pg_catalog.split_part(text, text, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.split_part(text, text, integer) is 'split string by field_sep and return field_num';

alter function pg_catalog.split_part(text, text, integer) owner to postgres;

create function pg_catalog.to_hex(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_hex(integer) is 'convert int4 number to hex';

alter function pg_catalog.to_hex(integer) owner to postgres;

create function pg_catalog.to_hex(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_hex(bigint) is 'convert int8 number to hex';

alter function pg_catalog.to_hex(bigint) owner to postgres;

create function pg_catalog.array_lower(anyarray, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_lower(anyarray, integer) is 'array lower dimension';

alter function pg_catalog.array_lower(anyarray, integer) owner to postgres;

create function pg_catalog.array_upper(anyarray, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_upper(anyarray, integer) is 'array upper dimension';

alter function pg_catalog.array_upper(anyarray, integer) owner to postgres;

create function pg_catalog.pg_conversion_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_conversion_is_visible(oid) is 'is conversion visible in search path?';

alter function pg_catalog.pg_conversion_is_visible(oid) owner to postgres;

create function pg_catalog.pg_stat_get_backend_activity_start(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_activity_start(integer) is 'statistics: start time for current query of backend';

alter function pg_catalog.pg_stat_get_backend_activity_start(integer) owner to postgres;

create function pg_catalog.pg_terminate_backend(integer)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_terminate_backend(integer) is 'terminate a server process';

alter function pg_catalog.pg_terminate_backend(integer) owner to postgres;

create function pg_catalog.pg_get_functiondef(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_functiondef(oid) is 'definition of a function';

alter function pg_catalog.pg_get_functiondef(oid) owner to postgres;

create function pg_catalog.text_pattern_lt(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_pattern_lt(text, text) is 'implementation of ~<~ operator';

alter function pg_catalog.text_pattern_lt(text, text) owner to postgres;

create function pg_catalog.text_pattern_le(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_pattern_le(text, text) is 'implementation of ~<=~ operator';

alter function pg_catalog.text_pattern_le(text, text) owner to postgres;

create function pg_catalog.pg_get_function_arguments(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_function_arguments(oid) is 'argument list of a function';

alter function pg_catalog.pg_get_function_arguments(oid) owner to postgres;

create function pg_catalog.text_pattern_ge(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_pattern_ge(text, text) is 'implementation of ~>=~ operator';

alter function pg_catalog.text_pattern_ge(text, text) owner to postgres;

create function pg_catalog.text_pattern_gt(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text_pattern_gt(text, text) is 'implementation of ~>~ operator';

alter function pg_catalog.text_pattern_gt(text, text) owner to postgres;

create function pg_catalog.pg_get_function_result(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_function_result(oid) is 'result type of a function';

alter function pg_catalog.pg_get_function_result(oid) owner to postgres;

create function pg_catalog.bttext_pattern_cmp(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bttext_pattern_cmp(text, text) is 'less-equal-greater';

alter function pg_catalog.bttext_pattern_cmp(text, text) owner to postgres;

create function pg_catalog.ceiling(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ceiling(numeric) is 'nearest integer >= value';

alter function pg_catalog.ceiling(numeric) owner to postgres;

create function pg_catalog.pg_database_size(name)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_database_size(name) is 'total disk space usage for the specified database';

alter function pg_catalog.pg_database_size(name) owner to postgres;

create function pg_catalog.power(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.power(numeric, numeric) is 'exponentiation';

alter function pg_catalog.power(numeric, numeric) owner to postgres;

create function pg_catalog.width_bucket(numeric, numeric, numeric, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.width_bucket(numeric, numeric, numeric, integer) is 'bucket number of operand in equal-width histogram';

alter function pg_catalog.width_bucket(numeric, numeric, numeric, integer) owner to postgres;

create function pg_catalog.pg_cancel_backend(integer)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_cancel_backend(integer) is 'cancel a server process'' current query';

alter function pg_catalog.pg_cancel_backend(integer) owner to postgres;

create function pg_catalog.pg_start_backup(label text, fast boolean default false, exclusive boolean default true)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_start_backup(text, boolean, boolean) is 'prepare for taking an online backup';

alter function pg_catalog.pg_start_backup(text, boolean, boolean) owner to postgres;

create function pg_catalog.pg_stop_backup()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stop_backup() is 'finish taking an online backup';

alter function pg_catalog.pg_stop_backup() owner to postgres;

create function pg_catalog.bpchar_pattern_lt(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar_pattern_lt(char, char) is 'implementation of ~<~ operator';

alter function pg_catalog.bpchar_pattern_lt(char, char) owner to postgres;

create function pg_catalog.bpchar_pattern_le(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar_pattern_le(char, char) is 'implementation of ~<=~ operator';

alter function pg_catalog.bpchar_pattern_le(char, char) owner to postgres;

create function pg_catalog.array_length(anyarray, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_length(anyarray, integer) is 'array length';

alter function pg_catalog.array_length(anyarray, integer) owner to postgres;

create function pg_catalog.bpchar_pattern_ge(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar_pattern_ge(char, char) is 'implementation of ~>=~ operator';

alter function pg_catalog.bpchar_pattern_ge(char, char) owner to postgres;

create function pg_catalog.bpchar_pattern_gt(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar_pattern_gt(char, char) is 'implementation of ~>~ operator';

alter function pg_catalog.bpchar_pattern_gt(char, char) owner to postgres;

create function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) owner to postgres;

create function pg_catalog.btbpchar_pattern_cmp(char, char)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btbpchar_pattern_cmp(char, char) is 'less-equal-greater';

alter function pg_catalog.btbpchar_pattern_cmp(char, char) owner to postgres;

create function pg_catalog.has_sequence_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_sequence_privilege(name, text, text) is 'user privilege on sequence by username, seq name';

alter function pg_catalog.has_sequence_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_sequence_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_sequence_privilege(name, oid, text) is 'user privilege on sequence by username, seq oid';

alter function pg_catalog.has_sequence_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_sequence_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_sequence_privilege(oid, text, text) is 'user privilege on sequence by user oid, seq name';

alter function pg_catalog.has_sequence_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_sequence_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_sequence_privilege(oid, oid, text) is 'user privilege on sequence by user oid, seq oid';

alter function pg_catalog.has_sequence_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_sequence_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_sequence_privilege(text, text) is 'current user privilege on sequence by seq name';

alter function pg_catalog.has_sequence_privilege(text, text) owner to postgres;

create function pg_catalog.has_sequence_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_sequence_privilege(oid, text) is 'current user privilege on sequence by seq oid';

alter function pg_catalog.has_sequence_privilege(oid, text) owner to postgres;

create function pg_catalog.btint48cmp(integer, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint48cmp(integer, bigint) is 'less-equal-greater';

alter function pg_catalog.btint48cmp(integer, bigint) owner to postgres;

create function pg_catalog.btint84cmp(bigint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint84cmp(bigint, integer) is 'less-equal-greater';

alter function pg_catalog.btint84cmp(bigint, integer) owner to postgres;

create function pg_catalog.btint24cmp(smallint, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint24cmp(smallint, integer) is 'less-equal-greater';

alter function pg_catalog.btint24cmp(smallint, integer) owner to postgres;

create function pg_catalog.btint42cmp(integer, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint42cmp(integer, smallint) is 'less-equal-greater';

alter function pg_catalog.btint42cmp(integer, smallint) owner to postgres;

create function pg_catalog.btint28cmp(smallint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint28cmp(smallint, bigint) is 'less-equal-greater';

alter function pg_catalog.btint28cmp(smallint, bigint) owner to postgres;

create function pg_catalog.btint82cmp(bigint, smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint82cmp(bigint, smallint) is 'less-equal-greater';

alter function pg_catalog.btint82cmp(bigint, smallint) owner to postgres;

create function pg_catalog.btfloat48cmp(real, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btfloat48cmp(real, double precision) is 'less-equal-greater';

alter function pg_catalog.btfloat48cmp(real, double precision) owner to postgres;

create function pg_catalog.btfloat84cmp(double precision, real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btfloat84cmp(double precision, real) is 'less-equal-greater';

alter function pg_catalog.btfloat84cmp(double precision, real) owner to postgres;

create function pg_catalog.inet_client_addr()
    stable
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_client_addr() is 'inet address of the client';

alter function pg_catalog.inet_client_addr() owner to postgres;

create function pg_catalog.inet_client_port()
    stable
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_client_port() is 'client''s port number for this connection';

alter function pg_catalog.inet_client_port() owner to postgres;

create function pg_catalog.inet_server_addr()
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_server_addr() is 'inet address of the server';

alter function pg_catalog.inet_server_addr() owner to postgres;

create function pg_catalog.inet_server_port()
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_server_port() is 'server''s port number for this connection';

alter function pg_catalog.inet_server_port() owner to postgres;

create function pg_catalog.regprocedurein(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regprocedurein(cstring) is 'I/O';

alter function pg_catalog.regprocedurein(cstring) owner to postgres;

create function pg_catalog.regprocedureout(regprocedure)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regprocedureout(regprocedure) is 'I/O';

alter function pg_catalog.regprocedureout(regprocedure) owner to postgres;

create function pg_catalog.regoperin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regoperin(cstring) is 'I/O';

alter function pg_catalog.regoperin(cstring) owner to postgres;

create function pg_catalog.regoperout(regoper)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regoperout(regoper) is 'I/O';

alter function pg_catalog.regoperout(regoper) owner to postgres;

create function pg_catalog.regoperatorin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regoperatorin(cstring) is 'I/O';

alter function pg_catalog.regoperatorin(cstring) owner to postgres;

create function pg_catalog.regoperatorout(regoperator)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regoperatorout(regoperator) is 'I/O';

alter function pg_catalog.regoperatorout(regoperator) owner to postgres;

create function pg_catalog.regclassin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regclassin(cstring) is 'I/O';

alter function pg_catalog.regclassin(cstring) owner to postgres;

create function pg_catalog.regclassout(regclass)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regclassout(regclass) is 'I/O';

alter function pg_catalog.regclassout(regclass) owner to postgres;

create function pg_catalog.regtypein(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regtypein(cstring) is 'I/O';

alter function pg_catalog.regtypein(cstring) owner to postgres;

create function pg_catalog.regtypeout(regtype)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regtypeout(regtype) is 'I/O';

alter function pg_catalog.regtypeout(regtype) owner to postgres;

create function pg_catalog.pg_stat_clear_snapshot()
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_clear_snapshot() is 'statistics: discard current transaction''s statistics snapshot';

alter function pg_catalog.pg_stat_clear_snapshot() owner to postgres;

create function pg_catalog.pg_get_function_identity_arguments(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_function_identity_arguments(oid) is 'identity argument list of a function';

alter function pg_catalog.pg_get_function_identity_arguments(oid) owner to postgres;

create function pg_catalog.fmgr_internal_validator(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.fmgr_internal_validator(oid) is '(internal)';

alter function pg_catalog.fmgr_internal_validator(oid) owner to postgres;

create function pg_catalog.fmgr_c_validator(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.fmgr_c_validator(oid) is '(internal)';

alter function pg_catalog.fmgr_c_validator(oid) owner to postgres;

create function pg_catalog.fmgr_sql_validator(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.fmgr_sql_validator(oid) is '(internal)';

alter function pg_catalog.fmgr_sql_validator(oid) owner to postgres;

create function pg_catalog.has_database_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_database_privilege(name, text, text) is 'user privilege on database by username, database name';

alter function pg_catalog.has_database_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_database_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_database_privilege(name, oid, text) is 'user privilege on database by username, database oid';

alter function pg_catalog.has_database_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_database_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_database_privilege(oid, text, text) is 'user privilege on database by user oid, database name';

alter function pg_catalog.has_database_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_database_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_database_privilege(oid, oid, text) is 'user privilege on database by user oid, database oid';

alter function pg_catalog.has_database_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_database_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_database_privilege(text, text) is 'current user privilege on database by database name';

alter function pg_catalog.has_database_privilege(text, text) owner to postgres;

create function pg_catalog.has_database_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_database_privilege(oid, text) is 'current user privilege on database by database oid';

alter function pg_catalog.has_database_privilege(oid, text) owner to postgres;

create function pg_catalog.has_function_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_function_privilege(name, text, text) is 'user privilege on function by username, function name';

alter function pg_catalog.has_function_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_function_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_function_privilege(name, oid, text) is 'user privilege on function by username, function oid';

alter function pg_catalog.has_function_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_function_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_function_privilege(oid, text, text) is 'user privilege on function by user oid, function name';

alter function pg_catalog.has_function_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_function_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_function_privilege(oid, oid, text) is 'user privilege on function by user oid, function oid';

alter function pg_catalog.has_function_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_function_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_function_privilege(text, text) is 'current user privilege on function by function name';

alter function pg_catalog.has_function_privilege(text, text) owner to postgres;

create function pg_catalog.has_function_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_function_privilege(oid, text) is 'current user privilege on function by function oid';

alter function pg_catalog.has_function_privilege(oid, text) owner to postgres;

create function pg_catalog.has_language_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_language_privilege(name, text, text) is 'user privilege on language by username, language name';

alter function pg_catalog.has_language_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_language_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_language_privilege(name, oid, text) is 'user privilege on language by username, language oid';

alter function pg_catalog.has_language_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_language_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_language_privilege(oid, text, text) is 'user privilege on language by user oid, language name';

alter function pg_catalog.has_language_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_language_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_language_privilege(oid, oid, text) is 'user privilege on language by user oid, language oid';

alter function pg_catalog.has_language_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_language_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_language_privilege(text, text) is 'current user privilege on language by language name';

alter function pg_catalog.has_language_privilege(text, text) owner to postgres;

create function pg_catalog.has_language_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_language_privilege(oid, text) is 'current user privilege on language by language oid';

alter function pg_catalog.has_language_privilege(oid, text) owner to postgres;

create function pg_catalog.has_schema_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_schema_privilege(name, text, text) is 'user privilege on schema by username, schema name';

alter function pg_catalog.has_schema_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_schema_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_schema_privilege(name, oid, text) is 'user privilege on schema by username, schema oid';

alter function pg_catalog.has_schema_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_schema_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_schema_privilege(oid, text, text) is 'user privilege on schema by user oid, schema name';

alter function pg_catalog.has_schema_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_schema_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_schema_privilege(oid, oid, text) is 'user privilege on schema by user oid, schema oid';

alter function pg_catalog.has_schema_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_schema_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_schema_privilege(text, text) is 'current user privilege on schema by schema name';

alter function pg_catalog.has_schema_privilege(text, text) owner to postgres;

create function pg_catalog.has_schema_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_schema_privilege(oid, text) is 'current user privilege on schema by schema oid';

alter function pg_catalog.has_schema_privilege(oid, text) owner to postgres;

create function pg_catalog.pg_stat_reset()
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_reset() is 'statistics: reset collected statistics for current database';

alter function pg_catalog.pg_stat_reset() owner to postgres;

create function pg_catalog.regexp_replace(text, text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexp_replace(text, text, text) is 'replace text using regexp';

alter function pg_catalog.regexp_replace(text, text, text) owner to postgres;

create function pg_catalog.regexp_replace(text, text, text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexp_replace(text, text, text, text) is 'replace text using regexp';

alter function pg_catalog.regexp_replace(text, text, text, text) owner to postgres;

create function pg_catalog.pg_total_relation_size(regclass)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_total_relation_size(regclass) is 'total disk space usage for the specified table and associated indexes';

alter function pg_catalog.pg_total_relation_size(regclass) owner to postgres;

create function pg_catalog.pg_size_pretty(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_size_pretty(bigint) is 'convert a long int to a human readable text using size units';

alter function pg_catalog.pg_size_pretty(bigint) owner to postgres;

create function pg_catalog.pg_options_to_table(options_array text[], out option_name text, out option_value text)
    stable
    strict
    parallel safe
    cost 1
    rows 3
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_options_to_table(text[], out text, out text) is 'convert generic options array to name/value table';

alter function pg_catalog.pg_options_to_table(text[], out text, out text) owner to postgres;

create function pg_catalog.record_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.record_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.record_out(record)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_out(record) is 'I/O';

alter function pg_catalog.record_out(record) owner to postgres;

create function pg_catalog.cstring_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cstring_in(cstring) is 'I/O';

alter function pg_catalog.cstring_in(cstring) owner to postgres;

create function pg_catalog.cstring_out(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cstring_out(cstring) is 'I/O';

alter function pg_catalog.cstring_out(cstring) owner to postgres;

create function pg_catalog.any_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.any_in(cstring) is 'I/O';

alter function pg_catalog.any_in(cstring) owner to postgres;

create function pg_catalog.any_out("any")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.any_out("any") is 'I/O';

alter function pg_catalog.any_out("any") owner to postgres;

create function pg_catalog.anyarray_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyarray_in(cstring) is 'I/O';

alter function pg_catalog.anyarray_in(cstring) owner to postgres;

create function pg_catalog.anyarray_out(anyarray)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyarray_out(anyarray) is 'I/O';

alter function pg_catalog.anyarray_out(anyarray) owner to postgres;

create function pg_catalog.void_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.void_in(cstring) is 'I/O';

alter function pg_catalog.void_in(cstring) owner to postgres;

create function pg_catalog.void_out(void)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.void_out(void) is 'I/O';

alter function pg_catalog.void_out(void) owner to postgres;

create function pg_catalog.trigger_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.trigger_in(cstring) is 'I/O';

alter function pg_catalog.trigger_in(cstring) owner to postgres;

create function pg_catalog.trigger_out(trigger)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.trigger_out(trigger) is 'I/O';

alter function pg_catalog.trigger_out(trigger) owner to postgres;

create function pg_catalog.language_handler_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.language_handler_in(cstring) is 'I/O';

alter function pg_catalog.language_handler_in(cstring) owner to postgres;

create function pg_catalog.language_handler_out(language_handler)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.language_handler_out(language_handler) is 'I/O';

alter function pg_catalog.language_handler_out(language_handler) owner to postgres;

create function pg_catalog.internal_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.internal_in(cstring) is 'I/O';

alter function pg_catalog.internal_in(cstring) owner to postgres;

create function pg_catalog.internal_out(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.internal_out(internal) is 'I/O';

alter function pg_catalog.internal_out(internal) owner to postgres;

create function pg_catalog.opaque_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.opaque_in(cstring) is 'I/O';

alter function pg_catalog.opaque_in(cstring) owner to postgres;

create function pg_catalog.opaque_out(opaque)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.opaque_out(opaque) is 'I/O';

alter function pg_catalog.opaque_out(opaque) owner to postgres;

create function pg_catalog.ceil(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ceil(double precision) is 'nearest integer >= value';

alter function pg_catalog.ceil(double precision) owner to postgres;

create function pg_catalog.floor(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.floor(double precision) is 'nearest integer <= value';

alter function pg_catalog.floor(double precision) owner to postgres;

create function pg_catalog.sign(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.sign(double precision) is 'sign of value';

alter function pg_catalog.sign(double precision) owner to postgres;

create function pg_catalog.md5(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.md5(text) is 'MD5 hash';

alter function pg_catalog.md5(text) owner to postgres;

create function pg_catalog.anyelement_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyelement_in(cstring) is 'I/O';

alter function pg_catalog.anyelement_in(cstring) owner to postgres;

create function pg_catalog.anyelement_out(anyelement)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyelement_out(anyelement) is 'I/O';

alter function pg_catalog.anyelement_out(anyelement) owner to postgres;

create function pg_catalog.postgresql_fdw_validator(text[], oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.postgresql_fdw_validator(text[], oid) is '(internal)';

alter function pg_catalog.postgresql_fdw_validator(text[], oid) owner to postgres;

create function pg_catalog.pg_encoding_max_length(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_encoding_max_length(integer) is 'maximum octet length of a character in given encoding';

alter function pg_catalog.pg_encoding_max_length(integer) owner to postgres;

create function pg_catalog.ceiling(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ceiling(double precision) is 'nearest integer >= value';

alter function pg_catalog.ceiling(double precision) owner to postgres;

create function pg_catalog.md5(bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.md5(bytea) is 'MD5 hash';

alter function pg_catalog.md5(bytea) owner to postgres;

create function pg_catalog.pg_tablespace_size(oid)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_tablespace_size(oid) is 'total disk space usage for the specified tablespace';

alter function pg_catalog.pg_tablespace_size(oid) owner to postgres;

create function pg_catalog.pg_tablespace_size(name)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_tablespace_size(name) is 'total disk space usage for the specified tablespace';

alter function pg_catalog.pg_tablespace_size(name) owner to postgres;

create function pg_catalog.pg_database_size(oid)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_database_size(oid) is 'total disk space usage for the specified database';

alter function pg_catalog.pg_database_size(oid) owner to postgres;

create function pg_catalog.pg_relation_size(regclass) returns bigint
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.pg_relation_size($1, 'main')
$$;

comment on function pg_catalog.pg_relation_size(regclass) is 'disk space usage for the main fork of the specified table or index';

alter function pg_catalog.pg_relation_size(regclass) owner to postgres;

create function pg_catalog.unnest(anyarray)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.unnest(anyarray) is 'expand array to set of rows';

alter function pg_catalog.unnest(anyarray) owner to postgres;

create function pg_catalog.pg_relation_size(regclass, text)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_relation_size(regclass, text) is 'disk space usage for the specified fork of a table or index';

alter function pg_catalog.pg_relation_size(regclass, text) owner to postgres;

create function pg_catalog.array_agg_transfn(internal, anynonarray)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_agg_transfn(internal, anynonarray) is 'aggregate transition function';

alter function pg_catalog.array_agg_transfn(internal, anynonarray) owner to postgres;

create function pg_catalog.array_agg_finalfn(internal, anynonarray)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_agg_finalfn(internal, anynonarray) is 'aggregate final function';

alter function pg_catalog.array_agg_finalfn(internal, anynonarray) owner to postgres;

create function pg_catalog.date_lt_timestamp(date, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_lt_timestamp(date, timestamp) is 'implementation of < operator';

alter function pg_catalog.date_lt_timestamp(date, timestamp) owner to postgres;

create function pg_catalog.date_le_timestamp(date, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_le_timestamp(date, timestamp) is 'implementation of <= operator';

alter function pg_catalog.date_le_timestamp(date, timestamp) owner to postgres;

create function pg_catalog.date_eq_timestamp(date, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_eq_timestamp(date, timestamp) is 'implementation of = operator';

alter function pg_catalog.date_eq_timestamp(date, timestamp) owner to postgres;

create function pg_catalog.date_gt_timestamp(date, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_gt_timestamp(date, timestamp) is 'implementation of > operator';

alter function pg_catalog.date_gt_timestamp(date, timestamp) owner to postgres;

create function pg_catalog.date_ge_timestamp(date, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_ge_timestamp(date, timestamp) is 'implementation of >= operator';

alter function pg_catalog.date_ge_timestamp(date, timestamp) owner to postgres;

create function pg_catalog.date_ne_timestamp(date, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_ne_timestamp(date, timestamp) is 'implementation of <> operator';

alter function pg_catalog.date_ne_timestamp(date, timestamp) owner to postgres;

create function pg_catalog.date_cmp_timestamp(date, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_cmp_timestamp(date, timestamp) is 'less-equal-greater';

alter function pg_catalog.date_cmp_timestamp(date, timestamp) owner to postgres;

create function pg_catalog.date_lt_timestamptz(date, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_lt_timestamptz(date, timestamp with time zone) is 'implementation of < operator';

alter function pg_catalog.date_lt_timestamptz(date, timestamp with time zone) owner to postgres;

create function pg_catalog.date_le_timestamptz(date, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_le_timestamptz(date, timestamp with time zone) is 'implementation of <= operator';

alter function pg_catalog.date_le_timestamptz(date, timestamp with time zone) owner to postgres;

create function pg_catalog.date_eq_timestamptz(date, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_eq_timestamptz(date, timestamp with time zone) is 'implementation of = operator';

alter function pg_catalog.date_eq_timestamptz(date, timestamp with time zone) owner to postgres;

create function pg_catalog.date_gt_timestamptz(date, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_gt_timestamptz(date, timestamp with time zone) is 'implementation of > operator';

alter function pg_catalog.date_gt_timestamptz(date, timestamp with time zone) owner to postgres;

create function pg_catalog.date_ge_timestamptz(date, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_ge_timestamptz(date, timestamp with time zone) is 'implementation of >= operator';

alter function pg_catalog.date_ge_timestamptz(date, timestamp with time zone) owner to postgres;

create function pg_catalog.date_ne_timestamptz(date, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_ne_timestamptz(date, timestamp with time zone) is 'implementation of <> operator';

alter function pg_catalog.date_ne_timestamptz(date, timestamp with time zone) owner to postgres;

create function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) is 'less-equal-greater';

alter function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamp_lt_date(timestamp, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_lt_date(timestamp, date) is 'implementation of < operator';

alter function pg_catalog.timestamp_lt_date(timestamp, date) owner to postgres;

create function pg_catalog.timestamp_le_date(timestamp, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_le_date(timestamp, date) is 'implementation of <= operator';

alter function pg_catalog.timestamp_le_date(timestamp, date) owner to postgres;

create function pg_catalog.timestamp_eq_date(timestamp, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_eq_date(timestamp, date) is 'implementation of = operator';

alter function pg_catalog.timestamp_eq_date(timestamp, date) owner to postgres;

create function pg_catalog.timestamp_gt_date(timestamp, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_gt_date(timestamp, date) is 'implementation of > operator';

alter function pg_catalog.timestamp_gt_date(timestamp, date) owner to postgres;

create function pg_catalog.timestamp_ge_date(timestamp, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_ge_date(timestamp, date) is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge_date(timestamp, date) owner to postgres;

create function pg_catalog.timestamp_ne_date(timestamp, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_ne_date(timestamp, date) is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne_date(timestamp, date) owner to postgres;

create function pg_catalog.timestamp_cmp_date(timestamp, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_cmp_date(timestamp, date) is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp_date(timestamp, date) owner to postgres;

create function pg_catalog.timestamptz_lt_date(timestamp with time zone, date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_lt_date(timestamp with time zone, date) is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt_date(timestamp with time zone, date) owner to postgres;

create function pg_catalog.timestamptz_le_date(timestamp with time zone, date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_le_date(timestamp with time zone, date) is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le_date(timestamp with time zone, date) owner to postgres;

create function pg_catalog.timestamptz_eq_date(timestamp with time zone, date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_eq_date(timestamp with time zone, date) is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq_date(timestamp with time zone, date) owner to postgres;

create function pg_catalog.timestamptz_gt_date(timestamp with time zone, date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_gt_date(timestamp with time zone, date) is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt_date(timestamp with time zone, date) owner to postgres;

create function pg_catalog.timestamptz_ge_date(timestamp with time zone, date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_ge_date(timestamp with time zone, date) is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge_date(timestamp with time zone, date) owner to postgres;

create function pg_catalog.timestamptz_ne_date(timestamp with time zone, date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_ne_date(timestamp with time zone, date) is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne_date(timestamp with time zone, date) owner to postgres;

create function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) owner to postgres;

create function pg_catalog.has_tablespace_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_tablespace_privilege(name, text, text) is 'user privilege on tablespace by username, tablespace name';

alter function pg_catalog.has_tablespace_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_tablespace_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_tablespace_privilege(name, oid, text) is 'user privilege on tablespace by username, tablespace oid';

alter function pg_catalog.has_tablespace_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_tablespace_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_tablespace_privilege(oid, text, text) is 'user privilege on tablespace by user oid, tablespace name';

alter function pg_catalog.has_tablespace_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_tablespace_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_tablespace_privilege(oid, oid, text) is 'user privilege on tablespace by user oid, tablespace oid';

alter function pg_catalog.has_tablespace_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_tablespace_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_tablespace_privilege(text, text) is 'current user privilege on tablespace by tablespace name';

alter function pg_catalog.has_tablespace_privilege(text, text) owner to postgres;

create function pg_catalog.has_tablespace_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_tablespace_privilege(oid, text) is 'current user privilege on tablespace by tablespace oid';

alter function pg_catalog.has_tablespace_privilege(oid, text) owner to postgres;

create function pg_catalog.shell_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.shell_in(cstring) is 'I/O';

alter function pg_catalog.shell_in(cstring) owner to postgres;

create function pg_catalog.shell_out(opaque)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.shell_out(opaque) is 'I/O';

alter function pg_catalog.shell_out(opaque) owner to postgres;

create function pg_catalog.array_recv(internal, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.array_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.array_send(anyarray)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_send(anyarray) is 'I/O';

alter function pg_catalog.array_send(anyarray) owner to postgres;

create function pg_catalog.record_recv(internal, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.record_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.record_send(record)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_send(record) is 'I/O';

alter function pg_catalog.record_send(record) owner to postgres;

create function pg_catalog.int2recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2recv(internal) is 'I/O';

alter function pg_catalog.int2recv(internal) owner to postgres;

create function pg_catalog.int2send(smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2send(smallint) is 'I/O';

alter function pg_catalog.int2send(smallint) owner to postgres;

create function pg_catalog.int4recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4recv(internal) is 'I/O';

alter function pg_catalog.int4recv(internal) owner to postgres;

create function pg_catalog.int4send(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4send(integer) is 'I/O';

alter function pg_catalog.int4send(integer) owner to postgres;

create function pg_catalog.int8recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8recv(internal) is 'I/O';

alter function pg_catalog.int8recv(internal) owner to postgres;

create function pg_catalog.int8send(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8send(bigint) is 'I/O';

alter function pg_catalog.int8send(bigint) owner to postgres;

create function pg_catalog.int2vectorrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2vectorrecv(internal) is 'I/O';

alter function pg_catalog.int2vectorrecv(internal) owner to postgres;

create function pg_catalog.int2vectorsend(int2vector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2vectorsend(int2vector) is 'I/O';

alter function pg_catalog.int2vectorsend(int2vector) owner to postgres;

create function pg_catalog.bytearecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bytearecv(internal) is 'I/O';

alter function pg_catalog.bytearecv(internal) owner to postgres;

create function pg_catalog.byteasend(bytea)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.byteasend(bytea) is 'I/O';

alter function pg_catalog.byteasend(bytea) owner to postgres;

create function pg_catalog.textrecv(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textrecv(internal) is 'I/O';

alter function pg_catalog.textrecv(internal) owner to postgres;

create function pg_catalog.textsend(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.textsend(text) is 'I/O';

alter function pg_catalog.textsend(text) owner to postgres;

create function pg_catalog.unknownrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.unknownrecv(internal) is 'I/O';

alter function pg_catalog.unknownrecv(internal) owner to postgres;

create function pg_catalog.unknownsend(unknown)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.unknownsend(unknown) is 'I/O';

alter function pg_catalog.unknownsend(unknown) owner to postgres;

create function pg_catalog.oidrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidrecv(internal) is 'I/O';

alter function pg_catalog.oidrecv(internal) owner to postgres;

create function pg_catalog.oidsend(oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidsend(oid) is 'I/O';

alter function pg_catalog.oidsend(oid) owner to postgres;

create function pg_catalog.oidvectorrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorrecv(internal) is 'I/O';

alter function pg_catalog.oidvectorrecv(internal) owner to postgres;

create function pg_catalog.oidvectorsend(oidvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.oidvectorsend(oidvector) is 'I/O';

alter function pg_catalog.oidvectorsend(oidvector) owner to postgres;

create function pg_catalog.namerecv(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namerecv(internal) is 'I/O';

alter function pg_catalog.namerecv(internal) owner to postgres;

create function pg_catalog.namesend(name)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.namesend(name) is 'I/O';

alter function pg_catalog.namesend(name) owner to postgres;

create function pg_catalog.float4recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4recv(internal) is 'I/O';

alter function pg_catalog.float4recv(internal) owner to postgres;

create function pg_catalog.float4send(real)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float4send(real) is 'I/O';

alter function pg_catalog.float4send(real) owner to postgres;

create function pg_catalog.float8recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8recv(internal) is 'I/O';

alter function pg_catalog.float8recv(internal) owner to postgres;

create function pg_catalog.float8send(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8send(double precision) is 'I/O';

alter function pg_catalog.float8send(double precision) owner to postgres;

create function pg_catalog.point_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_recv(internal) is 'I/O';

alter function pg_catalog.point_recv(internal) owner to postgres;

create function pg_catalog.point_send(point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.point_send(point) is 'I/O';

alter function pg_catalog.point_send(point) owner to postgres;

create function pg_catalog.bpcharrecv(internal, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharrecv(internal, oid, integer) is 'I/O';

alter function pg_catalog.bpcharrecv(internal, oid, integer) owner to postgres;

create function pg_catalog.bpcharsend(char)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpcharsend(char) is 'I/O';

alter function pg_catalog.bpcharsend(char) owner to postgres;

create function pg_catalog.varcharrecv(internal, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varcharrecv(internal, oid, integer) is 'I/O';

alter function pg_catalog.varcharrecv(internal, oid, integer) owner to postgres;

create function pg_catalog.varcharsend(varchar)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varcharsend(varchar) is 'I/O';

alter function pg_catalog.varcharsend(varchar) owner to postgres;

create function pg_catalog.charrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.charrecv(internal) is 'I/O';

alter function pg_catalog.charrecv(internal) owner to postgres;

create function pg_catalog.charsend("char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.charsend("char") is 'I/O';

alter function pg_catalog.charsend("char") owner to postgres;

create function pg_catalog.boolrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolrecv(internal) is 'I/O';

alter function pg_catalog.boolrecv(internal) owner to postgres;

create function pg_catalog.boolsend(boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolsend(boolean) is 'I/O';

alter function pg_catalog.boolsend(boolean) owner to postgres;

create function pg_catalog.tidrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidrecv(internal) is 'I/O';

alter function pg_catalog.tidrecv(internal) owner to postgres;

create function pg_catalog.tidsend(tid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidsend(tid) is 'I/O';

alter function pg_catalog.tidsend(tid) owner to postgres;

create function pg_catalog.xidrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xidrecv(internal) is 'I/O';

alter function pg_catalog.xidrecv(internal) owner to postgres;

create function pg_catalog.xidsend(xid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xidsend(xid) is 'I/O';

alter function pg_catalog.xidsend(xid) owner to postgres;

create function pg_catalog.cidrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidrecv(internal) is 'I/O';

alter function pg_catalog.cidrecv(internal) owner to postgres;

create function pg_catalog.cidsend(cid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidsend(cid) is 'I/O';

alter function pg_catalog.cidsend(cid) owner to postgres;

create function pg_catalog.regprocrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regprocrecv(internal) is 'I/O';

alter function pg_catalog.regprocrecv(internal) owner to postgres;

create function pg_catalog.regprocsend(regproc)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regprocsend(regproc) is 'I/O';

alter function pg_catalog.regprocsend(regproc) owner to postgres;

create function pg_catalog.regprocedurerecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regprocedurerecv(internal) is 'I/O';

alter function pg_catalog.regprocedurerecv(internal) owner to postgres;

create function pg_catalog.regproceduresend(regprocedure)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regproceduresend(regprocedure) is 'I/O';

alter function pg_catalog.regproceduresend(regprocedure) owner to postgres;

create function pg_catalog.regoperrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regoperrecv(internal) is 'I/O';

alter function pg_catalog.regoperrecv(internal) owner to postgres;

create function pg_catalog.regopersend(regoper)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regopersend(regoper) is 'I/O';

alter function pg_catalog.regopersend(regoper) owner to postgres;

create function pg_catalog.regoperatorrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regoperatorrecv(internal) is 'I/O';

alter function pg_catalog.regoperatorrecv(internal) owner to postgres;

create function pg_catalog.regoperatorsend(regoperator)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regoperatorsend(regoperator) is 'I/O';

alter function pg_catalog.regoperatorsend(regoperator) owner to postgres;

create function pg_catalog.regclassrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regclassrecv(internal) is 'I/O';

alter function pg_catalog.regclassrecv(internal) owner to postgres;

create function pg_catalog.regclasssend(regclass)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regclasssend(regclass) is 'I/O';

alter function pg_catalog.regclasssend(regclass) owner to postgres;

create function pg_catalog.regtyperecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regtyperecv(internal) is 'I/O';

alter function pg_catalog.regtyperecv(internal) owner to postgres;

create function pg_catalog.regtypesend(regtype)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regtypesend(regtype) is 'I/O';

alter function pg_catalog.regtypesend(regtype) owner to postgres;

create function pg_catalog.bit_recv(internal, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bit_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.bit_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.bit_send(bit)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bit_send(bit) is 'I/O';

alter function pg_catalog.bit_send(bit) owner to postgres;

create function pg_catalog.varbit_recv(internal, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbit_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.varbit_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.varbit_send(bit varying)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbit_send(bit varying) is 'I/O';

alter function pg_catalog.varbit_send(bit varying) owner to postgres;

create function pg_catalog.numeric_recv(internal, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.numeric_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.numeric_send(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_send(numeric) is 'I/O';

alter function pg_catalog.numeric_send(numeric) owner to postgres;

create function pg_catalog.abstimerecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimerecv(internal) is 'I/O';

alter function pg_catalog.abstimerecv(internal) owner to postgres;

create function pg_catalog.abstimesend(abstime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.abstimesend(abstime) is 'I/O';

alter function pg_catalog.abstimesend(abstime) owner to postgres;

create function pg_catalog.reltimerecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimerecv(internal) is 'I/O';

alter function pg_catalog.reltimerecv(internal) owner to postgres;

create function pg_catalog.reltimesend(reltime)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reltimesend(reltime) is 'I/O';

alter function pg_catalog.reltimesend(reltime) owner to postgres;

create function pg_catalog.tintervalrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalrecv(internal) is 'I/O';

alter function pg_catalog.tintervalrecv(internal) owner to postgres;

create function pg_catalog.tintervalsend(tinterval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tintervalsend(tinterval) is 'I/O';

alter function pg_catalog.tintervalsend(tinterval) owner to postgres;

create function pg_catalog.date_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_recv(internal) is 'I/O';

alter function pg_catalog.date_recv(internal) owner to postgres;

create function pg_catalog.date_send(date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_send(date) is 'I/O';

alter function pg_catalog.date_send(date) owner to postgres;

create function pg_catalog.time_recv(internal, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.time_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.time_send(time)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_send(time) is 'I/O';

alter function pg_catalog.time_send(time) owner to postgres;

create function pg_catalog.timetz_recv(internal, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.timetz_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.timetz_send(time with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetz_send(time with time zone) is 'I/O';

alter function pg_catalog.timetz_send(time with time zone) owner to postgres;

create function pg_catalog.timestamp_recv(internal, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.timestamp_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.timestamp_send(timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_send(timestamp) is 'I/O';

alter function pg_catalog.timestamp_send(timestamp) owner to postgres;

create function pg_catalog.timestamptz_recv(internal, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.timestamptz_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.timestamptz_send(timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_send(timestamp with time zone) is 'I/O';

alter function pg_catalog.timestamptz_send(timestamp with time zone) owner to postgres;

create function pg_catalog.interval_recv(internal, oid, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.interval_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.interval_send(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_send(interval) is 'I/O';

alter function pg_catalog.interval_send(interval) owner to postgres;

create function pg_catalog.lseg_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_recv(internal) is 'I/O';

alter function pg_catalog.lseg_recv(internal) owner to postgres;

create function pg_catalog.lseg_send(lseg)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lseg_send(lseg) is 'I/O';

alter function pg_catalog.lseg_send(lseg) owner to postgres;

create function pg_catalog.path_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_recv(internal) is 'I/O';

alter function pg_catalog.path_recv(internal) owner to postgres;

create function pg_catalog.path_send(path)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.path_send(path) is 'I/O';

alter function pg_catalog.path_send(path) owner to postgres;

create function pg_catalog.box_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_recv(internal) is 'I/O';

alter function pg_catalog.box_recv(internal) owner to postgres;

create function pg_catalog.box_send(box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_send(box) is 'I/O';

alter function pg_catalog.box_send(box) owner to postgres;

create function pg_catalog.poly_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_recv(internal) is 'I/O';

alter function pg_catalog.poly_recv(internal) owner to postgres;

create function pg_catalog.poly_send(polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_send(polygon) is 'I/O';

alter function pg_catalog.poly_send(polygon) owner to postgres;

create function pg_catalog.line_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_recv(internal) is 'I/O';

alter function pg_catalog.line_recv(internal) owner to postgres;

create function pg_catalog.line_send(line)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.line_send(line) is 'I/O';

alter function pg_catalog.line_send(line) owner to postgres;

create function pg_catalog.circle_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_recv(internal) is 'I/O';

alter function pg_catalog.circle_recv(internal) owner to postgres;

create function pg_catalog.circle_send(circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_send(circle) is 'I/O';

alter function pg_catalog.circle_send(circle) owner to postgres;

create function pg_catalog.cash_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_recv(internal) is 'I/O';

alter function pg_catalog.cash_recv(internal) owner to postgres;

create function pg_catalog.cash_send(money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_send(money) is 'I/O';

alter function pg_catalog.cash_send(money) owner to postgres;

create function pg_catalog.macaddr_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_recv(internal) is 'I/O';

alter function pg_catalog.macaddr_recv(internal) owner to postgres;

create function pg_catalog.macaddr_send(macaddr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_send(macaddr) is 'I/O';

alter function pg_catalog.macaddr_send(macaddr) owner to postgres;

create function pg_catalog.inet_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_recv(internal) is 'I/O';

alter function pg_catalog.inet_recv(internal) owner to postgres;

create function pg_catalog.inet_send(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_send(inet) is 'I/O';

alter function pg_catalog.inet_send(inet) owner to postgres;

create function pg_catalog.cidr_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidr_recv(internal) is 'I/O';

alter function pg_catalog.cidr_recv(internal) owner to postgres;

create function pg_catalog.cidr_send(cidr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cidr_send(cidr) is 'I/O';

alter function pg_catalog.cidr_send(cidr) owner to postgres;

create function pg_catalog.cstring_recv(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cstring_recv(internal) is 'I/O';

alter function pg_catalog.cstring_recv(internal) owner to postgres;

create function pg_catalog.cstring_send(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cstring_send(cstring) is 'I/O';

alter function pg_catalog.cstring_send(cstring) owner to postgres;

create function pg_catalog.anyarray_recv(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyarray_recv(internal) is 'I/O';

alter function pg_catalog.anyarray_recv(internal) owner to postgres;

create function pg_catalog.anyarray_send(anyarray)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyarray_send(anyarray) is 'I/O';

alter function pg_catalog.anyarray_send(anyarray) owner to postgres;

create function pg_catalog.pg_get_ruledef(oid, boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_ruledef(oid, boolean) is 'source text of a rule with pretty-print option';

alter function pg_catalog.pg_get_ruledef(oid, boolean) owner to postgres;

create function pg_catalog.pg_get_viewdef(text, boolean)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_viewdef(text, boolean) is 'select statement of a view with pretty-print option';

alter function pg_catalog.pg_get_viewdef(text, boolean) owner to postgres;

create function pg_catalog.pg_get_viewdef(oid, boolean)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_viewdef(oid, boolean) is 'select statement of a view with pretty-print option';

alter function pg_catalog.pg_get_viewdef(oid, boolean) owner to postgres;

create function pg_catalog.pg_get_indexdef(oid, integer, boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_indexdef(oid, integer, boolean) is 'index description (full create statement or single expression) with pretty-print option';

alter function pg_catalog.pg_get_indexdef(oid, integer, boolean) owner to postgres;

create function pg_catalog.pg_get_constraintdef(oid, boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_constraintdef(oid, boolean) is 'constraint description with pretty-print option';

alter function pg_catalog.pg_get_constraintdef(oid, boolean) owner to postgres;

create function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean) is 'deparse an encoded expression with pretty-print option';

alter function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean) owner to postgres;

create function pg_catalog.pg_prepared_statement(out name text, out statement text,
                                                 out prepare_time timestamp with time zone,
                                                 out parameter_types regtype[], out from_sql boolean)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_prepared_statement(out text, out text, out timestamp with time zone, out regtype[], out boolean) is 'get the prepared statements for this session';

alter function pg_catalog.pg_prepared_statement(out text, out text, out timestamp with time zone, out regtype[], out boolean) owner to postgres;

create function pg_catalog.pg_cursor(out name text, out statement text, out is_holdable boolean, out is_binary boolean,
                                     out is_scrollable boolean, out creation_time timestamp with time zone)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_cursor(out text, out text, out boolean, out boolean, out boolean, out timestamp with time zone) is 'get the open cursors for this session';

alter function pg_catalog.pg_cursor(out text, out text, out boolean, out boolean, out boolean, out timestamp with time zone) owner to postgres;

create function pg_catalog.float8_var_pop(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_var_pop(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_var_pop(double precision[]) owner to postgres;

create function pg_catalog.float8_stddev_pop(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_stddev_pop(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_stddev_pop(double precision[]) owner to postgres;

create function pg_catalog.numeric_var_pop(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_var_pop(internal) is 'aggregate final function';

alter function pg_catalog.numeric_var_pop(internal) owner to postgres;

create function pg_catalog.booland_statefunc(boolean, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.booland_statefunc(boolean, boolean) is 'aggregate transition function';

alter function pg_catalog.booland_statefunc(boolean, boolean) owner to postgres;

create function pg_catalog.boolor_statefunc(boolean, boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.boolor_statefunc(boolean, boolean) is 'aggregate transition function';

alter function pg_catalog.boolor_statefunc(boolean, boolean) owner to postgres;

create function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone) is 'implementation of < operator';

alter function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone) is 'implementation of <= operator';

alter function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone) is 'implementation of = operator';

alter function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone) is 'implementation of > operator';

alter function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone) is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone) is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone) is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone) owner to postgres;

create function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp) is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp) owner to postgres;

create function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp) is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp) owner to postgres;

create function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp) is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp) owner to postgres;

create function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp) is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp) owner to postgres;

create function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp) is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp) owner to postgres;

create function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp) is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp) owner to postgres;

create function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp) is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp) owner to postgres;

create function pg_catalog.interval_pl_date(interval, date) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_date(interval, date) is 'implementation of + operator';

alter function pg_catalog.interval_pl_date(interval, date) owner to postgres;

create function pg_catalog.interval_pl_timetz(interval, time with time zone) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timetz(interval, time with time zone) is 'implementation of + operator';

alter function pg_catalog.interval_pl_timetz(interval, time with time zone) owner to postgres;

create function pg_catalog.interval_pl_timestamp(interval, timestamp without time zone) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timestamp(interval, timestamp) is 'implementation of + operator';

alter function pg_catalog.interval_pl_timestamp(interval, timestamp) owner to postgres;

create function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $2 + $1
$$;

comment on function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) is 'implementation of + operator';

alter function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) owner to postgres;

create function pg_catalog.integer_pl_date(integer, date) returns date
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $2 + $1
$$;

comment on function pg_catalog.integer_pl_date(integer, date) is 'implementation of + operator';

alter function pg_catalog.integer_pl_date(integer, date) owner to postgres;

create function pg_catalog.pg_tablespace_databases(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_tablespace_databases(oid) is 'get OIDs of databases in a tablespace';

alter function pg_catalog.pg_tablespace_databases(oid) owner to postgres;

create function pg_catalog.bool(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bool(integer) is 'convert int4 to boolean';

alter function pg_catalog.bool(integer) owner to postgres;

create function pg_catalog.int4(boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4(boolean) is 'convert boolean to int4';

alter function pg_catalog.int4(boolean) owner to postgres;

create function pg_catalog.lastval()
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lastval() is 'current value from last used sequence';

alter function pg_catalog.lastval() owner to postgres;

create function pg_catalog.pg_postmaster_start_time()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_postmaster_start_time() is 'postmaster start time';

alter function pg_catalog.pg_postmaster_start_time() owner to postgres;

create function pg_catalog.pg_blocking_pids(integer)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_blocking_pids(integer) is 'get array of PIDs of sessions blocking specified backend PID';

alter function pg_catalog.pg_blocking_pids(integer) owner to postgres;

create function pg_catalog.box_below(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_below(box, box) is 'implementation of <<| operator';

alter function pg_catalog.box_below(box, box) owner to postgres;

create function pg_catalog.box_overbelow(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_overbelow(box, box) is 'implementation of &<| operator';

alter function pg_catalog.box_overbelow(box, box) owner to postgres;

create function pg_catalog.box_overabove(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_overabove(box, box) is 'implementation of |&> operator';

alter function pg_catalog.box_overabove(box, box) owner to postgres;

create function pg_catalog.box_above(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box_above(box, box) is 'implementation of |>> operator';

alter function pg_catalog.box_above(box, box) owner to postgres;

create function pg_catalog.poly_below(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_below(polygon, polygon) is 'implementation of <<| operator';

alter function pg_catalog.poly_below(polygon, polygon) owner to postgres;

create function pg_catalog.poly_overbelow(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_overbelow(polygon, polygon) is 'implementation of &<| operator';

alter function pg_catalog.poly_overbelow(polygon, polygon) owner to postgres;

create function pg_catalog.poly_overabove(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_overabove(polygon, polygon) is 'implementation of |&> operator';

alter function pg_catalog.poly_overabove(polygon, polygon) owner to postgres;

create function pg_catalog.poly_above(polygon, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.poly_above(polygon, polygon) is 'implementation of |>> operator';

alter function pg_catalog.poly_above(polygon, polygon) owner to postgres;

create function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) owner to postgres;

create function pg_catalog.gist_box_compress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_box_compress(internal) is 'GiST support';

alter function pg_catalog.gist_box_compress(internal) owner to postgres;

create function pg_catalog.gist_box_decompress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_box_decompress(internal) is 'GiST support';

alter function pg_catalog.gist_box_decompress(internal) owner to postgres;

create function pg_catalog.gist_box_penalty(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_box_penalty(internal, internal, internal) is 'GiST support';

alter function pg_catalog.gist_box_penalty(internal, internal, internal) owner to postgres;

create function pg_catalog.gist_box_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_box_picksplit(internal, internal) is 'GiST support';

alter function pg_catalog.gist_box_picksplit(internal, internal) owner to postgres;

create function pg_catalog.gist_box_union(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_box_union(internal, internal) is 'GiST support';

alter function pg_catalog.gist_box_union(internal, internal) owner to postgres;

create function pg_catalog.gist_box_same(box, box, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_box_same(box, box, internal) is 'GiST support';

alter function pg_catalog.gist_box_same(box, box, internal) owner to postgres;

create function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) owner to postgres;

create function pg_catalog.gist_poly_compress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_poly_compress(internal) is 'GiST support';

alter function pg_catalog.gist_poly_compress(internal) owner to postgres;

create function pg_catalog.circle_overbelow(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_overbelow(circle, circle) is 'implementation of &<| operator';

alter function pg_catalog.circle_overbelow(circle, circle) owner to postgres;

create function pg_catalog.circle_overabove(circle, circle)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.circle_overabove(circle, circle) is 'implementation of |&> operator';

alter function pg_catalog.circle_overabove(circle, circle) owner to postgres;

create function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) owner to postgres;

create function pg_catalog.gist_circle_compress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_circle_compress(internal) is 'GiST support';

alter function pg_catalog.gist_circle_compress(internal) owner to postgres;

create function pg_catalog.numeric_stddev_pop(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_stddev_pop(internal) is 'aggregate final function';

alter function pg_catalog.numeric_stddev_pop(internal) owner to postgres;

create function pg_catalog.domain_in(cstring, oid, integer)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.domain_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.domain_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.domain_recv(internal, oid, integer)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.domain_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.domain_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.pg_timezone_abbrevs(out abbrev text, out utc_offset interval, out is_dst boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_timezone_abbrevs(out text, out interval, out boolean) is 'get the available time zone abbreviations';

alter function pg_catalog.pg_timezone_abbrevs(out text, out interval, out boolean) owner to postgres;

create function pg_catalog.xmlexists(text, xml)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xmlexists(text, xml) is 'test XML value against XPath expression';

alter function pg_catalog.xmlexists(text, xml) owner to postgres;

create function pg_catalog.pg_reload_conf()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_reload_conf() is 'reload configuration files';

alter function pg_catalog.pg_reload_conf() owner to postgres;

create function pg_catalog.pg_rotate_logfile()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_rotate_logfile() is 'rotate log file';

alter function pg_catalog.pg_rotate_logfile() owner to postgres;

create function pg_catalog.pg_stat_file(filename text, out size bigint, out access timestamp with time zone,
                                        out modification timestamp with time zone, out change timestamp with time zone,
                                        out creation timestamp with time zone, out isdir boolean)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_file(text, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) is 'get information about file';

alter function pg_catalog.pg_stat_file(text, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) owner to postgres;

create function pg_catalog.pg_read_file(text, bigint, bigint)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_read_file(text, bigint, bigint) is 'read text from a file';

alter function pg_catalog.pg_read_file(text, bigint, bigint) owner to postgres;

create function pg_catalog.pg_ls_dir(text)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ls_dir(text) is 'list all files in a directory';

alter function pg_catalog.pg_ls_dir(text) owner to postgres;

create function pg_catalog.pg_sleep(double precision)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_sleep(double precision) is 'sleep for the specified time in seconds';

alter function pg_catalog.pg_sleep(double precision) owner to postgres;

create function pg_catalog.inetnot(inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inetnot(inet) is 'implementation of ~ operator';

alter function pg_catalog.inetnot(inet) owner to postgres;

create function pg_catalog.inetand(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inetand(inet, inet) is 'implementation of & operator';

alter function pg_catalog.inetand(inet, inet) owner to postgres;

create function pg_catalog.inetor(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inetor(inet, inet) is 'implementation of | operator';

alter function pg_catalog.inetor(inet, inet) owner to postgres;

create function pg_catalog.inetpl(inet, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inetpl(inet, bigint) is 'implementation of + operator';

alter function pg_catalog.inetpl(inet, bigint) owner to postgres;

create function pg_catalog.int8pl_inet(bigint, inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select $2 + $1
$$;

comment on function pg_catalog.int8pl_inet(bigint, inet) is 'implementation of + operator';

alter function pg_catalog.int8pl_inet(bigint, inet) owner to postgres;

create function pg_catalog.inetmi_int8(inet, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inetmi_int8(inet, bigint) is 'implementation of - operator';

alter function pg_catalog.inetmi_int8(inet, bigint) owner to postgres;

create function pg_catalog.inetmi(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inetmi(inet, inet) is 'implementation of - operator';

alter function pg_catalog.inetmi(inet, inet) owner to postgres;

create function pg_catalog.transaction_timestamp()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.transaction_timestamp() is 'current transaction time';

alter function pg_catalog.transaction_timestamp() owner to postgres;

create function pg_catalog.statement_timestamp()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.statement_timestamp() is 'current statement time';

alter function pg_catalog.statement_timestamp() owner to postgres;

create function pg_catalog.clock_timestamp()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.clock_timestamp() is 'current clock time';

alter function pg_catalog.clock_timestamp() owner to postgres;

create function pg_catalog.gin_cmp_prefix(text, text, smallint, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_cmp_prefix(text, text, smallint, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_cmp_prefix(text, text, smallint, internal) owner to postgres;

create function pg_catalog.pg_has_role(name, name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_has_role(name, name, text) is 'user privilege on role by username, role name';

alter function pg_catalog.pg_has_role(name, name, text) owner to postgres;

create function pg_catalog.pg_has_role(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_has_role(name, oid, text) is 'user privilege on role by username, role oid';

alter function pg_catalog.pg_has_role(name, oid, text) owner to postgres;

create function pg_catalog.pg_has_role(oid, name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_has_role(oid, name, text) is 'user privilege on role by user oid, role name';

alter function pg_catalog.pg_has_role(oid, name, text) owner to postgres;

create function pg_catalog.pg_has_role(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_has_role(oid, oid, text) is 'user privilege on role by user oid, role oid';

alter function pg_catalog.pg_has_role(oid, oid, text) owner to postgres;

create function pg_catalog.pg_has_role(name, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_has_role(name, text) is 'current user privilege on role by role name';

alter function pg_catalog.pg_has_role(name, text) owner to postgres;

create function pg_catalog.pg_has_role(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_has_role(oid, text) is 'current user privilege on role by role oid';

alter function pg_catalog.pg_has_role(oid, text) owner to postgres;

create function pg_catalog.justify_interval(interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.justify_interval(interval) is 'promote groups of 24 hours to numbers of days and promote groups of 30 days to numbers of months';

alter function pg_catalog.justify_interval(interval) owner to postgres;

create function pg_catalog.pg_get_triggerdef(oid, boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_triggerdef(oid, boolean) is 'trigger description with pretty-print option';

alter function pg_catalog.pg_get_triggerdef(oid, boolean) owner to postgres;

create function pg_catalog.asind(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.asind(double precision) is 'arcsine, degrees';

alter function pg_catalog.asind(double precision) owner to postgres;

create function pg_catalog.acosd(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.acosd(double precision) is 'arccosine, degrees';

alter function pg_catalog.acosd(double precision) owner to postgres;

create function pg_catalog.atand(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.atand(double precision) is 'arctangent, degrees';

alter function pg_catalog.atand(double precision) owner to postgres;

create function pg_catalog.atan2d(double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.atan2d(double precision, double precision) is 'arctangent, two arguments, degrees';

alter function pg_catalog.atan2d(double precision, double precision) owner to postgres;

create function pg_catalog.sind(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.sind(double precision) is 'sine, degrees';

alter function pg_catalog.sind(double precision) owner to postgres;

create function pg_catalog.cosd(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cosd(double precision) is 'cosine, degrees';

alter function pg_catalog.cosd(double precision) owner to postgres;

create function pg_catalog.tand(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tand(double precision) is 'tangent, degrees';

alter function pg_catalog.tand(double precision) owner to postgres;

create function pg_catalog.cotd(double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cotd(double precision) is 'cotangent, degrees';

alter function pg_catalog.cotd(double precision) owner to postgres;

create function pg_catalog.pg_stop_backup(exclusive boolean, out lsn pg_lsn, out labelfile text, out spcmapfile text)
    strict
    parallel safe
    cost 1
    rows 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stop_backup(boolean, out pg_lsn, out text, out text) is 'finish taking an online backup';

alter function pg_catalog.pg_stop_backup(boolean, out pg_lsn, out text, out text) owner to postgres;

create function pg_catalog.numeric_avg_serialize(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_avg_serialize(internal) is 'aggregate serial function';

alter function pg_catalog.numeric_avg_serialize(internal) owner to postgres;

create function pg_catalog.numeric_avg_deserialize(bytea, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_avg_deserialize(bytea, internal) is 'aggregate deserial function';

alter function pg_catalog.numeric_avg_deserialize(bytea, internal) owner to postgres;

create function pg_catalog.ginarrayextract(anyarray, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ginarrayextract(anyarray, internal, internal) is 'GIN array support';

alter function pg_catalog.ginarrayextract(anyarray, internal, internal) owner to postgres;

create function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal,
                                              internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) is 'GIN array support';

alter function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.int8_avg_accum(internal, bigint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_avg_accum(internal, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_avg_accum(internal, bigint) owner to postgres;

create function pg_catalog.arrayoverlap(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.arrayoverlap(anyarray, anyarray) is 'implementation of && operator';

alter function pg_catalog.arrayoverlap(anyarray, anyarray) owner to postgres;

create function pg_catalog.arraycontains(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.arraycontains(anyarray, anyarray) is 'implementation of @> operator';

alter function pg_catalog.arraycontains(anyarray, anyarray) owner to postgres;

create function pg_catalog.arraycontained(anyarray, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.arraycontained(anyarray, anyarray) is 'implementation of <@ operator';

alter function pg_catalog.arraycontained(anyarray, anyarray) owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_returned(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_tuples_returned(oid) is 'statistics: tuples returned for database';

alter function pg_catalog.pg_stat_get_db_tuples_returned(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_fetched(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_tuples_fetched(oid) is 'statistics: tuples fetched for database';

alter function pg_catalog.pg_stat_get_db_tuples_fetched(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_inserted(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_tuples_inserted(oid) is 'statistics: tuples inserted in database';

alter function pg_catalog.pg_stat_get_db_tuples_inserted(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_updated(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_tuples_updated(oid) is 'statistics: tuples updated in database';

alter function pg_catalog.pg_stat_get_db_tuples_updated(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_tuples_deleted(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_tuples_deleted(oid) is 'statistics: tuples deleted in database';

alter function pg_catalog.pg_stat_get_db_tuples_deleted(oid) owner to postgres;

create function pg_catalog.regexp_matches(text, text)
    immutable
    strict
    parallel safe
    cost 1
    rows 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexp_matches(text, text) is 'find all match groups for regexp';

alter function pg_catalog.regexp_matches(text, text) owner to postgres;

create function pg_catalog.regexp_matches(text, text, text)
    immutable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as -- missing source code
;

comment on function pg_catalog.regexp_matches(text, text, text) is 'find all match groups for regexp';

alter function pg_catalog.regexp_matches(text, text, text) owner to postgres;

create function pg_catalog.regexp_split_to_table(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexp_split_to_table(text, text) is 'split string by pattern';

alter function pg_catalog.regexp_split_to_table(text, text) owner to postgres;

create function pg_catalog.regexp_split_to_table(text, text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexp_split_to_table(text, text, text) is 'split string by pattern';

alter function pg_catalog.regexp_split_to_table(text, text, text) owner to postgres;

create function pg_catalog.regexp_split_to_array(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexp_split_to_array(text, text) is 'split string by pattern';

alter function pg_catalog.regexp_split_to_array(text, text) owner to postgres;

create function pg_catalog.regexp_split_to_array(text, text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regexp_split_to_array(text, text, text) is 'split string by pattern';

alter function pg_catalog.regexp_split_to_array(text, text, text) owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() is 'statistics: number of timed checkpoints started by the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() is 'statistics: number of backend requested checkpoints started by the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() is 'statistics: number of buffers written by the bgwriter during checkpoints';

alter function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_buf_written_clean()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() is 'statistics: number of buffers written by the bgwriter for cleaning dirty buffers';

alter function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() is 'statistics: number of times the bgwriter stopped processing when it had written too many buffers while cleaning';

alter function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() owner to postgres;

create function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) is 'GIN array support';

alter function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.pg_stat_get_buf_written_backend()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_buf_written_backend() is 'statistics: number of buffers written by backends';

alter function pg_catalog.pg_stat_get_buf_written_backend() owner to postgres;

create function pg_catalog.anynonarray_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anynonarray_in(cstring) is 'I/O';

alter function pg_catalog.anynonarray_in(cstring) owner to postgres;

create function pg_catalog.anynonarray_out(anynonarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anynonarray_out(anynonarray) is 'I/O';

alter function pg_catalog.anynonarray_out(anynonarray) owner to postgres;

create function pg_catalog.pg_stat_get_last_vacuum_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_last_vacuum_time(oid) is 'statistics: last manual vacuum time for a table';

alter function pg_catalog.pg_stat_get_last_vacuum_time(oid) owner to postgres;

create function pg_catalog.pg_stat_get_last_autovacuum_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_last_autovacuum_time(oid) is 'statistics: last auto vacuum time for a table';

alter function pg_catalog.pg_stat_get_last_autovacuum_time(oid) owner to postgres;

create function pg_catalog.pg_stat_get_last_analyze_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_last_analyze_time(oid) is 'statistics: last manual analyze time for a table';

alter function pg_catalog.pg_stat_get_last_analyze_time(oid) owner to postgres;

create function pg_catalog.pg_stat_get_last_autoanalyze_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_last_autoanalyze_time(oid) is 'statistics: last auto analyze time for a table';

alter function pg_catalog.pg_stat_get_last_autoanalyze_time(oid) owner to postgres;

create function pg_catalog.int8_avg_combine(internal, internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_avg_combine(internal, internal) is 'aggregate combine function';

alter function pg_catalog.int8_avg_combine(internal, internal) owner to postgres;

create function pg_catalog.int8_avg_serialize(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_avg_serialize(internal) is 'aggregate serial function';

alter function pg_catalog.int8_avg_serialize(internal) owner to postgres;

create function pg_catalog.int8_avg_deserialize(bytea, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_avg_deserialize(bytea, internal) is 'aggregate deserial function';

alter function pg_catalog.int8_avg_deserialize(bytea, internal) owner to postgres;

create function pg_catalog.pg_stat_get_backend_wait_event_type(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_wait_event_type(integer) is 'statistics: wait event type on which backend is currently waiting';

alter function pg_catalog.pg_stat_get_backend_wait_event_type(integer) owner to postgres;

create function pg_catalog.tidgt(tid, tid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidgt(tid, tid) is 'implementation of > operator';

alter function pg_catalog.tidgt(tid, tid) owner to postgres;

create function pg_catalog.tidlt(tid, tid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidlt(tid, tid) is 'implementation of < operator';

alter function pg_catalog.tidlt(tid, tid) owner to postgres;

create function pg_catalog.tidge(tid, tid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidge(tid, tid) is 'implementation of >= operator';

alter function pg_catalog.tidge(tid, tid) owner to postgres;

create function pg_catalog.tidle(tid, tid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidle(tid, tid) is 'implementation of <= operator';

alter function pg_catalog.tidle(tid, tid) owner to postgres;

create function pg_catalog.bttidcmp(tid, tid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bttidcmp(tid, tid) is 'less-equal-greater';

alter function pg_catalog.bttidcmp(tid, tid) owner to postgres;

create function pg_catalog.tidlarger(tid, tid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidlarger(tid, tid) is 'larger of two';

alter function pg_catalog.tidlarger(tid, tid) owner to postgres;

create function pg_catalog.tidsmaller(tid, tid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tidsmaller(tid, tid) is 'smaller of two';

alter function pg_catalog.tidsmaller(tid, tid) owner to postgres;

create function pg_catalog.int8inc_any(bigint, "any")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8inc_any(bigint, "any") is 'increment, ignores second argument';

alter function pg_catalog.int8inc_any(bigint, "any") owner to postgres;

create function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) is 'aggregate transition function';

alter function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) owner to postgres;

create function pg_catalog.float8_regr_accum(double precision[], double precision, double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_accum(double precision[], double precision, double precision) is 'aggregate transition function';

alter function pg_catalog.float8_regr_accum(double precision[], double precision, double precision) owner to postgres;

create function pg_catalog.float8_regr_sxx(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_sxx(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_sxx(double precision[]) owner to postgres;

create function pg_catalog.float8_regr_syy(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_syy(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_syy(double precision[]) owner to postgres;

create function pg_catalog.float8_regr_sxy(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_sxy(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_sxy(double precision[]) owner to postgres;

create function pg_catalog.float8_regr_avgx(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_avgx(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_avgx(double precision[]) owner to postgres;

create function pg_catalog.float8_regr_avgy(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_avgy(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_avgy(double precision[]) owner to postgres;

create function pg_catalog.float8_regr_r2(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_r2(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_r2(double precision[]) owner to postgres;

create function pg_catalog.float8_regr_slope(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_slope(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_slope(double precision[]) owner to postgres;

create function pg_catalog.float8_regr_intercept(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_intercept(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_intercept(double precision[]) owner to postgres;

create function pg_catalog.float8_covar_pop(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_covar_pop(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_covar_pop(double precision[]) owner to postgres;

create function pg_catalog.float8_covar_samp(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_covar_samp(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_covar_samp(double precision[]) owner to postgres;

create function pg_catalog.float8_corr(double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_corr(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_corr(double precision[]) owner to postgres;

create function pg_catalog.pg_stat_get_db_blk_read_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_blk_read_time(oid) is 'statistics: block read time, in msec';

alter function pg_catalog.pg_stat_get_db_blk_read_time(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_blk_write_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_blk_write_time(oid) is 'statistics: block write time, in msec';

alter function pg_catalog.pg_stat_get_db_blk_write_time(oid) owner to postgres;

create function pg_catalog.pg_switch_xlog()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_switch_xlog() is 'switch to new xlog file';

alter function pg_catalog.pg_switch_xlog() owner to postgres;

create function pg_catalog.pg_current_xlog_location()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_current_xlog_location() is 'current xlog write location';

alter function pg_catalog.pg_current_xlog_location() owner to postgres;

create function pg_catalog.pg_xlogfile_name_offset(wal_location pg_lsn, out file_name text, out file_offset integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_xlogfile_name_offset(pg_lsn, out text, out integer) is 'xlog filename and byte offset, given an xlog location';

alter function pg_catalog.pg_xlogfile_name_offset(pg_lsn, out text, out integer) owner to postgres;

create function pg_catalog.pg_xlogfile_name(pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_xlogfile_name(pg_lsn) is 'xlog filename, given an xlog location';

alter function pg_catalog.pg_xlogfile_name(pg_lsn) owner to postgres;

create function pg_catalog.pg_current_xlog_insert_location()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_current_xlog_insert_location() is 'current xlog insert location';

alter function pg_catalog.pg_current_xlog_insert_location() owner to postgres;

create function pg_catalog.pg_stat_get_backend_wait_event(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_wait_event(integer) is 'statistics: wait event on which backend is currently waiting';

alter function pg_catalog.pg_stat_get_backend_wait_event(integer) owner to postgres;

create function pg_catalog.pg_my_temp_schema()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_my_temp_schema() is 'get OID of current session''s temp schema, if any';

alter function pg_catalog.pg_my_temp_schema() owner to postgres;

create function pg_catalog.pg_is_other_temp_schema(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_is_other_temp_schema(oid) is 'is schema another session''s temp schema?';

alter function pg_catalog.pg_is_other_temp_schema(oid) owner to postgres;

create function pg_catalog.pg_timezone_names(out name text, out abbrev text, out utc_offset interval,
                                             out is_dst boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_timezone_names(out text, out text, out interval, out boolean) is 'get the available time zone names';

alter function pg_catalog.pg_timezone_names(out text, out text, out interval, out boolean) owner to postgres;

create function pg_catalog.pg_stat_get_backend_xact_start(integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_backend_xact_start(integer) is 'statistics: start time for backend''s current transaction';

alter function pg_catalog.pg_stat_get_backend_xact_start(integer) owner to postgres;

create function pg_catalog.numeric_avg_accum(internal, numeric)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_avg_accum(internal, numeric) is 'aggregate transition function';

alter function pg_catalog.numeric_avg_accum(internal, numeric) owner to postgres;

create function pg_catalog.pg_stat_get_buf_alloc()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_buf_alloc() is 'statistics: number of buffer allocations';

alter function pg_catalog.pg_stat_get_buf_alloc() owner to postgres;

create function pg_catalog.pg_stat_get_live_tuples(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_live_tuples(oid) is 'statistics: number of live tuples';

alter function pg_catalog.pg_stat_get_live_tuples(oid) owner to postgres;

create function pg_catalog.pg_stat_get_dead_tuples(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_dead_tuples(oid) is 'statistics: number of dead tuples';

alter function pg_catalog.pg_stat_get_dead_tuples(oid) owner to postgres;

create function pg_catalog.pg_advisory_lock(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_lock(bigint) is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_lock(bigint) owner to postgres;

create function pg_catalog.pg_advisory_lock_shared(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_lock_shared(bigint) is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_lock_shared(bigint) owner to postgres;

create function pg_catalog.pg_try_advisory_lock(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_try_advisory_lock(bigint) is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock(bigint) owner to postgres;

create function pg_catalog.pg_try_advisory_lock_shared(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_try_advisory_lock_shared(bigint) is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock_shared(bigint) owner to postgres;

create function pg_catalog.pg_advisory_unlock(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_unlock(bigint) is 'release exclusive advisory lock';

alter function pg_catalog.pg_advisory_unlock(bigint) owner to postgres;

create function pg_catalog.pg_advisory_unlock_shared(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_unlock_shared(bigint) is 'release shared advisory lock';

alter function pg_catalog.pg_advisory_unlock_shared(bigint) owner to postgres;

create function pg_catalog.pg_advisory_lock(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_lock(integer, integer) is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_lock(integer, integer) owner to postgres;

create function pg_catalog.pg_advisory_lock_shared(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_lock_shared(integer, integer) is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_lock_shared(integer, integer) owner to postgres;

create function pg_catalog.pg_try_advisory_lock(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_try_advisory_lock(integer, integer) is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock(integer, integer) owner to postgres;

create function pg_catalog.pg_try_advisory_lock_shared(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_try_advisory_lock_shared(integer, integer) is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock_shared(integer, integer) owner to postgres;

create function pg_catalog.pg_advisory_unlock(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_unlock(integer, integer) is 'release exclusive advisory lock';

alter function pg_catalog.pg_advisory_unlock(integer, integer) owner to postgres;

create function pg_catalog.pg_advisory_unlock_shared(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_unlock_shared(integer, integer) is 'release shared advisory lock';

alter function pg_catalog.pg_advisory_unlock_shared(integer, integer) owner to postgres;

create function pg_catalog.pg_advisory_unlock_all()
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_unlock_all() is 'release all advisory locks';

alter function pg_catalog.pg_advisory_unlock_all() owner to postgres;

create function pg_catalog.xml_in(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xml_in(cstring) is 'I/O';

alter function pg_catalog.xml_in(cstring) owner to postgres;

create function pg_catalog.xml_out(xml)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xml_out(xml) is 'I/O';

alter function pg_catalog.xml_out(xml) owner to postgres;

create function pg_catalog.xmlcomment(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xmlcomment(text) is 'generate XML comment';

alter function pg_catalog.xmlcomment(text) owner to postgres;

create function pg_catalog.xml(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xml(text) is 'perform a non-validating parse of a character string to produce an XML value';

alter function pg_catalog.xml(text) owner to postgres;

create function pg_catalog.xmlvalidate(xml, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xmlvalidate(xml, text) is 'validate an XML value';

alter function pg_catalog.xmlvalidate(xml, text) owner to postgres;

create function pg_catalog.xml_recv(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xml_recv(internal) is 'I/O';

alter function pg_catalog.xml_recv(internal) owner to postgres;

create function pg_catalog.xml_send(xml)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xml_send(xml) is 'I/O';

alter function pg_catalog.xml_send(xml) owner to postgres;

create function pg_catalog.xmlconcat2(xml, xml)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xmlconcat2(xml, xml) is 'aggregate transition function';

alter function pg_catalog.xmlconcat2(xml, xml) owner to postgres;

create function pg_catalog.varbittypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbittypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.varbittypmodin(cstring[]) owner to postgres;

create function pg_catalog.intervaltypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.intervaltypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.intervaltypmodin(cstring[]) owner to postgres;

create function pg_catalog.intervaltypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.intervaltypmodout(integer) is 'I/O typmod';

alter function pg_catalog.intervaltypmodout(integer) owner to postgres;

create function pg_catalog.timestamptypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.timestamptypmodin(cstring[]) owner to postgres;

create function pg_catalog.timestamptypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptypmodout(integer) is 'I/O typmod';

alter function pg_catalog.timestamptypmodout(integer) owner to postgres;

create function pg_catalog.timestamptztypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptztypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.timestamptztypmodin(cstring[]) owner to postgres;

create function pg_catalog.timestamptztypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamptztypmodout(integer) is 'I/O typmod';

alter function pg_catalog.timestamptztypmodout(integer) owner to postgres;

create function pg_catalog.timetypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.timetypmodin(cstring[]) owner to postgres;

create function pg_catalog.timetypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetypmodout(integer) is 'I/O typmod';

alter function pg_catalog.timetypmodout(integer) owner to postgres;

create function pg_catalog.timetztypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetztypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.timetztypmodin(cstring[]) owner to postgres;

create function pg_catalog.timetztypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timetztypmodout(integer) is 'I/O typmod';

alter function pg_catalog.timetztypmodout(integer) owner to postgres;

create function pg_catalog.bpchartypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchartypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.bpchartypmodin(cstring[]) owner to postgres;

create function pg_catalog.bpchartypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchartypmodout(integer) is 'I/O typmod';

alter function pg_catalog.bpchartypmodout(integer) owner to postgres;

create function pg_catalog.varchartypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varchartypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.varchartypmodin(cstring[]) owner to postgres;

create function pg_catalog.varchartypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varchartypmodout(integer) is 'I/O typmod';

alter function pg_catalog.varchartypmodout(integer) owner to postgres;

create function pg_catalog.numerictypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numerictypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.numerictypmodin(cstring[]) owner to postgres;

create function pg_catalog.numerictypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numerictypmodout(integer) is 'I/O typmod';

alter function pg_catalog.numerictypmodout(integer) owner to postgres;

create function pg_catalog.bittypmodin(cstring[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bittypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.bittypmodin(cstring[]) owner to postgres;

create function pg_catalog.bittypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bittypmodout(integer) is 'I/O typmod';

alter function pg_catalog.bittypmodout(integer) owner to postgres;

create function pg_catalog.varbittypmodout(integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbittypmodout(integer) is 'I/O typmod';

alter function pg_catalog.varbittypmodout(integer) owner to postgres;

create function pg_catalog.text(xml)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text(xml) is 'serialize an XML value to a character string';

alter function pg_catalog.text(xml) owner to postgres;

create function pg_catalog.table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.table_to_xml(regclass, boolean, boolean, text) is 'map table contents to XML';

alter function pg_catalog.table_to_xml(regclass, boolean, boolean, text) owner to postgres;

create function pg_catalog.query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)
    strict
    language internal
as -- missing source code
;

comment on function pg_catalog.query_to_xml(text, boolean, boolean, text) is 'map query result to XML';

alter function pg_catalog.query_to_xml(text, boolean, boolean, text) owner to postgres;

create function pg_catalog.cursor_to_xml(cursor refcursor, count integer, nulls boolean, tableforest boolean,
                                         targetns text)
    strict
    language internal
as -- missing source code
;

comment on function pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text) is 'map rows from cursor to XML';

alter function pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text) owner to postgres;

create function pg_catalog.table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text) is 'map table structure to XML Schema';

alter function pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text) owner to postgres;

create function pg_catalog.query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
    strict
    language internal
as -- missing source code
;

comment on function pg_catalog.query_to_xmlschema(text, boolean, boolean, text) is 'map query result structure to XML Schema';

alter function pg_catalog.query_to_xmlschema(text, boolean, boolean, text) owner to postgres;

create function pg_catalog.cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text)
    strict
    language internal
as -- missing source code
;

comment on function pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text) is 'map cursor structure to XML Schema';

alter function pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text) owner to postgres;

create function pg_catalog.table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text) is 'map table contents and structure to XML and XML Schema';

alter function pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text) owner to postgres;

create function pg_catalog.query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text)
    strict
    language internal
as -- missing source code
;

comment on function pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text) is 'map query result and structure to XML and XML Schema';

alter function pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text) owner to postgres;

create function pg_catalog.xpath(text, xml, text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xpath(text, xml, text[]) is 'evaluate XPath expression, with namespaces support';

alter function pg_catalog.xpath(text, xml, text[]) owner to postgres;

create function pg_catalog.xpath(text, xml) returns xml[]
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.xpath($1, $2, '{}'::pg_catalog.text[])
$$;

comment on function pg_catalog.xpath(text, xml) is 'evaluate XPath expression';

alter function pg_catalog.xpath(text, xml) owner to postgres;

create function pg_catalog.schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.schema_to_xml(name, boolean, boolean, text) is 'map schema contents to XML';

alter function pg_catalog.schema_to_xml(name, boolean, boolean, text) owner to postgres;

create function pg_catalog.schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.schema_to_xmlschema(name, boolean, boolean, text) is 'map schema structure to XML Schema';

alter function pg_catalog.schema_to_xmlschema(name, boolean, boolean, text) owner to postgres;

create function pg_catalog.schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text) is 'map schema contents and structure to XML and XML Schema';

alter function pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text) owner to postgres;

create function pg_catalog.database_to_xml(nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.database_to_xml(boolean, boolean, text) is 'map database contents to XML';

alter function pg_catalog.database_to_xml(boolean, boolean, text) owner to postgres;

create function pg_catalog.database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.database_to_xmlschema(boolean, boolean, text) is 'map database structure to XML Schema';

alter function pg_catalog.database_to_xmlschema(boolean, boolean, text) owner to postgres;

create function pg_catalog.database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text)
    stable
    strict
    parallel restricted
    language internal
as -- missing source code
;

comment on function pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text) is 'map database contents and structure to XML and XML Schema';

alter function pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text) owner to postgres;

create function pg_catalog.txid_snapshot_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_snapshot_in(cstring) is 'I/O';

alter function pg_catalog.txid_snapshot_in(cstring) owner to postgres;

create function pg_catalog.txid_snapshot_out(txid_snapshot)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_snapshot_out(txid_snapshot) is 'I/O';

alter function pg_catalog.txid_snapshot_out(txid_snapshot) owner to postgres;

create function pg_catalog.txid_snapshot_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_snapshot_recv(internal) is 'I/O';

alter function pg_catalog.txid_snapshot_recv(internal) owner to postgres;

create function pg_catalog.txid_snapshot_send(txid_snapshot)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_snapshot_send(txid_snapshot) is 'I/O';

alter function pg_catalog.txid_snapshot_send(txid_snapshot) owner to postgres;

create function pg_catalog.txid_current()
    stable
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_current() is 'get current transaction ID';

alter function pg_catalog.txid_current() owner to postgres;

create function pg_catalog.txid_current_snapshot()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_current_snapshot() is 'get current snapshot';

alter function pg_catalog.txid_current_snapshot() owner to postgres;

create function pg_catalog.txid_snapshot_xmin(txid_snapshot)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_snapshot_xmin(txid_snapshot) is 'get xmin of snapshot';

alter function pg_catalog.txid_snapshot_xmin(txid_snapshot) owner to postgres;

create function pg_catalog.txid_snapshot_xmax(txid_snapshot)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_snapshot_xmax(txid_snapshot) is 'get xmax of snapshot';

alter function pg_catalog.txid_snapshot_xmax(txid_snapshot) owner to postgres;

create function pg_catalog.txid_snapshot_xip(txid_snapshot)
    immutable
    strict
    parallel safe
    cost 1
    rows 50
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_snapshot_xip(txid_snapshot) is 'get set of in-progress txids in snapshot';

alter function pg_catalog.txid_snapshot_xip(txid_snapshot) owner to postgres;

create function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) is 'is txid visible in snapshot?';

alter function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) owner to postgres;

create function pg_catalog.uuid_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_in(cstring) is 'I/O';

alter function pg_catalog.uuid_in(cstring) owner to postgres;

create function pg_catalog.uuid_out(uuid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_out(uuid) is 'I/O';

alter function pg_catalog.uuid_out(uuid) owner to postgres;

create function pg_catalog.uuid_lt(uuid, uuid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_lt(uuid, uuid) is 'implementation of < operator';

alter function pg_catalog.uuid_lt(uuid, uuid) owner to postgres;

create function pg_catalog.uuid_le(uuid, uuid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_le(uuid, uuid) is 'implementation of <= operator';

alter function pg_catalog.uuid_le(uuid, uuid) owner to postgres;

create function pg_catalog.uuid_eq(uuid, uuid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_eq(uuid, uuid) is 'implementation of = operator';

alter function pg_catalog.uuid_eq(uuid, uuid) owner to postgres;

create function pg_catalog.uuid_ge(uuid, uuid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_ge(uuid, uuid) is 'implementation of >= operator';

alter function pg_catalog.uuid_ge(uuid, uuid) owner to postgres;

create function pg_catalog.uuid_gt(uuid, uuid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_gt(uuid, uuid) is 'implementation of > operator';

alter function pg_catalog.uuid_gt(uuid, uuid) owner to postgres;

create function pg_catalog.uuid_ne(uuid, uuid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_ne(uuid, uuid) is 'implementation of <> operator';

alter function pg_catalog.uuid_ne(uuid, uuid) owner to postgres;

create function pg_catalog.uuid_cmp(uuid, uuid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_cmp(uuid, uuid) is 'less-equal-greater';

alter function pg_catalog.uuid_cmp(uuid, uuid) owner to postgres;

create function pg_catalog.uuid_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_recv(internal) is 'I/O';

alter function pg_catalog.uuid_recv(internal) owner to postgres;

create function pg_catalog.uuid_send(uuid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_send(uuid) is 'I/O';

alter function pg_catalog.uuid_send(uuid) owner to postgres;

create function pg_catalog.uuid_hash(uuid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_hash(uuid) is 'hash';

alter function pg_catalog.uuid_hash(uuid) owner to postgres;

create function pg_catalog.text(boolean)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.text(boolean) is 'convert boolean to text';

alter function pg_catalog.text(boolean) owner to postgres;

create function pg_catalog.pg_stat_get_function_calls(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_function_calls(oid) is 'statistics: number of function calls';

alter function pg_catalog.pg_stat_get_function_calls(oid) owner to postgres;

create function pg_catalog.pg_stat_get_function_total_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_function_total_time(oid) is 'statistics: total execution time of function, in msec';

alter function pg_catalog.pg_stat_get_function_total_time(oid) owner to postgres;

create function pg_catalog.pg_stat_get_function_self_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_function_self_time(oid) is 'statistics: self execution time of function, in msec';

alter function pg_catalog.pg_stat_get_function_self_time(oid) owner to postgres;

create function pg_catalog.record_eq(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_eq(record, record) is 'implementation of = operator';

alter function pg_catalog.record_eq(record, record) owner to postgres;

create function pg_catalog.record_ne(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_ne(record, record) is 'implementation of <> operator';

alter function pg_catalog.record_ne(record, record) owner to postgres;

create function pg_catalog.record_lt(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_lt(record, record) is 'implementation of < operator';

alter function pg_catalog.record_lt(record, record) owner to postgres;

create function pg_catalog.record_gt(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_gt(record, record) is 'implementation of > operator';

alter function pg_catalog.record_gt(record, record) owner to postgres;

create function pg_catalog.record_le(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_le(record, record) is 'implementation of <= operator';

alter function pg_catalog.record_le(record, record) owner to postgres;

create function pg_catalog.record_ge(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_ge(record, record) is 'implementation of >= operator';

alter function pg_catalog.record_ge(record, record) owner to postgres;

create function pg_catalog.btrecordcmp(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btrecordcmp(record, record) is 'less-equal-greater';

alter function pg_catalog.btrecordcmp(record, record) owner to postgres;

create function pg_catalog.pg_table_size(regclass)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_table_size(regclass) is 'disk space usage for the specified table, including TOAST, free space and visibility map';

alter function pg_catalog.pg_table_size(regclass) owner to postgres;

create function pg_catalog.pg_indexes_size(regclass)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_indexes_size(regclass) is 'disk space usage for all indexes attached to the specified table';

alter function pg_catalog.pg_indexes_size(regclass) owner to postgres;

create function pg_catalog.pg_relation_filenode(regclass)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_relation_filenode(regclass) is 'filenode identifier of relation';

alter function pg_catalog.pg_relation_filenode(regclass) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text) is 'user privilege on foreign data wrapper by username, foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) is 'user privilege on foreign data wrapper by username, foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text) is 'user privilege on foreign data wrapper by user oid, foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text) is 'user privilege on foreign data wrapper by user oid, foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(text, text) is 'current user privilege on foreign data wrapper by foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(text, text) owner to postgres;

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text) is 'current user privilege on foreign data wrapper by foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, text) owner to postgres;

create function pg_catalog.has_server_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_server_privilege(name, text, text) is 'user privilege on server by username, server name';

alter function pg_catalog.has_server_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_server_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_server_privilege(name, oid, text) is 'user privilege on server by username, server oid';

alter function pg_catalog.has_server_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_server_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_server_privilege(oid, text, text) is 'user privilege on server by user oid, server name';

alter function pg_catalog.has_server_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_server_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_server_privilege(oid, oid, text) is 'user privilege on server by user oid, server oid';

alter function pg_catalog.has_server_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_server_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_server_privilege(text, text) is 'current user privilege on server by server name';

alter function pg_catalog.has_server_privilege(text, text) owner to postgres;

create function pg_catalog.has_server_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_server_privilege(oid, text) is 'current user privilege on server by server oid';

alter function pg_catalog.has_server_privilege(oid, text) owner to postgres;

create function pg_catalog.has_column_privilege(name, text, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(name, text, text, text) is 'user privilege on column by username, rel name, col name';

alter function pg_catalog.has_column_privilege(name, text, text, text) owner to postgres;

create function pg_catalog.has_column_privilege(name, text, smallint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(name, text, smallint, text) is 'user privilege on column by username, rel name, col attnum';

alter function pg_catalog.has_column_privilege(name, text, smallint, text) owner to postgres;

create function pg_catalog.has_column_privilege(name, oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(name, oid, text, text) is 'user privilege on column by username, rel oid, col name';

alter function pg_catalog.has_column_privilege(name, oid, text, text) owner to postgres;

create function pg_catalog.has_column_privilege(name, oid, smallint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(name, oid, smallint, text) is 'user privilege on column by username, rel oid, col attnum';

alter function pg_catalog.has_column_privilege(name, oid, smallint, text) owner to postgres;

create function pg_catalog.has_column_privilege(oid, text, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(oid, text, text, text) is 'user privilege on column by user oid, rel name, col name';

alter function pg_catalog.has_column_privilege(oid, text, text, text) owner to postgres;

create function pg_catalog.has_column_privilege(oid, text, smallint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(oid, text, smallint, text) is 'user privilege on column by user oid, rel name, col attnum';

alter function pg_catalog.has_column_privilege(oid, text, smallint, text) owner to postgres;

create function pg_catalog.has_column_privilege(oid, oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(oid, oid, text, text) is 'user privilege on column by user oid, rel oid, col name';

alter function pg_catalog.has_column_privilege(oid, oid, text, text) owner to postgres;

create function pg_catalog.has_column_privilege(oid, oid, smallint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(oid, oid, smallint, text) is 'user privilege on column by user oid, rel oid, col attnum';

alter function pg_catalog.has_column_privilege(oid, oid, smallint, text) owner to postgres;

create function pg_catalog.has_column_privilege(text, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(text, text, text) is 'current user privilege on column by rel name, col name';

alter function pg_catalog.has_column_privilege(text, text, text) owner to postgres;

create function pg_catalog.has_column_privilege(text, smallint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(text, smallint, text) is 'current user privilege on column by rel name, col attnum';

alter function pg_catalog.has_column_privilege(text, smallint, text) owner to postgres;

create function pg_catalog.has_column_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(oid, text, text) is 'current user privilege on column by rel oid, col name';

alter function pg_catalog.has_column_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_column_privilege(oid, smallint, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_column_privilege(oid, smallint, text) is 'current user privilege on column by rel oid, col attnum';

alter function pg_catalog.has_column_privilege(oid, smallint, text) owner to postgres;

create function pg_catalog.has_any_column_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.has_any_column_privilege(name, text, text) is 'user privilege on any column by username, rel name';

alter function pg_catalog.has_any_column_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_any_column_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.has_any_column_privilege(name, oid, text) is 'user privilege on any column by username, rel oid';

alter function pg_catalog.has_any_column_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_any_column_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.has_any_column_privilege(oid, text, text) is 'user privilege on any column by user oid, rel name';

alter function pg_catalog.has_any_column_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_any_column_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.has_any_column_privilege(oid, oid, text) is 'user privilege on any column by user oid, rel oid';

alter function pg_catalog.has_any_column_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_any_column_privilege(text, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.has_any_column_privilege(text, text) is 'current user privilege on any column by rel name';

alter function pg_catalog.has_any_column_privilege(text, text) owner to postgres;

create function pg_catalog.has_any_column_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.has_any_column_privilege(oid, text) is 'current user privilege on any column by rel oid';

alter function pg_catalog.has_any_column_privilege(oid, text) owner to postgres;

create function pg_catalog.overlay(bit, bit, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.overlay(bit, bit, integer, integer) is 'substitute portion of bitstring';

alter function pg_catalog.overlay(bit, bit, integer, integer) owner to postgres;

create function pg_catalog.overlay(bit, bit, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.overlay(bit, bit, integer) is 'substitute portion of bitstring';

alter function pg_catalog.overlay(bit, bit, integer) owner to postgres;

create function pg_catalog.get_bit(bit, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.get_bit(bit, integer) is 'get bit';

alter function pg_catalog.get_bit(bit, integer) owner to postgres;

create function pg_catalog.set_bit(bit, integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.set_bit(bit, integer, integer) is 'set bit';

alter function pg_catalog.set_bit(bit, integer, integer) owner to postgres;

create function pg_catalog.pg_relation_filepath(regclass)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_relation_filepath(regclass) is 'file path of relation';

alter function pg_catalog.pg_relation_filepath(regclass) owner to postgres;

create function pg_catalog.pg_listening_channels()
    stable
    strict
    parallel restricted
    cost 1
    rows 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_listening_channels() is 'get the channels that the current backend listens to';

alter function pg_catalog.pg_listening_channels() owner to postgres;

create function pg_catalog.pg_notify(text, text)
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_notify(text, text) is 'send a notification event';

alter function pg_catalog.pg_notify(text, text) owner to postgres;

create function pg_catalog.pg_stat_get_xact_numscans(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_numscans(oid) is 'statistics: number of scans done for table/index in current transaction';

alter function pg_catalog.pg_stat_get_xact_numscans(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_returned(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_tuples_returned(oid) is 'statistics: number of tuples read by seqscan in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_returned(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_fetched(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_tuples_fetched(oid) is 'statistics: number of tuples fetched by idxscan in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_fetched(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_inserted(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_tuples_inserted(oid) is 'statistics: number of tuples inserted in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_inserted(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_updated(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_tuples_updated(oid) is 'statistics: number of tuples updated in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_updated(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_deleted(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_tuples_deleted(oid) is 'statistics: number of tuples deleted in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_deleted(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) is 'statistics: number of tuples hot updated in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_blocks_fetched(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_blocks_fetched(oid) is 'statistics: number of blocks fetched in current transaction';

alter function pg_catalog.pg_stat_get_xact_blocks_fetched(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_blocks_hit(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_blocks_hit(oid) is 'statistics: number of blocks found in cache in current transaction';

alter function pg_catalog.pg_stat_get_xact_blocks_hit(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_calls(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_function_calls(oid) is 'statistics: number of function calls in current transaction';

alter function pg_catalog.pg_stat_get_xact_function_calls(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_total_time(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_function_total_time(oid) is 'statistics: total execution time of function in current transaction, in msec';

alter function pg_catalog.pg_stat_get_xact_function_total_time(oid) owner to postgres;

create function pg_catalog.pg_stat_get_xact_function_self_time(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_xact_function_self_time(oid) is 'statistics: self execution time of function in current transaction, in msec';

alter function pg_catalog.pg_stat_get_xact_function_self_time(oid) owner to postgres;

create function pg_catalog.xpath_exists(text, xml, text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xpath_exists(text, xml, text[]) is 'test XML value against XPath expression, with namespace support';

alter function pg_catalog.xpath_exists(text, xml, text[]) owner to postgres;

create function pg_catalog.xpath_exists(text, xml) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.xpath_exists($1, $2, '{}'::pg_catalog.text[])
$$;

comment on function pg_catalog.xpath_exists(text, xml) is 'test XML value against XPath expression';

alter function pg_catalog.xpath_exists(text, xml) owner to postgres;

create function pg_catalog.xml_is_well_formed(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xml_is_well_formed(text) is 'determine if a string is well formed XML';

alter function pg_catalog.xml_is_well_formed(text) owner to postgres;

create function pg_catalog.xml_is_well_formed_document(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xml_is_well_formed_document(text) is 'determine if a string is well formed XML document';

alter function pg_catalog.xml_is_well_formed_document(text) owner to postgres;

create function pg_catalog.xml_is_well_formed_content(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xml_is_well_formed_content(text) is 'determine if a string is well formed XML content';

alter function pg_catalog.xml_is_well_formed_content(text) owner to postgres;

create function pg_catalog.pg_stat_get_vacuum_count(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_vacuum_count(oid) is 'statistics: number of manual vacuums for a table';

alter function pg_catalog.pg_stat_get_vacuum_count(oid) owner to postgres;

create function pg_catalog.pg_stat_get_autovacuum_count(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_autovacuum_count(oid) is 'statistics: number of auto vacuums for a table';

alter function pg_catalog.pg_stat_get_autovacuum_count(oid) owner to postgres;

create function pg_catalog.pg_stat_get_analyze_count(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_analyze_count(oid) is 'statistics: number of manual analyzes for a table';

alter function pg_catalog.pg_stat_get_analyze_count(oid) owner to postgres;

create function pg_catalog.pg_stat_get_autoanalyze_count(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_autoanalyze_count(oid) is 'statistics: number of auto analyzes for a table';

alter function pg_catalog.pg_stat_get_autoanalyze_count(oid) owner to postgres;

create function pg_catalog.concat("any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.concat("any") is 'concatenate values';

alter function pg_catalog.concat("any") owner to postgres;

create function pg_catalog.concat_ws(text, "any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.concat_ws(text, "any") is 'concatenate values with separators';

alter function pg_catalog.concat_ws(text, "any") owner to postgres;

create function pg_catalog."left"(text, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."left"(text, integer) is 'extract the first n characters';

alter function pg_catalog."left"(text, integer) owner to postgres;

create function pg_catalog."right"(text, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog."right"(text, integer) is 'extract the last n characters';

alter function pg_catalog."right"(text, integer) owner to postgres;

create function pg_catalog.reverse(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.reverse(text) is 'reverse text';

alter function pg_catalog.reverse(text) owner to postgres;

create function pg_catalog.pg_stat_get_buf_fsync_backend()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_buf_fsync_backend() is 'statistics: number of backend buffer writes that did their own fsync';

alter function pg_catalog.pg_stat_get_buf_fsync_backend() owner to postgres;

create function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_tablespace(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_conflict_tablespace(oid) is 'statistics: recovery conflicts in database caused by drop tablespace';

alter function pg_catalog.pg_stat_get_db_conflict_tablespace(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_lock(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_conflict_lock(oid) is 'statistics: recovery conflicts in database caused by relation lock';

alter function pg_catalog.pg_stat_get_db_conflict_lock(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_snapshot(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_conflict_snapshot(oid) is 'statistics: recovery conflicts in database caused by snapshot expiry';

alter function pg_catalog.pg_stat_get_db_conflict_snapshot(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) is 'statistics: recovery conflicts in database caused by shared buffer pin';

alter function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) is 'statistics: recovery conflicts in database caused by buffer deadlock';

alter function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_conflict_all(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_conflict_all(oid) is 'statistics: recovery conflicts in database';

alter function pg_catalog.pg_stat_get_db_conflict_all(oid) owner to postgres;

create function pg_catalog.pg_xlog_replay_pause()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_xlog_replay_pause() is 'pause xlog replay';

alter function pg_catalog.pg_xlog_replay_pause() owner to postgres;

create function pg_catalog.pg_xlog_replay_resume()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_xlog_replay_resume() is 'resume xlog replay, if it was paused';

alter function pg_catalog.pg_xlog_replay_resume() owner to postgres;

create function pg_catalog.pg_is_xlog_replay_paused()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_is_xlog_replay_paused() is 'true if xlog replay is paused';

alter function pg_catalog.pg_is_xlog_replay_paused() owner to postgres;

create function pg_catalog.pg_stat_get_db_stat_reset_time(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_stat_reset_time(oid) is 'statistics: last reset for a database';

alter function pg_catalog.pg_stat_get_db_stat_reset_time(oid) owner to postgres;

create function pg_catalog.pg_stat_get_bgwriter_stat_reset_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() is 'statistics: last reset for the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() owner to postgres;

create function pg_catalog.ginarrayextract(anyarray, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ginarrayextract(anyarray, internal) is 'GIN array support (obsolete)';

alter function pg_catalog.ginarrayextract(anyarray, internal) owner to postgres;

create function pg_catalog.gin_extract_tsvector(tsvector, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsvector(tsvector, internal) owner to postgres;

create function pg_catalog.pg_sequence_parameters(sequence_oid oid, out start_value bigint, out minimum_value bigint,
                                                  out maximum_value bigint, out increment bigint,
                                                  out cycle_option boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_sequence_parameters(oid, out bigint, out bigint, out bigint, out bigint, out boolean) is 'sequence parameters, for use by information schema';

alter function pg_catalog.pg_sequence_parameters(oid, out bigint, out bigint, out bigint, out bigint, out boolean) owner to postgres;

create function pg_catalog.pg_available_extensions(out name name, out default_version text, out comment text)
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_available_extensions(out name, out text, out text) is 'list available extensions';

alter function pg_catalog.pg_available_extensions(out name, out text, out text) owner to postgres;

create function pg_catalog.pg_available_extension_versions(out name name, out version text, out superuser boolean,
                                                           out relocatable boolean, out schema name,
                                                           out requires name[], out comment text)
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_available_extension_versions(out name, out text, out boolean, out boolean, out name, out name[], out text) is 'list available extension versions';

alter function pg_catalog.pg_available_extension_versions(out name, out text, out boolean, out boolean, out name, out name[], out text) owner to postgres;

create function pg_catalog.pg_extension_update_paths(name name, out source text, out target text, out path text)
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_extension_update_paths(name, out text, out text, out text) is 'list an extension''s version update paths';

alter function pg_catalog.pg_extension_update_paths(name, out text, out text, out text) owner to postgres;

create function pg_catalog.pg_extension_config_dump(regclass, text)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_extension_config_dump(regclass, text) is 'flag an extension''s table contents to be emitted by pg_dump';

alter function pg_catalog.pg_extension_config_dump(regclass, text) owner to postgres;

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal) owner to postgres;

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal) owner to postgres;

create function pg_catalog.pg_advisory_xact_lock(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_xact_lock(bigint) is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_xact_lock(bigint) owner to postgres;

create function pg_catalog.pg_advisory_xact_lock_shared(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_xact_lock_shared(bigint) is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_xact_lock_shared(bigint) owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_try_advisory_xact_lock(bigint) is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock(bigint) owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock_shared(bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(bigint) is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock_shared(bigint) owner to postgres;

create function pg_catalog.pg_advisory_xact_lock(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_xact_lock(integer, integer) is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_xact_lock(integer, integer) owner to postgres;

create function pg_catalog.pg_advisory_xact_lock_shared(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_advisory_xact_lock_shared(integer, integer) is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_xact_lock_shared(integer, integer) owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_try_advisory_xact_lock(integer, integer) is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock(integer, integer) owner to postgres;

create function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer) is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer) owner to postgres;

create function pg_catalog.varchar_transform(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varchar_transform(internal) is 'transform a varchar length coercion';

alter function pg_catalog.varchar_transform(internal) owner to postgres;

create function pg_catalog.pg_create_restore_point(text)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_create_restore_point(text) is 'create a named restore point';

alter function pg_catalog.pg_create_restore_point(text) owner to postgres;

create function pg_catalog.pg_stat_get_wal_senders(out pid integer, out state text, out sent_location pg_lsn,
                                                   out write_location pg_lsn, out flush_location pg_lsn,
                                                   out replay_location pg_lsn, out sync_priority integer,
                                                   out sync_state text)
    stable
    parallel restricted
    cost 1
    rows 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_wal_senders(out integer, out text, out pg_lsn, out pg_lsn, out pg_lsn, out pg_lsn, out integer, out text) is 'statistics: information about currently active replication';

alter function pg_catalog.pg_stat_get_wal_senders(out integer, out text, out pg_lsn, out pg_lsn, out pg_lsn, out pg_lsn, out integer, out text) owner to postgres;

create function pg_catalog.row_number()
    immutable
    window
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.row_number() is 'row number within partition';

alter function pg_catalog.row_number() owner to postgres;

create function pg_catalog.rank()
    immutable
    window
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.rank() is 'integer rank with gaps';

alter function pg_catalog.rank() owner to postgres;

create function pg_catalog.dense_rank()
    immutable
    window
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dense_rank() is 'integer rank without gaps';

alter function pg_catalog.dense_rank() owner to postgres;

create function pg_catalog.percent_rank()
    immutable
    window
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.percent_rank() is 'fractional rank within partition';

alter function pg_catalog.percent_rank() owner to postgres;

create function pg_catalog.cume_dist()
    immutable
    window
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cume_dist() is 'fractional row number within partition';

alter function pg_catalog.cume_dist() owner to postgres;

create function pg_catalog.ntile(integer)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ntile(integer) is 'split rows into N groups';

alter function pg_catalog.ntile(integer) owner to postgres;

create function pg_catalog.lag(anyelement)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lag(anyelement) is 'fetch the preceding row value';

alter function pg_catalog.lag(anyelement) owner to postgres;

create function pg_catalog.lag(anyelement, integer)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lag(anyelement, integer) is 'fetch the Nth preceding row value';

alter function pg_catalog.lag(anyelement, integer) owner to postgres;

create function pg_catalog.lag(anyelement, integer, anyelement)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lag(anyelement, integer, anyelement) is 'fetch the Nth preceding row value with default';

alter function pg_catalog.lag(anyelement, integer, anyelement) owner to postgres;

create function pg_catalog.lead(anyelement)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lead(anyelement) is 'fetch the following row value';

alter function pg_catalog.lead(anyelement) owner to postgres;

create function pg_catalog.lead(anyelement, integer)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lead(anyelement, integer) is 'fetch the Nth following row value';

alter function pg_catalog.lead(anyelement, integer) owner to postgres;

create function pg_catalog.lead(anyelement, integer, anyelement)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lead(anyelement, integer, anyelement) is 'fetch the Nth following row value with default';

alter function pg_catalog.lead(anyelement, integer, anyelement) owner to postgres;

create function pg_catalog.first_value(anyelement)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.first_value(anyelement) is 'fetch the first row value';

alter function pg_catalog.first_value(anyelement) owner to postgres;

create function pg_catalog.last_value(anyelement)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.last_value(anyelement) is 'fetch the last row value';

alter function pg_catalog.last_value(anyelement) owner to postgres;

create function pg_catalog.nth_value(anyelement, integer)
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.nth_value(anyelement, integer) is 'fetch the Nth row value';

alter function pg_catalog.nth_value(anyelement, integer) owner to postgres;

create function pg_catalog.fdw_handler_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.fdw_handler_in(cstring) is 'I/O';

alter function pg_catalog.fdw_handler_in(cstring) owner to postgres;

create function pg_catalog.fdw_handler_out(fdw_handler)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.fdw_handler_out(fdw_handler) is 'I/O';

alter function pg_catalog.fdw_handler_out(fdw_handler) owner to postgres;

create function pg_catalog.void_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.void_recv(internal) is 'I/O';

alter function pg_catalog.void_recv(internal) owner to postgres;

create function pg_catalog.void_send(void)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.void_send(void) is 'I/O';

alter function pg_catalog.void_send(void) owner to postgres;

create function pg_catalog.btint2sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint2sortsupport(internal) is 'sort support';

alter function pg_catalog.btint2sortsupport(internal) owner to postgres;

create function pg_catalog.btint4sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint4sortsupport(internal) is 'sort support';

alter function pg_catalog.btint4sortsupport(internal) owner to postgres;

create function pg_catalog.btint8sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btint8sortsupport(internal) is 'sort support';

alter function pg_catalog.btint8sortsupport(internal) owner to postgres;

create function pg_catalog.btfloat4sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btfloat4sortsupport(internal) is 'sort support';

alter function pg_catalog.btfloat4sortsupport(internal) owner to postgres;

create function pg_catalog.btfloat8sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btfloat8sortsupport(internal) is 'sort support';

alter function pg_catalog.btfloat8sortsupport(internal) owner to postgres;

create function pg_catalog.btoidsortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btoidsortsupport(internal) is 'sort support';

alter function pg_catalog.btoidsortsupport(internal) owner to postgres;

create function pg_catalog.btnamesortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btnamesortsupport(internal) is 'sort support';

alter function pg_catalog.btnamesortsupport(internal) owner to postgres;

create function pg_catalog.date_sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.date_sortsupport(internal) is 'sort support';

alter function pg_catalog.date_sortsupport(internal) owner to postgres;

create function pg_catalog.timestamp_sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_sortsupport(internal) is 'sort support';

alter function pg_catalog.timestamp_sortsupport(internal) owner to postgres;

create function pg_catalog.has_type_privilege(name, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_type_privilege(name, text, text) is 'user privilege on type by username, type name';

alter function pg_catalog.has_type_privilege(name, text, text) owner to postgres;

create function pg_catalog.has_type_privilege(name, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_type_privilege(name, oid, text) is 'user privilege on type by username, type oid';

alter function pg_catalog.has_type_privilege(name, oid, text) owner to postgres;

create function pg_catalog.has_type_privilege(oid, text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_type_privilege(oid, text, text) is 'user privilege on type by user oid, type name';

alter function pg_catalog.has_type_privilege(oid, text, text) owner to postgres;

create function pg_catalog.has_type_privilege(oid, oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_type_privilege(oid, oid, text) is 'user privilege on type by user oid, type oid';

alter function pg_catalog.has_type_privilege(oid, oid, text) owner to postgres;

create function pg_catalog.has_type_privilege(text, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_type_privilege(text, text) is 'current user privilege on type by type name';

alter function pg_catalog.has_type_privilege(text, text) owner to postgres;

create function pg_catalog.has_type_privilege(oid, text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.has_type_privilege(oid, text) is 'current user privilege on type by type oid';

alter function pg_catalog.has_type_privilege(oid, text) owner to postgres;

create function pg_catalog.macaddr_not(macaddr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_not(macaddr) is 'implementation of ~ operator';

alter function pg_catalog.macaddr_not(macaddr) owner to postgres;

create function pg_catalog.macaddr_and(macaddr, macaddr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_and(macaddr, macaddr) is 'implementation of & operator';

alter function pg_catalog.macaddr_and(macaddr, macaddr) owner to postgres;

create function pg_catalog.macaddr_or(macaddr, macaddr)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.macaddr_or(macaddr, macaddr) is 'implementation of | operator';

alter function pg_catalog.macaddr_or(macaddr, macaddr) owner to postgres;

create function pg_catalog.pg_stat_get_db_temp_files(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_temp_files(oid) is 'statistics: number of temporary files written';

alter function pg_catalog.pg_stat_get_db_temp_files(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_temp_bytes(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_temp_bytes(oid) is 'statistics: number of bytes in temporary files written';

alter function pg_catalog.pg_stat_get_db_temp_bytes(oid) owner to postgres;

create function pg_catalog.pg_stat_get_db_deadlocks(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_db_deadlocks(oid) is 'statistics: deadlocks detected in database';

alter function pg_catalog.pg_stat_get_db_deadlocks(oid) owner to postgres;

create function pg_catalog.array_to_json(anyarray)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_to_json(anyarray) is 'map array to json';

alter function pg_catalog.array_to_json(anyarray) owner to postgres;

create function pg_catalog.array_to_json(anyarray, boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_to_json(anyarray, boolean) is 'map array to json with optional pretty printing';

alter function pg_catalog.array_to_json(anyarray, boolean) owner to postgres;

create function pg_catalog.row_to_json(record)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.row_to_json(record) is 'map row to json';

alter function pg_catalog.row_to_json(record) owner to postgres;

create function pg_catalog.row_to_json(record, boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.row_to_json(record, boolean) is 'map row to json with optional pretty printing';

alter function pg_catalog.row_to_json(record, boolean) owner to postgres;

create function pg_catalog.numeric_transform(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_transform(internal) is 'transform a numeric length coercion';

alter function pg_catalog.numeric_transform(internal) owner to postgres;

create function pg_catalog.varbit_transform(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.varbit_transform(internal) is 'transform a varbit length coercion';

alter function pg_catalog.varbit_transform(internal) owner to postgres;

create function pg_catalog.pg_get_viewdef(oid, integer)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_viewdef(oid, integer) is 'select statement of a view with pretty-printing and specified line wrapping';

alter function pg_catalog.pg_get_viewdef(oid, integer) owner to postgres;

create function pg_catalog.pg_stat_get_checkpoint_write_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_checkpoint_write_time() is 'statistics: checkpoint time spent writing buffers to disk, in msec';

alter function pg_catalog.pg_stat_get_checkpoint_write_time() owner to postgres;

create function pg_catalog.pg_stat_get_checkpoint_sync_time()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_checkpoint_sync_time() is 'statistics: checkpoint time spent synchronizing buffers to disk, in msec';

alter function pg_catalog.pg_stat_get_checkpoint_sync_time() owner to postgres;

create function pg_catalog.pg_collation_for("any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_collation_for("any") is 'collation of the argument; implementation of the COLLATION FOR expression';

alter function pg_catalog.pg_collation_for("any") owner to postgres;

create function pg_catalog.pg_trigger_depth()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_trigger_depth() is 'current trigger depth';

alter function pg_catalog.pg_trigger_depth() owner to postgres;

create function pg_catalog.pg_xlog_location_diff(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_xlog_location_diff(pg_lsn, pg_lsn) is 'difference in bytes, given two xlog locations';

alter function pg_catalog.pg_xlog_location_diff(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_size_pretty(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_size_pretty(numeric) is 'convert a numeric to a human readable text using size units';

alter function pg_catalog.pg_size_pretty(numeric) owner to postgres;

create function pg_catalog.array_remove(anyarray, anyelement)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_remove(anyarray, anyelement) is 'remove any occurrences of an element from an array';

alter function pg_catalog.array_remove(anyarray, anyelement) owner to postgres;

create function pg_catalog.array_replace(anyarray, anyelement, anyelement)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_replace(anyarray, anyelement, anyelement) is 'replace any occurrences of an element in an array';

alter function pg_catalog.array_replace(anyarray, anyelement, anyelement) owner to postgres;

create function pg_catalog.rangesel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.rangesel(internal, oid, internal, integer) is 'restriction selectivity for range operators';

alter function pg_catalog.rangesel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.lo_lseek64(integer, bigint, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_lseek64(integer, bigint, integer) is 'large object seek (64 bit)';

alter function pg_catalog.lo_lseek64(integer, bigint, integer) owner to postgres;

create function pg_catalog.lo_tell64(integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_tell64(integer) is 'large object position (64 bit)';

alter function pg_catalog.lo_tell64(integer) owner to postgres;

create function pg_catalog.lo_truncate64(integer, bigint)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_truncate64(integer, bigint) is 'truncate large object (64 bit)';

alter function pg_catalog.lo_truncate64(integer, bigint) owner to postgres;

create function pg_catalog.json_agg_transfn(internal, anyelement)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_agg_transfn(internal, anyelement) is 'json aggregate transition function';

alter function pg_catalog.json_agg_transfn(internal, anyelement) owner to postgres;

create function pg_catalog.json_agg_finalfn(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_agg_finalfn(internal) is 'json aggregate final function';

alter function pg_catalog.json_agg_finalfn(internal) owner to postgres;

create function pg_catalog.to_json(anyelement)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_json(anyelement) is 'map input to json';

alter function pg_catalog.to_json(anyelement) owner to postgres;

create function pg_catalog.pg_stat_get_mod_since_analyze(oid)
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_mod_since_analyze(oid) is 'statistics: number of tuples changed since last analyze';

alter function pg_catalog.pg_stat_get_mod_since_analyze(oid) owner to postgres;

create function pg_catalog.numeric_sum(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_sum(internal) is 'aggregate final function';

alter function pg_catalog.numeric_sum(internal) owner to postgres;

create function pg_catalog.cardinality(anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cardinality(anyarray) is 'array cardinality';

alter function pg_catalog.cardinality(anyarray) owner to postgres;

create function pg_catalog.json_object_agg_transfn(internal, "any", "any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_object_agg_transfn(internal, "any", "any") is 'json object aggregate transition function';

alter function pg_catalog.json_object_agg_transfn(internal, "any", "any") owner to postgres;

create function pg_catalog.record_image_eq(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_image_eq(record, record) is 'implementation of *= operator';

alter function pg_catalog.record_image_eq(record, record) owner to postgres;

create function pg_catalog.record_image_ne(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_image_ne(record, record) is 'implementation of *<> operator';

alter function pg_catalog.record_image_ne(record, record) owner to postgres;

create function pg_catalog.record_image_lt(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_image_lt(record, record) is 'implementation of *< operator';

alter function pg_catalog.record_image_lt(record, record) owner to postgres;

create function pg_catalog.record_image_gt(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_image_gt(record, record) is 'implementation of *> operator';

alter function pg_catalog.record_image_gt(record, record) owner to postgres;

create function pg_catalog.record_image_le(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_image_le(record, record) is 'implementation of *<= operator';

alter function pg_catalog.record_image_le(record, record) owner to postgres;

create function pg_catalog.record_image_ge(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.record_image_ge(record, record) is 'implementation of *>= operator';

alter function pg_catalog.record_image_ge(record, record) owner to postgres;

create function pg_catalog.btrecordimagecmp(record, record)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btrecordimagecmp(record, record) is 'less-equal-greater based on byte images';

alter function pg_catalog.btrecordimagecmp(record, record) owner to postgres;

create function pg_catalog.pg_stat_get_archiver(out archived_count bigint, out last_archived_wal text,
                                                out last_archived_time timestamp with time zone,
                                                out failed_count bigint, out last_failed_wal text,
                                                out last_failed_time timestamp with time zone,
                                                out stats_reset timestamp with time zone)
    stable
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_archiver(out bigint, out text, out timestamp with time zone, out bigint, out text, out timestamp with time zone, out timestamp with time zone) is 'statistics: information about WAL archiver';

alter function pg_catalog.pg_stat_get_archiver(out bigint, out text, out timestamp with time zone, out bigint, out text, out timestamp with time zone, out timestamp with time zone) owner to postgres;

create function pg_catalog.json_object_agg_finalfn(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_object_agg_finalfn(internal) is 'json object aggregate final function';

alter function pg_catalog.json_object_agg_finalfn(internal) owner to postgres;

create function pg_catalog.json_build_array("any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_build_array("any") is 'build a json array from any inputs';

alter function pg_catalog.json_build_array("any") owner to postgres;

create function pg_catalog.json_build_array()
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_build_array() is 'build an empty json array';

alter function pg_catalog.json_build_array() owner to postgres;

create function pg_catalog.json_build_object("any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_build_object("any") is 'build a json object from pairwise key/value inputs';

alter function pg_catalog.json_build_object("any") owner to postgres;

create function pg_catalog.json_build_object()
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_build_object() is 'build an empty json object';

alter function pg_catalog.json_build_object() owner to postgres;

create function pg_catalog.json_object(text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_object(text[]) is 'map text array of key value pairs to json object';

alter function pg_catalog.json_object(text[]) owner to postgres;

create function pg_catalog.json_object(text[], text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_object(text[], text[]) is 'map text arrays of keys and values to json object';

alter function pg_catalog.json_object(text[], text[]) owner to postgres;

create function pg_catalog.json_to_record(json)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_to_record(json) is 'get record fields from a json object';

alter function pg_catalog.json_to_record(json) owner to postgres;

create function pg_catalog.json_to_recordset(json)
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.json_to_recordset(json) is 'get set of records with fields from a json array of objects';

alter function pg_catalog.json_to_recordset(json) owner to postgres;

create function pg_catalog.jsonb_array_length(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_array_length(jsonb) is 'length of jsonb array';

alter function pg_catalog.jsonb_array_length(jsonb) owner to postgres;

create function pg_catalog.jsonb_each(from_json jsonb, out key text, out value jsonb)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_each(jsonb, out text, out jsonb) is 'key value pairs of a jsonb object';

alter function pg_catalog.jsonb_each(jsonb, out text, out jsonb) owner to postgres;

create function pg_catalog.jsonb_populate_record(anyelement, jsonb)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_populate_record(anyelement, jsonb) is 'get record fields from a jsonb object';

alter function pg_catalog.jsonb_populate_record(anyelement, jsonb) owner to postgres;

create function pg_catalog.jsonb_typeof(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_typeof(jsonb) is 'get the type of a jsonb value';

alter function pg_catalog.jsonb_typeof(jsonb) owner to postgres;

create function pg_catalog.jsonb_object_field_text(from_json jsonb, field_name text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_object_field_text(jsonb, text) is 'implementation of ->> operator';

alter function pg_catalog.jsonb_object_field_text(jsonb, text) owner to postgres;

create function pg_catalog.jsonb_array_element(from_json jsonb, element_index integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_array_element(jsonb, integer) is 'implementation of -> operator';

alter function pg_catalog.jsonb_array_element(jsonb, integer) owner to postgres;

create function pg_catalog.jsonb_array_element_text(from_json jsonb, element_index integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_array_element_text(jsonb, integer) is 'implementation of ->> operator';

alter function pg_catalog.jsonb_array_element_text(jsonb, integer) owner to postgres;

create function pg_catalog.jsonb_extract_path(from_json jsonb, path_elems text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_extract_path(jsonb, text[]) is 'get value from jsonb with path elements';

alter function pg_catalog.jsonb_extract_path(jsonb, text[]) owner to postgres;

create function pg_catalog.width_bucket(anyelement, anyarray)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.width_bucket(anyelement, anyarray) is 'bucket number of operand given a sorted array of bucket lower bounds';

alter function pg_catalog.width_bucket(anyelement, anyarray) owner to postgres;

create function pg_catalog.jsonb_array_elements(from_json jsonb, out value jsonb)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_array_elements(jsonb, out jsonb) is 'elements of a jsonb array';

alter function pg_catalog.jsonb_array_elements(jsonb, out jsonb) owner to postgres;

create function pg_catalog.pg_lsn_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_in(cstring) is 'I/O';

alter function pg_catalog.pg_lsn_in(cstring) owner to postgres;

create function pg_catalog.pg_lsn_out(pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_out(pg_lsn) is 'I/O';

alter function pg_catalog.pg_lsn_out(pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) is 'implementation of < operator';

alter function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) is 'implementation of <= operator';

alter function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) is 'implementation of = operator';

alter function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) is 'implementation of >= operator';

alter function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) is 'implementation of > operator';

alter function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) is 'implementation of <> operator';

alter function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) is 'implementation of - operator';

alter function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_recv(internal) is 'I/O';

alter function pg_catalog.pg_lsn_recv(internal) owner to postgres;

create function pg_catalog.pg_lsn_send(pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_send(pg_lsn) is 'I/O';

alter function pg_catalog.pg_lsn_send(pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) is 'less-equal-greater';

alter function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) owner to postgres;

create function pg_catalog.pg_lsn_hash(pg_lsn)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_lsn_hash(pg_lsn) is 'hash';

alter function pg_catalog.pg_lsn_hash(pg_lsn) owner to postgres;

create function pg_catalog.bttextsortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bttextsortsupport(internal) is 'sort support';

alter function pg_catalog.bttextsortsupport(internal) owner to postgres;

create function pg_catalog.generate_series(numeric, numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_series(numeric, numeric, numeric) is 'non-persistent series generator';

alter function pg_catalog.generate_series(numeric, numeric, numeric) owner to postgres;

create function pg_catalog.generate_series(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.generate_series(numeric, numeric) is 'non-persistent series generator';

alter function pg_catalog.generate_series(numeric, numeric) owner to postgres;

create function pg_catalog.json_strip_nulls(json)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_strip_nulls(json) is 'remove object fields with null values from json';

alter function pg_catalog.json_strip_nulls(json) owner to postgres;

create function pg_catalog.jsonb_strip_nulls(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_strip_nulls(jsonb) is 'remove object fields with null values from jsonb';

alter function pg_catalog.jsonb_strip_nulls(jsonb) owner to postgres;

create function pg_catalog.jsonb_object(text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_object(text[]) is 'map text array of key value pairs to jsonb object';

alter function pg_catalog.jsonb_object(text[]) owner to postgres;

create function pg_catalog.jsonb_object(text[], text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_object(text[], text[]) is 'map text array of key value pairs to jsonb object';

alter function pg_catalog.jsonb_object(text[], text[]) owner to postgres;

create function pg_catalog.jsonb_agg_transfn(internal, anyelement)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_agg_transfn(internal, anyelement) is 'jsonb aggregate transition function';

alter function pg_catalog.jsonb_agg_transfn(internal, anyelement) owner to postgres;

create function pg_catalog.jsonb_agg_finalfn(internal)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_agg_finalfn(internal) is 'jsonb aggregate final function';

alter function pg_catalog.jsonb_agg_finalfn(internal) owner to postgres;

create function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") is 'jsonb object aggregate transition function';

alter function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") owner to postgres;

create function pg_catalog.jsonb_object_agg_finalfn(internal)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_object_agg_finalfn(internal) is 'jsonb object aggregate final function';

alter function pg_catalog.jsonb_object_agg_finalfn(internal) owner to postgres;

create function pg_catalog.jsonb_build_array("any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_build_array("any") is 'build a jsonb array from any inputs';

alter function pg_catalog.jsonb_build_array("any") owner to postgres;

create function pg_catalog.jsonb_build_array()
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_build_array() is 'build an empty jsonb array';

alter function pg_catalog.jsonb_build_array() owner to postgres;

create function pg_catalog.jsonb_build_object("any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_build_object("any") is 'build a jsonb object from pairwise key/value inputs';

alter function pg_catalog.jsonb_build_object("any") owner to postgres;

create function pg_catalog.jsonb_build_object()
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_build_object() is 'build an empty jsonb object';

alter function pg_catalog.jsonb_build_object() owner to postgres;

create function pg_catalog.dist_ppoly(point, polygon)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_ppoly(point, polygon) is 'implementation of <-> operator';

alter function pg_catalog.dist_ppoly(point, polygon) owner to postgres;

create function pg_catalog.array_position(anyarray, anyelement)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_position(anyarray, anyelement) is 'returns an offset of value in array';

alter function pg_catalog.array_position(anyarray, anyelement) owner to postgres;

create function pg_catalog.array_position(anyarray, anyelement, integer)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_position(anyarray, anyelement, integer) is 'returns an offset of value in array with start index';

alter function pg_catalog.array_position(anyarray, anyelement, integer) owner to postgres;

create function pg_catalog.array_positions(anyarray, anyelement)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_positions(anyarray, anyelement) is 'returns an array of offsets of some value in array';

alter function pg_catalog.array_positions(anyarray, anyelement) owner to postgres;

create function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) owner to postgres;

create function pg_catalog.gist_box_fetch(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_box_fetch(internal) is 'GiST support';

alter function pg_catalog.gist_box_fetch(internal) owner to postgres;

create function pg_catalog.gist_point_fetch(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_point_fetch(internal) is 'GiST support';

alter function pg_catalog.gist_point_fetch(internal) owner to postgres;

create function pg_catalog.numeric_sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_sortsupport(internal) is 'sort support';

alter function pg_catalog.numeric_sortsupport(internal) owner to postgres;

create function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) owner to postgres;

create function pg_catalog.dist_cpoint(circle, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_cpoint(circle, point) is 'implementation of <-> operator';

alter function pg_catalog.dist_cpoint(circle, point) owner to postgres;

create function pg_catalog.dist_polyp(polygon, point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dist_polyp(polygon, point) is 'implementation of <-> operator';

alter function pg_catalog.dist_polyp(polygon, point) owner to postgres;

create function pg_catalog.pg_read_file(text, bigint, bigint, boolean)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_read_file(text, bigint, bigint, boolean) is 'read text from a file';

alter function pg_catalog.pg_read_file(text, bigint, bigint, boolean) owner to postgres;

create function pg_catalog.current_setting(text, boolean)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.current_setting(text, boolean) is 'SHOW X as a function, optionally no error for missing variable';

alter function pg_catalog.current_setting(text, boolean) owner to postgres;

create function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) owner to postgres;

create function pg_catalog.pg_notification_queue_usage()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_notification_queue_usage() is 'get the fraction of the asynchronous notification queue currently in use';

alter function pg_catalog.pg_notification_queue_usage() owner to postgres;

create function pg_catalog.pg_ls_dir(text, boolean, boolean)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ls_dir(text, boolean, boolean) is 'list all files in a directory';

alter function pg_catalog.pg_ls_dir(text, boolean, boolean) owner to postgres;

create function pg_catalog.row_security_active(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.row_security_active(oid) is 'row security for current context active on table by table oid';

alter function pg_catalog.row_security_active(oid) owner to postgres;

create function pg_catalog.row_security_active(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.row_security_active(text) is 'row security for current context active on table by table name';

alter function pg_catalog.row_security_active(text) owner to postgres;

create function pg_catalog.uuid_sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.uuid_sortsupport(internal) is 'sort support';

alter function pg_catalog.uuid_sortsupport(internal) owner to postgres;

create function pg_catalog.jsonb_concat(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_concat(jsonb, jsonb) is 'implementation of || operator';

alter function pg_catalog.jsonb_concat(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_delete(jsonb, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_delete(jsonb, text) is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(jsonb, text) owner to postgres;

create function pg_catalog.jsonb_delete(jsonb, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_delete(jsonb, integer) is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(jsonb, integer) owner to postgres;

create function pg_catalog.jsonb_delete_path(jsonb, text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_delete_path(jsonb, text[]) is 'implementation of #- operator';

alter function pg_catalog.jsonb_delete_path(jsonb, text[]) owner to postgres;

create function pg_catalog.jsonb_set(jsonb_in jsonb, path text[], replacement jsonb,
                                     create_if_missing boolean default true)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_set(jsonb, text[], jsonb, boolean) is 'Set part of a jsonb';

alter function pg_catalog.jsonb_set(jsonb, text[], jsonb, boolean) owner to postgres;

create function pg_catalog.jsonb_pretty(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_pretty(jsonb) is 'Indented text from jsonb';

alter function pg_catalog.jsonb_pretty(jsonb) owner to postgres;

create function pg_catalog.pg_stat_file(filename text, missing_ok boolean, out size bigint,
                                        out access timestamp with time zone, out modification timestamp with time zone,
                                        out change timestamp with time zone, out creation timestamp with time zone,
                                        out isdir boolean)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_file(text, boolean, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) is 'get information about file';

alter function pg_catalog.pg_stat_file(text, boolean, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) owner to postgres;

create function pg_catalog.xidneq(xid, xid)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xidneq(xid, xid) is 'implementation of <> operator';

alter function pg_catalog.xidneq(xid, xid) owner to postgres;

create function pg_catalog.xidneqint4(xid, integer)
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.xidneqint4(xid, integer) is 'implementation of <> operator';

alter function pg_catalog.xidneqint4(xid, integer) owner to postgres;

create function pg_catalog.tsm_handler_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsm_handler_in(cstring) is 'I/O';

alter function pg_catalog.tsm_handler_in(cstring) owner to postgres;

create function pg_catalog.tsm_handler_out(tsm_handler)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsm_handler_out(tsm_handler) is 'I/O';

alter function pg_catalog.tsm_handler_out(tsm_handler) owner to postgres;

create function pg_catalog.bernoulli(internal)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bernoulli(internal) is 'BERNOULLI tablesample method handler';

alter function pg_catalog.bernoulli(internal) owner to postgres;

create function pg_catalog.system(internal)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.system(internal) is 'SYSTEM tablesample method handler';

alter function pg_catalog.system(internal) owner to postgres;

create function pg_catalog.pg_stat_get_wal_receiver(out pid integer, out status text, out receive_start_lsn pg_lsn,
                                                    out receive_start_tli integer, out received_lsn pg_lsn,
                                                    out received_tli integer,
                                                    out last_msg_send_time timestamp with time zone,
                                                    out last_msg_receipt_time timestamp with time zone,
                                                    out latest_end_lsn pg_lsn,
                                                    out latest_end_time timestamp with time zone, out slot_name text,
                                                    out conninfo text)
    stable
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_wal_receiver(out integer, out text, out pg_lsn, out integer, out pg_lsn, out integer, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone, out text, out text) is 'statistics: information about WAL receiver';

alter function pg_catalog.pg_stat_get_wal_receiver(out integer, out text, out pg_lsn, out integer, out pg_lsn, out integer, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone, out text, out text) owner to postgres;

create function pg_catalog.pg_stat_get_progress_info(cmdtype text, out pid integer, out datid oid, out relid oid,
                                                     out param1 bigint, out param2 bigint, out param3 bigint,
                                                     out param4 bigint, out param5 bigint, out param6 bigint,
                                                     out param7 bigint, out param8 bigint, out param9 bigint,
                                                     out param10 bigint)
    stable
    strict
    parallel restricted
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_progress_info(text, out integer, out oid, out oid, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint) is 'statistics: information about progress of backends running maintenance command';

alter function pg_catalog.pg_stat_get_progress_info(text, out integer, out oid, out oid, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint) owner to postgres;

create function pg_catalog.ts_filter(tsvector, "char"[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_filter(tsvector, "char"[]) is 'delete lexemes that do not have one of the given weights';

alter function pg_catalog.ts_filter(tsvector, "char"[]) owner to postgres;

create function pg_catalog.setweight(tsvector, "char", text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.setweight(tsvector, "char", text[]) is 'set given weight for given lexemes';

alter function pg_catalog.setweight(tsvector, "char", text[]) owner to postgres;

create function pg_catalog.ts_delete(tsvector, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_delete(tsvector, text) is 'delete lexeme';

alter function pg_catalog.ts_delete(tsvector, text) owner to postgres;

create function pg_catalog.unnest(tsvector tsvector, out lexeme text, out positions smallint[], out weights text[])
    immutable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as -- missing source code
;

comment on function pg_catalog.unnest(tsvector, out text, out smallint[], out text[]) is 'expand tsvector to set of rows';

alter function pg_catalog.unnest(tsvector, out text, out smallint[], out text[]) owner to postgres;

create function pg_catalog.ts_delete(tsvector, text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_delete(tsvector, text[]) is 'delete given lexemes';

alter function pg_catalog.ts_delete(tsvector, text[]) owner to postgres;

create function pg_catalog.int4_avg_combine(bigint[], bigint[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4_avg_combine(bigint[], bigint[]) is 'aggregate combine function';

alter function pg_catalog.int4_avg_combine(bigint[], bigint[]) owner to postgres;

create function pg_catalog.interval_combine(interval[], interval[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_combine(interval[], interval[]) is 'aggregate combine function';

alter function pg_catalog.interval_combine(interval[], interval[]) owner to postgres;

create function pg_catalog.tsvector_to_array(tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_to_array(tsvector) is 'convert tsvector to array of lexemes';

alter function pg_catalog.tsvector_to_array(tsvector) owner to postgres;

create function pg_catalog.array_to_tsvector(text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_to_tsvector(text[]) is 'build tsvector from array of lexemes';

alter function pg_catalog.array_to_tsvector(text[]) owner to postgres;

create function pg_catalog.bpchar_sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bpchar_sortsupport(internal) is 'sort support';

alter function pg_catalog.bpchar_sortsupport(internal) owner to postgres;

create function pg_catalog.pg_show_all_file_settings(out sourcefile text, out sourceline integer, out seqno integer,
                                                     out name text, out setting text, out applied boolean,
                                                     out error text)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_show_all_file_settings(out text, out integer, out integer, out text, out text, out boolean, out text) is 'show config file settings';

alter function pg_catalog.pg_show_all_file_settings(out text, out integer, out integer, out text, out text, out boolean, out text) owner to postgres;

create function pg_catalog.pg_current_xlog_flush_location()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_current_xlog_flush_location() is 'current xlog flush location';

alter function pg_catalog.pg_current_xlog_flush_location() owner to postgres;

create function pg_catalog.bytea_sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bytea_sortsupport(internal) is 'sort support';

alter function pg_catalog.bytea_sortsupport(internal) owner to postgres;

create function pg_catalog.bttext_pattern_sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bttext_pattern_sortsupport(internal) is 'sort support';

alter function pg_catalog.bttext_pattern_sortsupport(internal) owner to postgres;

create function pg_catalog.btbpchar_pattern_sortsupport(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.btbpchar_pattern_sortsupport(internal) is 'sort support';

alter function pg_catalog.btbpchar_pattern_sortsupport(internal) owner to postgres;

create function pg_catalog.pg_size_bytes(text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_size_bytes(text) is 'convert a size in human-readable format with size units into bytes';

alter function pg_catalog.pg_size_bytes(text) owner to postgres;

create function pg_catalog.numeric_serialize(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_serialize(internal) is 'aggregate serial function';

alter function pg_catalog.numeric_serialize(internal) owner to postgres;

create function pg_catalog.numeric_deserialize(bytea, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_deserialize(bytea, internal) is 'aggregate deserial function';

alter function pg_catalog.numeric_deserialize(bytea, internal) owner to postgres;

create function pg_catalog.numeric_avg_combine(internal, internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_avg_combine(internal, internal) is 'aggregate combine function';

alter function pg_catalog.numeric_avg_combine(internal, internal) owner to postgres;

create function pg_catalog.numeric_poly_combine(internal, internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_combine(internal, internal) is 'aggregate combine function';

alter function pg_catalog.numeric_poly_combine(internal, internal) owner to postgres;

create function pg_catalog.numeric_poly_serialize(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_serialize(internal) is 'aggregate serial function';

alter function pg_catalog.numeric_poly_serialize(internal) owner to postgres;

create function pg_catalog.numeric_poly_deserialize(bytea, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_deserialize(bytea, internal) is 'aggregate deserial function';

alter function pg_catalog.numeric_poly_deserialize(bytea, internal) owner to postgres;

create function pg_catalog.numeric_combine(internal, internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_combine(internal, internal) is 'aggregate combine function';

alter function pg_catalog.numeric_combine(internal, internal) owner to postgres;

create function pg_catalog.float8_regr_combine(double precision[], double precision[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.float8_regr_combine(double precision[], double precision[]) is 'aggregate combine function';

alter function pg_catalog.float8_regr_combine(double precision[], double precision[]) owner to postgres;

create function pg_catalog.pg_identify_object_as_address(classid oid, objid oid, subobjid integer, out type text,
                                                         out object_names text[], out object_args text[])
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_identify_object_as_address(oid, oid, integer, out text, out text[], out text[]) is 'get identification of SQL object for pg_get_object_address()';

alter function pg_catalog.pg_identify_object_as_address(oid, oid, integer, out text, out text[], out text[]) owner to postgres;

create function pg_catalog.brin_minmax_opcinfo(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_minmax_opcinfo(internal) is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_opcinfo(internal) owner to postgres;

create function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) owner to postgres;

create function pg_catalog.brin_minmax_consistent(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_minmax_consistent(internal, internal, internal) is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_consistent(internal, internal, internal) owner to postgres;

create function pg_catalog.brin_minmax_union(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_minmax_union(internal, internal, internal) is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_union(internal, internal, internal) owner to postgres;

create function pg_catalog.int8_avg_accum_inv(internal, bigint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_avg_accum_inv(internal, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_avg_accum_inv(internal, bigint) owner to postgres;

create function pg_catalog.numeric_poly_sum(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_sum(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_sum(internal) owner to postgres;

create function pg_catalog.numeric_poly_avg(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_avg(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_avg(internal) owner to postgres;

create function pg_catalog.numeric_poly_var_pop(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_var_pop(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_var_pop(internal) owner to postgres;

create function pg_catalog.numeric_poly_var_samp(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_var_samp(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_var_samp(internal) owner to postgres;

create function pg_catalog.numeric_poly_stddev_pop(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_stddev_pop(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_stddev_pop(internal) owner to postgres;

create function pg_catalog.numeric_poly_stddev_samp(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_poly_stddev_samp(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_stddev_samp(internal) owner to postgres;

create function pg_catalog.pg_config(out name text, out setting text)
    immutable
    strict
    parallel restricted
    cost 1
    rows 23
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_config(out text, out text) is 'pg_config binary as a function';

alter function pg_catalog.pg_config(out text, out text) owner to postgres;

create function pg_catalog.pg_control_system(out pg_control_version integer, out catalog_version_no integer,
                                             out system_identifier bigint,
                                             out pg_control_last_modified timestamp with time zone)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_control_system(out integer, out integer, out bigint, out timestamp with time zone) is 'pg_controldata general state information as a function';

alter function pg_catalog.pg_control_system(out integer, out integer, out bigint, out timestamp with time zone) owner to postgres;

create function pg_catalog.pg_control_checkpoint(out checkpoint_location pg_lsn, out prior_location pg_lsn,
                                                 out redo_location pg_lsn, out redo_wal_file text,
                                                 out timeline_id integer, out prev_timeline_id integer,
                                                 out full_page_writes boolean, out next_xid text, out next_oid oid,
                                                 out next_multixact_id xid, out next_multi_offset xid,
                                                 out oldest_xid xid, out oldest_xid_dbid oid, out oldest_active_xid xid,
                                                 out oldest_multi_xid xid, out oldest_multi_dbid oid,
                                                 out oldest_commit_ts_xid xid, out newest_commit_ts_xid xid,
                                                 out checkpoint_time timestamp with time zone)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_control_checkpoint(out pg_lsn, out pg_lsn, out pg_lsn, out text, out integer, out integer, out boolean, out text, out oid, out xid, out xid, out xid, out oid, out xid, out xid, out oid, out xid, out xid, out timestamp with time zone) is 'pg_controldata checkpoint state information as a function';

alter function pg_catalog.pg_control_checkpoint(out pg_lsn, out pg_lsn, out pg_lsn, out text, out integer, out integer, out boolean, out text, out oid, out xid, out xid, out xid, out oid, out xid, out xid, out oid, out xid, out xid, out timestamp with time zone) owner to postgres;

create function pg_catalog.pg_control_recovery(out min_recovery_end_location pg_lsn,
                                               out min_recovery_end_timeline integer, out backup_start_location pg_lsn,
                                               out backup_end_location pg_lsn,
                                               out end_of_backup_record_required boolean)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_control_recovery(out pg_lsn, out integer, out pg_lsn, out pg_lsn, out boolean) is 'pg_controldata recovery state information as a function';

alter function pg_catalog.pg_control_recovery(out pg_lsn, out integer, out pg_lsn, out pg_lsn, out boolean) owner to postgres;

create function pg_catalog.pg_control_init(out max_data_alignment integer, out database_block_size integer,
                                           out blocks_per_segment integer, out wal_block_size integer,
                                           out bytes_per_wal_segment integer, out max_identifier_length integer,
                                           out max_index_columns integer, out max_toast_chunk_size integer,
                                           out large_object_chunk_size integer, out bigint_timestamps boolean,
                                           out float4_pass_by_value boolean, out float8_pass_by_value boolean,
                                           out data_page_checksum_version integer)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_control_init(out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out boolean, out boolean, out boolean, out integer) is 'pg_controldata init state information as a function';

alter function pg_catalog.pg_control_init(out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out boolean, out boolean, out boolean, out integer) owner to postgres;

create function pg_catalog.pg_filenode_relation(oid, oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_filenode_relation(oid, oid) is 'relation OID for filenode and tablespace';

alter function pg_catalog.pg_filenode_relation(oid, oid) owner to postgres;

create function pg_catalog.lo_from_bytea(oid, bytea)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_from_bytea(oid, bytea) is 'create new large object with given content';

alter function pg_catalog.lo_from_bytea(oid, bytea) owner to postgres;

create function pg_catalog.lo_get(oid)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_get(oid) is 'read entire large object';

alter function pg_catalog.lo_get(oid) owner to postgres;

create function pg_catalog.lo_get(oid, bigint, integer)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_get(oid, bigint, integer) is 'read large object from offset for length';

alter function pg_catalog.lo_get(oid, bigint, integer) owner to postgres;

create function pg_catalog.lo_put(oid, bigint, bytea)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lo_put(oid, bigint, bytea) is 'write data at offset';

alter function pg_catalog.lo_put(oid, bigint, bytea) owner to postgres;

create function pg_catalog.make_timestamp(year integer, month integer, mday integer, hour integer, min integer,
                                          sec double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision) is 'construct timestamp';

alter function pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision) owner to postgres;

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer,
                                            sec double precision)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision) is 'construct timestamp with time zone';

alter function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision) owner to postgres;

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer,
                                            sec double precision, timezone text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text) is 'construct timestamp with time zone';

alter function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text) owner to postgres;

create function pg_catalog.make_interval(years integer default 0, months integer default 0, weeks integer default 0,
                                         days integer default 0, hours integer default 0, mins integer default 0,
                                         secs double precision default 0.0)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision) is 'construct interval';

alter function pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision) owner to postgres;

create function pg_catalog.jsonb_array_elements_text(from_json jsonb, out value text)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_array_elements_text(jsonb, out text) is 'elements of jsonb array';

alter function pg_catalog.jsonb_array_elements_text(jsonb, out text) owner to postgres;

create function pg_catalog.spg_range_quad_config(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_range_quad_config(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_config(internal, internal) owner to postgres;

create function pg_catalog.spg_range_quad_choose(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_range_quad_choose(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_choose(internal, internal) owner to postgres;

create function pg_catalog.spg_range_quad_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_range_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_picksplit(internal, internal) owner to postgres;

create function pg_catalog.spg_range_quad_inner_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_range_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_inner_consistent(internal, internal) owner to postgres;

create function pg_catalog.spg_range_quad_leaf_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_range_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_leaf_consistent(internal, internal) owner to postgres;

create function pg_catalog.jsonb_populate_recordset(anyelement, jsonb)
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_populate_recordset(anyelement, jsonb) is 'get set of records with fields from a jsonb array of objects';

alter function pg_catalog.jsonb_populate_recordset(anyelement, jsonb) owner to postgres;

create function pg_catalog.to_regoperator(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_regoperator(text) is 'convert operator name to regoperator';

alter function pg_catalog.to_regoperator(text) owner to postgres;

create function pg_catalog.jsonb_object_field(from_json jsonb, field_name text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_object_field(jsonb, text) is 'implementation of -> operator';

alter function pg_catalog.jsonb_object_field(jsonb, text) owner to postgres;

create function pg_catalog.to_regprocedure(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_regprocedure(text) is 'convert proname to regprocedure';

alter function pg_catalog.to_regprocedure(text) owner to postgres;

create function pg_catalog.gin_compare_jsonb(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_compare_jsonb(text, text) is 'GIN support';

alter function pg_catalog.gin_compare_jsonb(text, text) owner to postgres;

create function pg_catalog.gin_extract_jsonb(jsonb, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_jsonb(jsonb, internal, internal) is 'GIN support';

alter function pg_catalog.gin_extract_jsonb(jsonb, internal, internal) owner to postgres;

create function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal,
                                                internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) owner to postgres;

create function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal,
                                                     internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) owner to postgres;

create function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) owner to postgres;

create function pg_catalog.jsonb_to_record(jsonb)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_to_record(jsonb) is 'get record fields from a jsonb object';

alter function pg_catalog.jsonb_to_record(jsonb) owner to postgres;

create function pg_catalog.jsonb_to_recordset(jsonb)
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_to_recordset(jsonb) is 'get set of records with fields from a jsonb array of objects';

alter function pg_catalog.jsonb_to_recordset(jsonb) owner to postgres;

create function pg_catalog.to_regoper(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_regoper(text) is 'convert operator name to regoper';

alter function pg_catalog.to_regoper(text) owner to postgres;

create function pg_catalog.to_regtype(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_regtype(text) is 'convert type name to regtype';

alter function pg_catalog.to_regtype(text) owner to postgres;

create function pg_catalog.to_regproc(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_regproc(text) is 'convert proname to regproc';

alter function pg_catalog.to_regproc(text) owner to postgres;

create function pg_catalog.to_regclass(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_regclass(text) is 'convert classname to regclass';

alter function pg_catalog.to_regclass(text) owner to postgres;

create function pg_catalog.bool_accum(internal, boolean)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bool_accum(internal, boolean) is 'aggregate transition function';

alter function pg_catalog.bool_accum(internal, boolean) owner to postgres;

create function pg_catalog.bool_accum_inv(internal, boolean)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bool_accum_inv(internal, boolean) is 'aggregate transition function';

alter function pg_catalog.bool_accum_inv(internal, boolean) owner to postgres;

create function pg_catalog.bool_alltrue(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bool_alltrue(internal) is 'aggregate final function';

alter function pg_catalog.bool_alltrue(internal) owner to postgres;

create function pg_catalog.bool_anytrue(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bool_anytrue(internal) is 'aggregate final function';

alter function pg_catalog.bool_anytrue(internal) owner to postgres;

create function pg_catalog.anyenum_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyenum_in(cstring) is 'I/O';

alter function pg_catalog.anyenum_in(cstring) owner to postgres;

create function pg_catalog.anyenum_out(anyenum)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyenum_out(anyenum) is 'I/O';

alter function pg_catalog.anyenum_out(anyenum) owner to postgres;

create function pg_catalog.enum_in(cstring, oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_in(cstring, oid) is 'I/O';

alter function pg_catalog.enum_in(cstring, oid) owner to postgres;

create function pg_catalog.enum_out(anyenum)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_out(anyenum) is 'I/O';

alter function pg_catalog.enum_out(anyenum) owner to postgres;

create function pg_catalog.enum_eq(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_eq(anyenum, anyenum) is 'implementation of = operator';

alter function pg_catalog.enum_eq(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_ne(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_ne(anyenum, anyenum) is 'implementation of <> operator';

alter function pg_catalog.enum_ne(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_lt(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_lt(anyenum, anyenum) is 'implementation of < operator';

alter function pg_catalog.enum_lt(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_gt(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_gt(anyenum, anyenum) is 'implementation of > operator';

alter function pg_catalog.enum_gt(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_le(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_le(anyenum, anyenum) is 'implementation of <= operator';

alter function pg_catalog.enum_le(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_ge(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_ge(anyenum, anyenum) is 'implementation of >= operator';

alter function pg_catalog.enum_ge(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_cmp(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_cmp(anyenum, anyenum) is 'less-equal-greater';

alter function pg_catalog.enum_cmp(anyenum, anyenum) owner to postgres;

create function pg_catalog.hashenum(anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hashenum(anyenum) is 'hash';

alter function pg_catalog.hashenum(anyenum) owner to postgres;

create function pg_catalog.enum_smaller(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_smaller(anyenum, anyenum) is 'smaller of two';

alter function pg_catalog.enum_smaller(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_larger(anyenum, anyenum)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_larger(anyenum, anyenum) is 'larger of two';

alter function pg_catalog.enum_larger(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_first(anyenum)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_first(anyenum) is 'first value of the input enum type';

alter function pg_catalog.enum_first(anyenum) owner to postgres;

create function pg_catalog.enum_last(anyenum)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_last(anyenum) is 'last value of the input enum type';

alter function pg_catalog.enum_last(anyenum) owner to postgres;

create function pg_catalog.enum_range(anyenum, anyenum)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_range(anyenum, anyenum) is 'range between the two given enum values, as an ordered array';

alter function pg_catalog.enum_range(anyenum, anyenum) owner to postgres;

create function pg_catalog.enum_range(anyenum)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_range(anyenum) is 'range of the given enum type, as an ordered array';

alter function pg_catalog.enum_range(anyenum) owner to postgres;

create function pg_catalog.enum_recv(internal, oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_recv(internal, oid) is 'I/O';

alter function pg_catalog.enum_recv(internal, oid) owner to postgres;

create function pg_catalog.enum_send(anyenum)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.enum_send(anyenum) is 'I/O';

alter function pg_catalog.enum_send(anyenum) owner to postgres;

create function pg_catalog.string_agg_transfn(internal, text, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.string_agg_transfn(internal, text, text) is 'aggregate transition function';

alter function pg_catalog.string_agg_transfn(internal, text, text) owner to postgres;

create function pg_catalog.string_agg_finalfn(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.string_agg_finalfn(internal) is 'aggregate final function';

alter function pg_catalog.string_agg_finalfn(internal) owner to postgres;

create function pg_catalog.pg_describe_object(oid, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_describe_object(oid, oid, integer) is 'get identification of SQL object';

alter function pg_catalog.pg_describe_object(oid, oid, integer) owner to postgres;

create function pg_catalog.format(text, "any")
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.format(text, "any") is 'format text message';

alter function pg_catalog.format(text, "any") owner to postgres;

create function pg_catalog.format(text)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.format(text) is 'format text message';

alter function pg_catalog.format(text) owner to postgres;

create function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) is 'aggregate transition function';

alter function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) owner to postgres;

create function pg_catalog.bytea_string_agg_finalfn(internal)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bytea_string_agg_finalfn(internal) is 'aggregate final function';

alter function pg_catalog.bytea_string_agg_finalfn(internal) owner to postgres;

create function pg_catalog.int8dec(bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8dec(bigint) is 'decrement';

alter function pg_catalog.int8dec(bigint) owner to postgres;

create function pg_catalog.int8dec_any(bigint, "any")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8dec_any(bigint, "any") is 'decrement, ignores second argument';

alter function pg_catalog.int8dec_any(bigint, "any") owner to postgres;

create function pg_catalog.numeric_accum_inv(internal, numeric)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric_accum_inv(internal, numeric) is 'aggregate transition function';

alter function pg_catalog.numeric_accum_inv(internal, numeric) owner to postgres;

create function pg_catalog.interval_accum_inv(interval[], interval)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_accum_inv(interval[], interval) is 'aggregate transition function';

alter function pg_catalog.interval_accum_inv(interval[], interval) owner to postgres;

create function pg_catalog.network_overlap(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_overlap(inet, inet) is 'implementation of && operator';

alter function pg_catalog.network_overlap(inet, inet) owner to postgres;

create function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) owner to postgres;

create function pg_catalog.inet_gist_union(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_gist_union(internal, internal) is 'GiST support';

alter function pg_catalog.inet_gist_union(internal, internal) owner to postgres;

create function pg_catalog.inet_gist_compress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_gist_compress(internal) is 'GiST support';

alter function pg_catalog.inet_gist_compress(internal) owner to postgres;

create function pg_catalog.inet_gist_decompress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_gist_decompress(internal) is 'GiST support';

alter function pg_catalog.inet_gist_decompress(internal) owner to postgres;

create function pg_catalog.inet_gist_penalty(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_gist_penalty(internal, internal, internal) is 'GiST support';

alter function pg_catalog.inet_gist_penalty(internal, internal, internal) owner to postgres;

create function pg_catalog.inet_gist_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_gist_picksplit(internal, internal) is 'GiST support';

alter function pg_catalog.inet_gist_picksplit(internal, internal) owner to postgres;

create function pg_catalog.inet_gist_same(inet, inet, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_gist_same(inet, inet, internal) is 'GiST support';

alter function pg_catalog.inet_gist_same(inet, inet, internal) owner to postgres;

create function pg_catalog.networksel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.networksel(internal, oid, internal, integer) is 'restriction selectivity for network operators';

alter function pg_catalog.networksel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for network operators';

alter function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.network_larger(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_larger(inet, inet) is 'larger of two';

alter function pg_catalog.network_larger(inet, inet) owner to postgres;

create function pg_catalog.network_smaller(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.network_smaller(inet, inet) is 'smaller of two';

alter function pg_catalog.network_smaller(inet, inet) owner to postgres;

create function pg_catalog.pg_event_trigger_dropped_objects(out classid oid, out objid oid, out objsubid integer,
                                                            out original boolean, out normal boolean,
                                                            out is_temporary boolean, out object_type text,
                                                            out schema_name text, out object_name text,
                                                            out object_identity text, out address_names text[],
                                                            out address_args text[])
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_event_trigger_dropped_objects(out oid, out oid, out integer, out boolean, out boolean, out boolean, out text, out text, out text, out text, out text[], out text[]) is 'list objects dropped by the current command';

alter function pg_catalog.pg_event_trigger_dropped_objects(out oid, out oid, out integer, out boolean, out boolean, out boolean, out text, out text, out text, out text, out text[], out text[]) owner to postgres;

create function pg_catalog.int2_accum_inv(internal, smallint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2_accum_inv(internal, smallint) is 'aggregate transition function';

alter function pg_catalog.int2_accum_inv(internal, smallint) owner to postgres;

create function pg_catalog.int4_accum_inv(internal, integer)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4_accum_inv(internal, integer) is 'aggregate transition function';

alter function pg_catalog.int4_accum_inv(internal, integer) owner to postgres;

create function pg_catalog.int8_accum_inv(internal, bigint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8_accum_inv(internal, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_accum_inv(internal, bigint) owner to postgres;

create function pg_catalog.int2_avg_accum_inv(bigint[], smallint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2_avg_accum_inv(bigint[], smallint) is 'aggregate transition function';

alter function pg_catalog.int2_avg_accum_inv(bigint[], smallint) owner to postgres;

create function pg_catalog.int4_avg_accum_inv(bigint[], integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4_avg_accum_inv(bigint[], integer) is 'aggregate transition function';

alter function pg_catalog.int4_avg_accum_inv(bigint[], integer) owner to postgres;

create function pg_catalog.int2int4_sum(bigint[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int2int4_sum(bigint[]) is 'aggregate final function';

alter function pg_catalog.int2int4_sum(bigint[]) owner to postgres;

create function pg_catalog.inet_gist_fetch(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_gist_fetch(internal) is 'GiST support';

alter function pg_catalog.inet_gist_fetch(internal) owner to postgres;

create function pg_catalog.pg_logical_emit_message(boolean, text, text)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, text) is 'emit a textual logical decoding message';

alter function pg_catalog.pg_logical_emit_message(boolean, text, text) owner to postgres;

create function pg_catalog.pg_logical_emit_message(boolean, text, bytea)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, bytea) is 'emit a binary logical decoding message';

alter function pg_catalog.pg_logical_emit_message(boolean, text, bytea) owner to postgres;

create function pg_catalog.jsonb_insert(jsonb_in jsonb, path text[], replacement jsonb,
                                        insert_after boolean default false)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_insert(jsonb, text[], jsonb, boolean) is 'Insert value into a jsonb';

alter function pg_catalog.jsonb_insert(jsonb, text[], jsonb, boolean) owner to postgres;

create function pg_catalog.pg_xact_commit_timestamp(xid)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_xact_commit_timestamp(xid) is 'get commit timestamp of a transaction';

alter function pg_catalog.pg_xact_commit_timestamp(xid) owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid) owner to postgres;

create function pg_catalog.pg_last_committed_xact(out xid xid, out timestamp timestamp with time zone)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_last_committed_xact(out xid, out timestamp with time zone) is 'get transaction Id and commit timestamp of latest transaction commit';

alter function pg_catalog.pg_last_committed_xact(out xid, out timestamp with time zone) owner to postgres;

create function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid) owner to postgres;

create function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_toast_pg_type_oid(oid) owner to postgres;

create function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid) owner to postgres;

create function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid) owner to postgres;

create function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid) owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid) owner to postgres;

create function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid) owner to postgres;

create function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[])
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[]) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[]) owner to postgres;

create function pg_catalog.event_trigger_in(cstring)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.event_trigger_in(cstring) is 'I/O';

alter function pg_catalog.event_trigger_in(cstring) owner to postgres;

create function pg_catalog.event_trigger_out(event_trigger)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.event_trigger_out(event_trigger) is 'I/O';

alter function pg_catalog.event_trigger_out(event_trigger) owner to postgres;

create function pg_catalog.tsvectorin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvectorin(cstring) is 'I/O';

alter function pg_catalog.tsvectorin(cstring) owner to postgres;

create function pg_catalog.tsvectorout(tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvectorout(tsvector) is 'I/O';

alter function pg_catalog.tsvectorout(tsvector) owner to postgres;

create function pg_catalog.tsqueryin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsqueryin(cstring) is 'I/O';

alter function pg_catalog.tsqueryin(cstring) owner to postgres;

create function pg_catalog.tsqueryout(tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsqueryout(tsquery) is 'I/O';

alter function pg_catalog.tsqueryout(tsquery) owner to postgres;

create function pg_catalog.tsvector_lt(tsvector, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_lt(tsvector, tsvector) is 'implementation of < operator';

alter function pg_catalog.tsvector_lt(tsvector, tsvector) owner to postgres;

create function pg_catalog.tsvector_le(tsvector, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_le(tsvector, tsvector) is 'implementation of <= operator';

alter function pg_catalog.tsvector_le(tsvector, tsvector) owner to postgres;

create function pg_catalog.tsvector_eq(tsvector, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_eq(tsvector, tsvector) is 'implementation of = operator';

alter function pg_catalog.tsvector_eq(tsvector, tsvector) owner to postgres;

create function pg_catalog.tsvector_ne(tsvector, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_ne(tsvector, tsvector) is 'implementation of <> operator';

alter function pg_catalog.tsvector_ne(tsvector, tsvector) owner to postgres;

create function pg_catalog.tsvector_ge(tsvector, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_ge(tsvector, tsvector) is 'implementation of >= operator';

alter function pg_catalog.tsvector_ge(tsvector, tsvector) owner to postgres;

create function pg_catalog.tsvector_gt(tsvector, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_gt(tsvector, tsvector) is 'implementation of > operator';

alter function pg_catalog.tsvector_gt(tsvector, tsvector) owner to postgres;

create function pg_catalog.tsvector_cmp(tsvector, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_cmp(tsvector, tsvector) is 'less-equal-greater';

alter function pg_catalog.tsvector_cmp(tsvector, tsvector) owner to postgres;

create function pg_catalog.strip(tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.strip(tsvector) is 'strip position information';

alter function pg_catalog.strip(tsvector) owner to postgres;

create function pg_catalog.setweight(tsvector, "char")
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.setweight(tsvector, "char") is 'set given weight for whole tsvector';

alter function pg_catalog.setweight(tsvector, "char") owner to postgres;

create function pg_catalog.tsvector_concat(tsvector, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_concat(tsvector, tsvector) is 'implementation of || operator';

alter function pg_catalog.tsvector_concat(tsvector, tsvector) owner to postgres;

create function pg_catalog.ts_match_vq(tsvector, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_match_vq(tsvector, tsquery) is 'implementation of @@ operator';

alter function pg_catalog.ts_match_vq(tsvector, tsquery) owner to postgres;

create function pg_catalog.ts_match_qv(tsquery, tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_match_qv(tsquery, tsvector) is 'implementation of @@ operator';

alter function pg_catalog.ts_match_qv(tsquery, tsvector) owner to postgres;

create function pg_catalog.tsvectorsend(tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvectorsend(tsvector) is 'I/O';

alter function pg_catalog.tsvectorsend(tsvector) owner to postgres;

create function pg_catalog.tsvectorrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvectorrecv(internal) is 'I/O';

alter function pg_catalog.tsvectorrecv(internal) owner to postgres;

create function pg_catalog.tsquerysend(tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquerysend(tsquery) is 'I/O';

alter function pg_catalog.tsquerysend(tsquery) owner to postgres;

create function pg_catalog.tsqueryrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsqueryrecv(internal) is 'I/O';

alter function pg_catalog.tsqueryrecv(internal) owner to postgres;

create function pg_catalog.gtsvectorin(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvectorin(cstring) is 'I/O';

alter function pg_catalog.gtsvectorin(cstring) owner to postgres;

create function pg_catalog.gtsvectorout(gtsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvectorout(gtsvector) is 'I/O';

alter function pg_catalog.gtsvectorout(gtsvector) owner to postgres;

create function pg_catalog.gtsvector_compress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvector_compress(internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_compress(internal) owner to postgres;

create function pg_catalog.gtsvector_decompress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvector_decompress(internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_decompress(internal) owner to postgres;

create function pg_catalog.gtsvector_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvector_picksplit(internal, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_picksplit(internal, internal) owner to postgres;

create function pg_catalog.gtsvector_union(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvector_union(internal, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_union(internal, internal) owner to postgres;

create function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) owner to postgres;

create function pg_catalog.gtsvector_penalty(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvector_penalty(internal, internal, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_penalty(internal, internal, internal) owner to postgres;

create function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal) owner to postgres;

create function pg_catalog.gin_extract_tsvector(tsvector, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_extract_tsvector(tsvector, internal, internal) owner to postgres;

create function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal,
                                                  internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.tsquery_lt(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_lt(tsquery, tsquery) is 'implementation of < operator';

alter function pg_catalog.tsquery_lt(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_le(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_le(tsquery, tsquery) is 'implementation of <= operator';

alter function pg_catalog.tsquery_le(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_eq(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_eq(tsquery, tsquery) is 'implementation of = operator';

alter function pg_catalog.tsquery_eq(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_ne(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_ne(tsquery, tsquery) is 'implementation of <> operator';

alter function pg_catalog.tsquery_ne(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_ge(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_ge(tsquery, tsquery) is 'implementation of >= operator';

alter function pg_catalog.tsquery_ge(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_gt(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_gt(tsquery, tsquery) is 'implementation of > operator';

alter function pg_catalog.tsquery_gt(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_cmp(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_cmp(tsquery, tsquery) is 'less-equal-greater';

alter function pg_catalog.tsquery_cmp(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_and(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_and(tsquery, tsquery) is 'implementation of && operator';

alter function pg_catalog.tsquery_and(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_or(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_or(tsquery, tsquery) is 'implementation of || operator';

alter function pg_catalog.tsquery_or(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_not(tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_not(tsquery) is 'implementation of !! operator';

alter function pg_catalog.tsquery_not(tsquery) owner to postgres;

create function pg_catalog.numnode(tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numnode(tsquery) is 'number of nodes';

alter function pg_catalog.numnode(tsquery) owner to postgres;

create function pg_catalog.querytree(tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.querytree(tsquery) is 'show real useful query for GiST index';

alter function pg_catalog.querytree(tsquery) owner to postgres;

create function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery) is 'rewrite tsquery';

alter function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery) owner to postgres;

create function pg_catalog.ts_rewrite(tsquery, text)
    strict
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rewrite(tsquery, text) is 'rewrite tsquery';

alter function pg_catalog.ts_rewrite(tsquery, text) owner to postgres;

create function pg_catalog.tsmatchsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsmatchsel(internal, oid, internal, integer) is 'restriction selectivity of tsvector @@ tsquery';

alter function pg_catalog.tsmatchsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of tsvector @@ tsquery';

alter function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.ts_typanalyze(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_typanalyze(internal) is 'tsvector typanalyze';

alter function pg_catalog.ts_typanalyze(internal) owner to postgres;

create function pg_catalog.ts_stat(query text, out word text, out ndoc integer, out nentry integer)
    strict
    cost 10
    rows 10000
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_stat(text, out text, out integer, out integer) is 'statistics of tsvector column';

alter function pg_catalog.ts_stat(text, out text, out integer, out integer) owner to postgres;

create function pg_catalog.ts_stat(query text, weights text, out word text, out ndoc integer, out nentry integer)
    strict
    cost 10
    rows 10000
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_stat(text, text, out text, out integer, out integer) is 'statistics of tsvector column';

alter function pg_catalog.ts_stat(text, text, out text, out integer, out integer) owner to postgres;

create function pg_catalog.tsq_mcontains(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsq_mcontains(tsquery, tsquery) is 'implementation of @> operator';

alter function pg_catalog.tsq_mcontains(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsq_mcontained(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsq_mcontained(tsquery, tsquery) is 'implementation of <@ operator';

alter function pg_catalog.tsq_mcontained(tsquery, tsquery) owner to postgres;

create function pg_catalog.gtsquery_compress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsquery_compress(internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_compress(internal) owner to postgres;

create function pg_catalog.gtsquery_decompress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsquery_decompress(internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_decompress(internal) owner to postgres;

create function pg_catalog.gtsquery_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsquery_picksplit(internal, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_picksplit(internal, internal) owner to postgres;

create function pg_catalog.gtsquery_union(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsquery_union(internal, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_union(internal, internal) owner to postgres;

create function pg_catalog.gtsquery_same(bigint, bigint, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsquery_same(bigint, bigint, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_same(bigint, bigint, internal) owner to postgres;

create function pg_catalog.gtsquery_penalty(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsquery_penalty(internal, internal, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_penalty(internal, internal, internal) owner to postgres;

create function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal) owner to postgres;

create function pg_catalog.ts_rank(real[], tsvector, tsquery, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rank(real[], tsvector, tsquery, integer) is 'relevance';

alter function pg_catalog.ts_rank(real[], tsvector, tsquery, integer) owner to postgres;

create function pg_catalog.ts_rank(real[], tsvector, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rank(real[], tsvector, tsquery) is 'relevance';

alter function pg_catalog.ts_rank(real[], tsvector, tsquery) owner to postgres;

create function pg_catalog.ts_rank(tsvector, tsquery, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rank(tsvector, tsquery, integer) is 'relevance';

alter function pg_catalog.ts_rank(tsvector, tsquery, integer) owner to postgres;

create function pg_catalog.ts_rank(tsvector, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rank(tsvector, tsquery) is 'relevance';

alter function pg_catalog.ts_rank(tsvector, tsquery) owner to postgres;

create function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, integer) is 'relevance';

alter function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, integer) owner to postgres;

create function pg_catalog.ts_rank_cd(real[], tsvector, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rank_cd(real[], tsvector, tsquery) is 'relevance';

alter function pg_catalog.ts_rank_cd(real[], tsvector, tsquery) owner to postgres;

create function pg_catalog.ts_rank_cd(tsvector, tsquery, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery, integer) is 'relevance';

alter function pg_catalog.ts_rank_cd(tsvector, tsquery, integer) owner to postgres;

create function pg_catalog.ts_rank_cd(tsvector, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery) is 'relevance';

alter function pg_catalog.ts_rank_cd(tsvector, tsquery) owner to postgres;

create function pg_catalog.length(tsvector)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.length(tsvector) is 'number of lexemes';

alter function pg_catalog.length(tsvector) owner to postgres;

create function pg_catalog.ts_token_type(parser_oid oid, out tokid integer, out alias text, out description text)
    immutable
    strict
    parallel safe
    cost 1
    rows 16
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_token_type(oid, out integer, out text, out text) is 'get parser''s token types';

alter function pg_catalog.ts_token_type(oid, out integer, out text, out text) owner to postgres;

create function pg_catalog.ts_token_type(parser_name text, out tokid integer, out alias text, out description text)
    stable
    strict
    parallel safe
    cost 1
    rows 16
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_token_type(text, out integer, out text, out text) is 'get parser''s token types';

alter function pg_catalog.ts_token_type(text, out integer, out text, out text) owner to postgres;

create function pg_catalog.ts_parse(parser_oid oid, txt text, out tokid integer, out token text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_parse(oid, text, out integer, out text) is 'parse text to tokens';

alter function pg_catalog.ts_parse(oid, text, out integer, out text) owner to postgres;

create function pg_catalog.ts_parse(parser_name text, txt text, out tokid integer, out token text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_parse(text, text, out integer, out text) is 'parse text to tokens';

alter function pg_catalog.ts_parse(text, text, out integer, out text) owner to postgres;

create function pg_catalog.prsd_start(internal, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.prsd_start(internal, integer) is '(internal)';

alter function pg_catalog.prsd_start(internal, integer) owner to postgres;

create function pg_catalog.prsd_nexttoken(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.prsd_nexttoken(internal, internal, internal) is '(internal)';

alter function pg_catalog.prsd_nexttoken(internal, internal, internal) owner to postgres;

create function pg_catalog.prsd_end(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.prsd_end(internal) is '(internal)';

alter function pg_catalog.prsd_end(internal) owner to postgres;

create function pg_catalog.prsd_headline(internal, internal, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.prsd_headline(internal, internal, tsquery) is '(internal)';

alter function pg_catalog.prsd_headline(internal, internal, tsquery) owner to postgres;

create function pg_catalog.prsd_lextype(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.prsd_lextype(internal) is '(internal)';

alter function pg_catalog.prsd_lextype(internal) owner to postgres;

create function pg_catalog.ts_lexize(regdictionary, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_lexize(regdictionary, text) is 'normalize one word by dictionary';

alter function pg_catalog.ts_lexize(regdictionary, text) owner to postgres;

create function pg_catalog.gin_cmp_tslexeme(text, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_cmp_tslexeme(text, text) is 'GIN tsvector support';

alter function pg_catalog.gin_cmp_tslexeme(text, text) owner to postgres;

create function pg_catalog.dsimple_init(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dsimple_init(internal) is '(internal)';

alter function pg_catalog.dsimple_init(internal) owner to postgres;

create function pg_catalog.dsimple_lexize(internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dsimple_lexize(internal, internal, internal, internal) is '(internal)';

alter function pg_catalog.dsimple_lexize(internal, internal, internal, internal) owner to postgres;

create function pg_catalog.dsynonym_init(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dsynonym_init(internal) is '(internal)';

alter function pg_catalog.dsynonym_init(internal) owner to postgres;

create function pg_catalog.dsynonym_lexize(internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dsynonym_lexize(internal, internal, internal, internal) is '(internal)';

alter function pg_catalog.dsynonym_lexize(internal, internal, internal, internal) owner to postgres;

create function pg_catalog.dispell_init(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dispell_init(internal) is '(internal)';

alter function pg_catalog.dispell_init(internal) owner to postgres;

create function pg_catalog.dispell_lexize(internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dispell_lexize(internal, internal, internal, internal) is '(internal)';

alter function pg_catalog.dispell_lexize(internal, internal, internal, internal) owner to postgres;

create function pg_catalog.regconfigin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regconfigin(cstring) is 'I/O';

alter function pg_catalog.regconfigin(cstring) owner to postgres;

create function pg_catalog.regconfigout(regconfig)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regconfigout(regconfig) is 'I/O';

alter function pg_catalog.regconfigout(regconfig) owner to postgres;

create function pg_catalog.regconfigrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regconfigrecv(internal) is 'I/O';

alter function pg_catalog.regconfigrecv(internal) owner to postgres;

create function pg_catalog.regconfigsend(regconfig)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regconfigsend(regconfig) is 'I/O';

alter function pg_catalog.regconfigsend(regconfig) owner to postgres;

create function pg_catalog.thesaurus_init(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.thesaurus_init(internal) is '(internal)';

alter function pg_catalog.thesaurus_init(internal) owner to postgres;

create function pg_catalog.thesaurus_lexize(internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.thesaurus_lexize(internal, internal, internal, internal) is '(internal)';

alter function pg_catalog.thesaurus_lexize(internal, internal, internal, internal) owner to postgres;

create function pg_catalog.ts_headline(regconfig, text, tsquery, text)
    immutable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery, text) is 'generate headline';

alter function pg_catalog.ts_headline(regconfig, text, tsquery, text) owner to postgres;

create function pg_catalog.ts_headline(regconfig, text, tsquery)
    immutable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery) is 'generate headline';

alter function pg_catalog.ts_headline(regconfig, text, tsquery) owner to postgres;

create function pg_catalog.to_tsvector(regconfig, text)
    immutable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.to_tsvector(regconfig, text) is 'transform to tsvector';

alter function pg_catalog.to_tsvector(regconfig, text) owner to postgres;

create function pg_catalog.to_tsquery(regconfig, text)
    immutable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.to_tsquery(regconfig, text) is 'make tsquery';

alter function pg_catalog.to_tsquery(regconfig, text) owner to postgres;

create function pg_catalog.plainto_tsquery(regconfig, text)
    immutable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.plainto_tsquery(regconfig, text) is 'transform to tsquery';

alter function pg_catalog.plainto_tsquery(regconfig, text) owner to postgres;

create function pg_catalog.to_tsvector(text)
    stable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.to_tsvector(text) is 'transform to tsvector';

alter function pg_catalog.to_tsvector(text) owner to postgres;

create function pg_catalog.to_tsquery(text)
    stable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.to_tsquery(text) is 'make tsquery';

alter function pg_catalog.to_tsquery(text) owner to postgres;

create function pg_catalog.plainto_tsquery(text)
    stable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.plainto_tsquery(text) is 'transform to tsquery';

alter function pg_catalog.plainto_tsquery(text) owner to postgres;

create function pg_catalog.tsvector_update_trigger()
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_update_trigger() is 'trigger for automatic update of tsvector column';

alter function pg_catalog.tsvector_update_trigger() owner to postgres;

create function pg_catalog.tsvector_update_trigger_column()
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsvector_update_trigger_column() is 'trigger for automatic update of tsvector column';

alter function pg_catalog.tsvector_update_trigger_column() owner to postgres;

create function pg_catalog.ts_headline(text, tsquery, text)
    stable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_headline(text, tsquery, text) is 'generate headline';

alter function pg_catalog.ts_headline(text, tsquery, text) owner to postgres;

create function pg_catalog.ts_headline(text, tsquery)
    stable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_headline(text, tsquery) is 'generate headline';

alter function pg_catalog.ts_headline(text, tsquery) owner to postgres;

create function pg_catalog.pg_ts_parser_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ts_parser_is_visible(oid) is 'is text search parser visible in search path?';

alter function pg_catalog.pg_ts_parser_is_visible(oid) owner to postgres;

create function pg_catalog.pg_ts_dict_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ts_dict_is_visible(oid) is 'is text search dictionary visible in search path?';

alter function pg_catalog.pg_ts_dict_is_visible(oid) owner to postgres;

create function pg_catalog.pg_ts_config_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ts_config_is_visible(oid) is 'is text search configuration visible in search path?';

alter function pg_catalog.pg_ts_config_is_visible(oid) owner to postgres;

create function pg_catalog.get_current_ts_config()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.get_current_ts_config() is 'get current tsearch configuration';

alter function pg_catalog.get_current_ts_config() owner to postgres;

create function pg_catalog.ts_match_tt(text, text)
    stable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_match_tt(text, text) is 'implementation of @@ operator';

alter function pg_catalog.ts_match_tt(text, text) owner to postgres;

create function pg_catalog.ts_match_tq(text, tsquery)
    stable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.ts_match_tq(text, tsquery) is 'implementation of @@ operator';

alter function pg_catalog.ts_match_tq(text, tsquery) owner to postgres;

create function pg_catalog.pg_ts_template_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_ts_template_is_visible(oid) is 'is text search template visible in search path?';

alter function pg_catalog.pg_ts_template_is_visible(oid) owner to postgres;

create function pg_catalog.regdictionaryin(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regdictionaryin(cstring) is 'I/O';

alter function pg_catalog.regdictionaryin(cstring) owner to postgres;

create function pg_catalog.regdictionaryout(regdictionary)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regdictionaryout(regdictionary) is 'I/O';

alter function pg_catalog.regdictionaryout(regdictionary) owner to postgres;

create function pg_catalog.regdictionaryrecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regdictionaryrecv(internal) is 'I/O';

alter function pg_catalog.regdictionaryrecv(internal) owner to postgres;

create function pg_catalog.regdictionarysend(regdictionary)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regdictionarysend(regdictionary) is 'I/O';

alter function pg_catalog.regdictionarysend(regdictionary) owner to postgres;

create function pg_catalog.pg_stat_reset_shared(text)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_reset_shared(text) is 'statistics: reset collected statistics shared across the cluster';

alter function pg_catalog.pg_stat_reset_shared(text) owner to postgres;

create function pg_catalog.pg_stat_reset_single_table_counters(oid)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_reset_single_table_counters(oid) is 'statistics: reset collected statistics for a single table or index in the current database';

alter function pg_catalog.pg_stat_reset_single_table_counters(oid) owner to postgres;

create function pg_catalog.pg_stat_reset_single_function_counters(oid)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_reset_single_function_counters(oid) is 'statistics: reset collected statistics for a single function in the current database';

alter function pg_catalog.pg_stat_reset_single_function_counters(oid) owner to postgres;

create function pg_catalog.pg_tablespace_location(oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_tablespace_location(oid) is 'tablespace location';

alter function pg_catalog.pg_tablespace_location(oid) owner to postgres;

create function pg_catalog.pg_create_physical_replication_slot(slot_name name,
                                                               immediately_reserve boolean default false,
                                                               out slot_name name, out xlog_position pg_lsn)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_create_physical_replication_slot(name, boolean, out name, out pg_lsn) is 'create a physical replication slot';

alter function pg_catalog.pg_create_physical_replication_slot(name, boolean, out name, out pg_lsn) owner to postgres;

create function pg_catalog.pg_drop_replication_slot(name)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_drop_replication_slot(name) is 'drop a replication slot';

alter function pg_catalog.pg_drop_replication_slot(name) owner to postgres;

create function pg_catalog.pg_get_replication_slots(out slot_name name, out plugin name, out slot_type text,
                                                    out datoid oid, out active boolean, out active_pid integer,
                                                    out xmin xid, out catalog_xmin xid, out restart_lsn pg_lsn,
                                                    out confirmed_flush_lsn pg_lsn)
    stable
    parallel safe
    cost 1
    rows 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_replication_slots(out name, out name, out text, out oid, out boolean, out integer, out xid, out xid, out pg_lsn, out pg_lsn) is 'information about replication slots currently in use';

alter function pg_catalog.pg_get_replication_slots(out name, out name, out text, out oid, out boolean, out integer, out xid, out xid, out pg_lsn, out pg_lsn) owner to postgres;

create function pg_catalog.pg_logical_slot_get_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer,
                                                       options text[] default '{}'::text[], out location pg_lsn,
                                                       out xid xid, out data text)
    cost 1000
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) is 'get changes from replication slot';

alter function pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) owner to postgres;

create function pg_catalog.pg_logical_slot_get_binary_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer,
                                                              options text[] default '{}'::text[], out location pg_lsn,
                                                              out xid xid, out data bytea)
    cost 1000
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) is 'get binary changes from replication slot';

alter function pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) owner to postgres;

create function pg_catalog.pg_logical_slot_peek_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer,
                                                        options text[] default '{}'::text[], out location pg_lsn,
                                                        out xid xid, out data text)
    cost 1000
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) is 'peek at changes from replication slot';

alter function pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) owner to postgres;

create function pg_catalog.pg_logical_slot_peek_binary_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer,
                                                               options text[] default '{}'::text[], out location pg_lsn,
                                                               out xid xid, out data bytea)
    cost 1000
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) is 'peek at binary changes from replication slot';

alter function pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) owner to postgres;

create function pg_catalog.pg_create_logical_replication_slot(slot_name name, plugin name, out slot_name text,
                                                              out xlog_position pg_lsn)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_create_logical_replication_slot(name, name, out text, out pg_lsn) is 'set up a logical replication slot';

alter function pg_catalog.pg_create_logical_replication_slot(name, name, out text, out pg_lsn) owner to postgres;

create function pg_catalog.to_jsonb(anyelement)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_jsonb(anyelement) is 'map input to jsonb';

alter function pg_catalog.to_jsonb(anyelement) owner to postgres;

create function pg_catalog.pg_stat_get_snapshot_timestamp()
    stable
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_stat_get_snapshot_timestamp() is 'statistics: timestamp of the current statistics snapshot';

alter function pg_catalog.pg_stat_get_snapshot_timestamp() owner to postgres;

create function pg_catalog.gin_clean_pending_list(regclass)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_clean_pending_list(regclass) is 'clean up GIN pending list';

alter function pg_catalog.gin_clean_pending_list(regclass) owner to postgres;

create function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal) is 'GiST tsvector support (obsolete)';

alter function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal) owner to postgres;

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal,
                                                  internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal) owner to postgres;

create function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal) is 'GiST tsquery support (obsolete)';

alter function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal) owner to postgres;

create function pg_catalog.jsonb_send(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_send(jsonb) is 'I/O';

alter function pg_catalog.jsonb_send(jsonb) owner to postgres;

create function pg_catalog.jsonb_out(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_out(jsonb) is 'I/O';

alter function pg_catalog.jsonb_out(jsonb) owner to postgres;

create function pg_catalog.jsonb_recv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_recv(internal) is 'I/O';

alter function pg_catalog.jsonb_recv(internal) owner to postgres;

create function pg_catalog.jsonb_in(cstring)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_in(cstring) is 'I/O';

alter function pg_catalog.jsonb_in(cstring) owner to postgres;

create function pg_catalog.pg_get_function_arg_default(oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_function_arg_default(oid, integer) is 'function argument default';

alter function pg_catalog.pg_get_function_arg_default(oid, integer) owner to postgres;

create function pg_catalog.pg_export_snapshot()
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_export_snapshot() is 'export a snapshot';

alter function pg_catalog.pg_export_snapshot() owner to postgres;

create function pg_catalog.pg_is_in_recovery()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_is_in_recovery() is 'true if server is in recovery';

alter function pg_catalog.pg_is_in_recovery() owner to postgres;

create function pg_catalog.money(integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.money(integer) is 'convert int4 to money';

alter function pg_catalog.money(integer) owner to postgres;

create function pg_catalog.money(bigint)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.money(bigint) is 'convert int8 to money';

alter function pg_catalog.money(bigint) owner to postgres;

create function pg_catalog.pg_is_in_backup()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_is_in_backup() is 'true if server is in online backup';

alter function pg_catalog.pg_is_in_backup() owner to postgres;

create function pg_catalog.pg_backup_start_time()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_backup_start_time() is 'start time of an online backup';

alter function pg_catalog.pg_backup_start_time() owner to postgres;

create function pg_catalog.pg_collation_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_collation_is_visible(oid) is 'is collation visible in search path?';

alter function pg_catalog.pg_collation_is_visible(oid) owner to postgres;

create function pg_catalog.array_typanalyze(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_typanalyze(internal) is 'array typanalyze';

alter function pg_catalog.array_typanalyze(internal) owner to postgres;

create function pg_catalog.arraycontsel(internal, oid, internal, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.arraycontsel(internal, oid, internal, integer) is 'restriction selectivity for array-containment operators';

alter function pg_catalog.arraycontsel(internal, oid, internal, integer) owner to postgres;

create function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for array-containment operators';

alter function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) owner to postgres;

create function pg_catalog.pg_get_multixact_members(multixid xid, out xid xid, out mode text)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_multixact_members(xid, out xid, out text) is 'view members of a multixactid';

alter function pg_catalog.pg_get_multixact_members(xid, out xid, out text) owner to postgres;

create function pg_catalog.pg_last_xlog_receive_location()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_last_xlog_receive_location() is 'current xlog flush location';

alter function pg_catalog.pg_last_xlog_receive_location() owner to postgres;

create function pg_catalog.pg_last_xlog_replay_location()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_last_xlog_replay_location() is 'last xlog replay location';

alter function pg_catalog.pg_last_xlog_replay_location() owner to postgres;

create function pg_catalog.cash_div_cash(money, money)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cash_div_cash(money, money) is 'implementation of / operator';

alter function pg_catalog.cash_div_cash(money, money) owner to postgres;

create function pg_catalog.numeric(money)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numeric(money) is 'convert money to numeric';

alter function pg_catalog.numeric(money) owner to postgres;

create function pg_catalog.money(numeric)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.money(numeric) is 'convert numeric to money';

alter function pg_catalog.money(numeric) owner to postgres;

create function pg_catalog.pg_read_file(text)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_read_file(text) is 'read text from a file';

alter function pg_catalog.pg_read_file(text) owner to postgres;

create function pg_catalog.pg_read_binary_file(text, bigint, bigint)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint) is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text, bigint, bigint) owner to postgres;

create function pg_catalog.pg_read_binary_file(text)
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_read_binary_file(text) is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text) owner to postgres;

create function pg_catalog.pg_opfamily_is_visible(oid)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_opfamily_is_visible(oid) is 'is opfamily visible in search path?';

alter function pg_catalog.pg_opfamily_is_visible(oid) owner to postgres;

create function pg_catalog.pg_last_xact_replay_timestamp()
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_last_xact_replay_timestamp() is 'timestamp of last replay xact';

alter function pg_catalog.pg_last_xact_replay_timestamp() owner to postgres;

create function pg_catalog.anyrange_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyrange_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.anyrange_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.anyrange_out(anyrange)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.anyrange_out(anyrange) is 'I/O';

alter function pg_catalog.anyrange_out(anyrange) owner to postgres;

create function pg_catalog.range_in(cstring, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.range_in(cstring, oid, integer) owner to postgres;

create function pg_catalog.range_out(anyrange)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_out(anyrange) is 'I/O';

alter function pg_catalog.range_out(anyrange) owner to postgres;

create function pg_catalog.range_recv(internal, oid, integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.range_recv(internal, oid, integer) owner to postgres;

create function pg_catalog.range_send(anyrange)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_send(anyrange) is 'I/O';

alter function pg_catalog.range_send(anyrange) owner to postgres;

create function pg_catalog.pg_identify_object(classid oid, objid oid, subobjid integer, out type text, out schema text,
                                              out name text, out identity text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_identify_object(oid, oid, integer, out text, out text, out text, out text) is 'get machine-parseable identification of SQL object';

alter function pg_catalog.pg_identify_object(oid, oid, integer, out text, out text, out text, out text) owner to postgres;

create function pg_catalog.int4range(integer, integer)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4range(integer, integer) is 'int4range constructor';

alter function pg_catalog.int4range(integer, integer) owner to postgres;

create function pg_catalog.int4range(integer, integer, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4range(integer, integer, text) is 'int4range constructor';

alter function pg_catalog.int4range(integer, integer, text) owner to postgres;

create function pg_catalog.pg_relation_is_updatable(regclass, boolean)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_relation_is_updatable(regclass, boolean) is 'is a relation insertable/updatable/deletable';

alter function pg_catalog.pg_relation_is_updatable(regclass, boolean) owner to postgres;

create function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean)
    stable
    strict
    parallel safe
    cost 10
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) is 'is a column updatable';

alter function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) owner to postgres;

create function pg_catalog.numrange(numeric, numeric)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numrange(numeric, numeric) is 'numrange constructor';

alter function pg_catalog.numrange(numeric, numeric) owner to postgres;

create function pg_catalog.numrange(numeric, numeric, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numrange(numeric, numeric, text) is 'numrange constructor';

alter function pg_catalog.numrange(numeric, numeric, text) owner to postgres;

create function pg_catalog.make_date(year integer, month integer, day integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.make_date(integer, integer, integer) is 'construct date';

alter function pg_catalog.make_date(integer, integer, integer) owner to postgres;

create function pg_catalog.make_time(hour integer, min integer, sec double precision)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.make_time(integer, integer, double precision) is 'construct time';

alter function pg_catalog.make_time(integer, integer, double precision) owner to postgres;

create function pg_catalog.lower(anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lower(anyrange) is 'lower bound of range';

alter function pg_catalog.lower(anyrange) owner to postgres;

create function pg_catalog.upper(anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.upper(anyrange) is 'upper bound of range';

alter function pg_catalog.upper(anyrange) owner to postgres;

create function pg_catalog.isempty(anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.isempty(anyrange) is 'is the range empty?';

alter function pg_catalog.isempty(anyrange) owner to postgres;

create function pg_catalog.lower_inc(anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lower_inc(anyrange) is 'is the range''s lower bound inclusive?';

alter function pg_catalog.lower_inc(anyrange) owner to postgres;

create function pg_catalog.upper_inc(anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.upper_inc(anyrange) is 'is the range''s upper bound inclusive?';

alter function pg_catalog.upper_inc(anyrange) owner to postgres;

create function pg_catalog.lower_inf(anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.lower_inf(anyrange) is 'is the range''s lower bound infinite?';

alter function pg_catalog.lower_inf(anyrange) owner to postgres;

create function pg_catalog.upper_inf(anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.upper_inf(anyrange) is 'is the range''s upper bound infinite?';

alter function pg_catalog.upper_inf(anyrange) owner to postgres;

create function pg_catalog.range_eq(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_eq(anyrange, anyrange) is 'implementation of = operator';

alter function pg_catalog.range_eq(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_ne(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_ne(anyrange, anyrange) is 'implementation of <> operator';

alter function pg_catalog.range_ne(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_overlaps(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_overlaps(anyrange, anyrange) is 'implementation of && operator';

alter function pg_catalog.range_overlaps(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_contains_elem(anyrange, anyelement)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_contains_elem(anyrange, anyelement) is 'implementation of @> operator';

alter function pg_catalog.range_contains_elem(anyrange, anyelement) owner to postgres;

create function pg_catalog.range_contains(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_contains(anyrange, anyrange) is 'implementation of @> operator';

alter function pg_catalog.range_contains(anyrange, anyrange) owner to postgres;

create function pg_catalog.elem_contained_by_range(anyelement, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.elem_contained_by_range(anyelement, anyrange) is 'implementation of <@ operator';

alter function pg_catalog.elem_contained_by_range(anyelement, anyrange) owner to postgres;

create function pg_catalog.range_contained_by(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_contained_by(anyrange, anyrange) is 'implementation of <@ operator';

alter function pg_catalog.range_contained_by(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_adjacent(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_adjacent(anyrange, anyrange) is 'implementation of -|- operator';

alter function pg_catalog.range_adjacent(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_before(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_before(anyrange, anyrange) is 'implementation of << operator';

alter function pg_catalog.range_before(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_after(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_after(anyrange, anyrange) is 'implementation of >> operator';

alter function pg_catalog.range_after(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_overleft(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_overleft(anyrange, anyrange) is 'implementation of &< operator';

alter function pg_catalog.range_overleft(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_overright(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_overright(anyrange, anyrange) is 'implementation of &> operator';

alter function pg_catalog.range_overright(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_union(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_union(anyrange, anyrange) is 'implementation of + operator';

alter function pg_catalog.range_union(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_intersect(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_intersect(anyrange, anyrange) is 'implementation of * operator';

alter function pg_catalog.range_intersect(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_minus(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_minus(anyrange, anyrange) is 'implementation of - operator';

alter function pg_catalog.range_minus(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_cmp(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_cmp(anyrange, anyrange) is 'less-equal-greater';

alter function pg_catalog.range_cmp(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_lt(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_lt(anyrange, anyrange) is 'implementation of < operator';

alter function pg_catalog.range_lt(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_le(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_le(anyrange, anyrange) is 'implementation of <= operator';

alter function pg_catalog.range_le(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_ge(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_ge(anyrange, anyrange) is 'implementation of >= operator';

alter function pg_catalog.range_ge(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_gt(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gt(anyrange, anyrange) is 'implementation of > operator';

alter function pg_catalog.range_gt(anyrange, anyrange) owner to postgres;

create function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) owner to postgres;

create function pg_catalog.range_gist_union(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gist_union(internal, internal) is 'GiST support';

alter function pg_catalog.range_gist_union(internal, internal) owner to postgres;

create function pg_catalog.range_gist_compress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gist_compress(internal) is 'GiST support';

alter function pg_catalog.range_gist_compress(internal) owner to postgres;

create function pg_catalog.range_gist_decompress(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gist_decompress(internal) is 'GiST support';

alter function pg_catalog.range_gist_decompress(internal) owner to postgres;

create function pg_catalog.range_gist_penalty(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gist_penalty(internal, internal, internal) is 'GiST support';

alter function pg_catalog.range_gist_penalty(internal, internal, internal) owner to postgres;

create function pg_catalog.range_gist_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gist_picksplit(internal, internal) is 'GiST support';

alter function pg_catalog.range_gist_picksplit(internal, internal) owner to postgres;

create function pg_catalog.range_gist_same(anyrange, anyrange, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gist_same(anyrange, anyrange, internal) is 'GiST support';

alter function pg_catalog.range_gist_same(anyrange, anyrange, internal) owner to postgres;

create function pg_catalog.hash_range(anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.hash_range(anyrange) is 'hash a range';

alter function pg_catalog.hash_range(anyrange) owner to postgres;

create function pg_catalog.int4range_canonical(int4range)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4range_canonical(int4range) is 'convert an int4 range to canonical form';

alter function pg_catalog.int4range_canonical(int4range) owner to postgres;

create function pg_catalog.daterange_canonical(daterange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.daterange_canonical(daterange) is 'convert a date range to canonical form';

alter function pg_catalog.daterange_canonical(daterange) owner to postgres;

create function pg_catalog.range_typanalyze(internal)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_typanalyze(internal) is 'range typanalyze';

alter function pg_catalog.range_typanalyze(internal) owner to postgres;

create function pg_catalog.timestamp_transform(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_transform(internal) is 'transform a timestamp length coercion';

alter function pg_catalog.timestamp_transform(internal) owner to postgres;

create function pg_catalog.interval_transform(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.interval_transform(internal) is 'transform an interval length coercion';

alter function pg_catalog.interval_transform(internal) owner to postgres;

create function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) is 'GIN array support';

alter function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) owner to postgres;

create function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) owner to postgres;

create function pg_catalog.int4range_subdiff(integer, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int4range_subdiff(integer, integer) is 'float8 difference of two int4 values';

alter function pg_catalog.int4range_subdiff(integer, integer) owner to postgres;

create function pg_catalog.int8range_subdiff(bigint, bigint)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8range_subdiff(bigint, bigint) is 'float8 difference of two int8 values';

alter function pg_catalog.int8range_subdiff(bigint, bigint) owner to postgres;

create function pg_catalog.numrange_subdiff(numeric, numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.numrange_subdiff(numeric, numeric) is 'float8 difference of two numeric values';

alter function pg_catalog.numrange_subdiff(numeric, numeric) owner to postgres;

create function pg_catalog.daterange_subdiff(date, date)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.daterange_subdiff(date, date) is 'float8 difference of two date values';

alter function pg_catalog.daterange_subdiff(date, date) owner to postgres;

create function pg_catalog.int8range_canonical(int8range)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8range_canonical(int8range) is 'convert an int8 range to canonical form';

alter function pg_catalog.int8range_canonical(int8range) owner to postgres;

create function pg_catalog.tsrange_subdiff(timestamp, timestamp)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsrange_subdiff(timestamp, timestamp) is 'float8 difference of two timestamp values';

alter function pg_catalog.tsrange_subdiff(timestamp, timestamp) owner to postgres;

create function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) is 'float8 difference of two timestamp with time zone values';

alter function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.jsonb_object_keys(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_object_keys(jsonb) is 'get jsonb object keys';

alter function pg_catalog.jsonb_object_keys(jsonb) owner to postgres;

create function pg_catalog.jsonb_each_text(from_json jsonb, out key text, out value text)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_each_text(jsonb, out text, out text) is 'key value pairs of a jsonb object';

alter function pg_catalog.jsonb_each_text(jsonb, out text, out text) owner to postgres;

create function pg_catalog.tsrange(timestamp, timestamp)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsrange(timestamp, timestamp) is 'tsrange constructor';

alter function pg_catalog.tsrange(timestamp, timestamp) owner to postgres;

create function pg_catalog.tsrange(timestamp, timestamp, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsrange(timestamp, timestamp, text) is 'tsrange constructor';

alter function pg_catalog.tsrange(timestamp, timestamp, text) owner to postgres;

create function pg_catalog.pg_sleep_for(interval) returns void
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.pg_sleep(
                   extract(epoch from pg_catalog.clock_timestamp() operator (pg_catalog.+) $1) operator (pg_catalog.-)
                   extract(epoch from pg_catalog.clock_timestamp()))
$$;

comment on function pg_catalog.pg_sleep_for(interval) is 'sleep for the specified interval';

alter function pg_catalog.pg_sleep_for(interval) owner to postgres;

create function pg_catalog.pg_sleep_until(timestamp with time zone) returns void
    strict
    parallel safe
    cost 1
    language sql
as
$$
select pg_catalog.pg_sleep(
                   extract(epoch from $1) operator (pg_catalog.-) extract(epoch from pg_catalog.clock_timestamp()))
$$;

comment on function pg_catalog.pg_sleep_until(timestamp with time zone) is 'sleep until the specified time';

alter function pg_catalog.pg_sleep_until(timestamp with time zone) owner to postgres;

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone) is 'tstzrange constructor';

alter function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone) owner to postgres;

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text) is 'tstzrange constructor';

alter function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text) owner to postgres;

create function pg_catalog.mxid_age(xid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.mxid_age(xid) is 'age of a multi-transaction ID, in multi-transactions before current multi-transaction';

alter function pg_catalog.mxid_age(xid) owner to postgres;

create function pg_catalog.jsonb_extract_path_text(from_json jsonb, path_elems text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_extract_path_text(jsonb, text[]) is 'get value from jsonb as text with path elements';

alter function pg_catalog.jsonb_extract_path_text(jsonb, text[]) owner to postgres;

create function pg_catalog.daterange(date, date)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.daterange(date, date) is 'daterange constructor';

alter function pg_catalog.daterange(date, date) owner to postgres;

create function pg_catalog.daterange(date, date, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.daterange(date, date, text) is 'daterange constructor';

alter function pg_catalog.daterange(date, date, text) owner to postgres;

create function pg_catalog.acldefault("char", oid)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.acldefault("char", oid) is 'TODO';

alter function pg_catalog.acldefault("char", oid) owner to postgres;

create function pg_catalog.time_transform(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.time_transform(internal) is 'transform a time length coercion';

alter function pg_catalog.time_transform(internal) owner to postgres;

create function pg_catalog.int8range(bigint, bigint)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8range(bigint, bigint) is 'int8range constructor';

alter function pg_catalog.int8range(bigint, bigint) owner to postgres;

create function pg_catalog.int8range(bigint, bigint, text)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.int8range(bigint, bigint, text) is 'int8range constructor';

alter function pg_catalog.int8range(bigint, bigint, text) owner to postgres;

create function pg_catalog.json_object_field(from_json json, field_name text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_object_field(json, text) is 'implementation of -> operator';

alter function pg_catalog.json_object_field(json, text) owner to postgres;

create function pg_catalog.json_object_field_text(from_json json, field_name text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_object_field_text(json, text) is 'implementation of ->> operator';

alter function pg_catalog.json_object_field_text(json, text) owner to postgres;

create function pg_catalog.json_array_element(from_json json, element_index integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_array_element(json, integer) is 'implementation of -> operator';

alter function pg_catalog.json_array_element(json, integer) owner to postgres;

create function pg_catalog.json_array_element_text(from_json json, element_index integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_array_element_text(json, integer) is 'implementation of ->> operator';

alter function pg_catalog.json_array_element_text(json, integer) owner to postgres;

create function pg_catalog.json_extract_path(from_json json, path_elems text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_extract_path(json, text[]) is 'get value from json with path elements';

alter function pg_catalog.json_extract_path(json, text[]) owner to postgres;

create function pg_catalog.brin_summarize_new_values(regclass)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_summarize_new_values(regclass) is 'brin: standalone scan new table pages';

alter function pg_catalog.brin_summarize_new_values(regclass) owner to postgres;

create function pg_catalog.json_extract_path_text(from_json json, path_elems text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_extract_path_text(json, text[]) is 'get value from json as text with path elements';

alter function pg_catalog.json_extract_path_text(json, text[]) owner to postgres;

create function pg_catalog.pg_get_object_address(type text, name text[], args text[], out classid oid, out objid oid,
                                                 out subobjid integer)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_get_object_address(text, text[], text[], out oid, out oid, out integer) is 'get OID-based object address from name/args arrays';

alter function pg_catalog.pg_get_object_address(text, text[], text[], out oid, out oid, out integer) owner to postgres;

create function pg_catalog.json_array_elements(from_json json, out value json)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.json_array_elements(json, out json) is 'key value pairs of a json object';

alter function pg_catalog.json_array_elements(json, out json) owner to postgres;

create function pg_catalog.json_array_length(json)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_array_length(json) is 'length of json array';

alter function pg_catalog.json_array_length(json) owner to postgres;

create function pg_catalog.json_object_keys(json)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.json_object_keys(json) is 'get json object keys';

alter function pg_catalog.json_object_keys(json) owner to postgres;

create function pg_catalog.json_each(from_json json, out key text, out value json)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.json_each(json, out text, out json) is 'key value pairs of a json object';

alter function pg_catalog.json_each(json, out text, out json) owner to postgres;

create function pg_catalog.json_each_text(from_json json, out key text, out value text)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.json_each_text(json, out text, out text) is 'key value pairs of a json object';

alter function pg_catalog.json_each_text(json, out text, out text) owner to postgres;

create function pg_catalog.json_populate_record(base anyelement, from_json json, use_json_as_text boolean default false)
    stable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_populate_record(anyelement, json, boolean) is 'get record fields from a json object';

alter function pg_catalog.json_populate_record(anyelement, json, boolean) owner to postgres;

create function pg_catalog.json_populate_recordset(base anyelement, from_json json,
                                                   use_json_as_text boolean default false)
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.json_populate_recordset(anyelement, json, boolean) is 'get set of records with fields from a json array of objects';

alter function pg_catalog.json_populate_recordset(anyelement, json, boolean) owner to postgres;

create function pg_catalog.json_typeof(json)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.json_typeof(json) is 'get the type of a json value';

alter function pg_catalog.json_typeof(json) owner to postgres;

create function pg_catalog.json_array_elements_text(from_json json, out value text)
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.json_array_elements_text(json, out text) is 'elements of json array';

alter function pg_catalog.json_array_elements_text(json, out text) owner to postgres;

create function pg_catalog.ordered_set_transition(internal, "any")
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ordered_set_transition(internal, "any") is 'aggregate transition function';

alter function pg_catalog.ordered_set_transition(internal, "any") owner to postgres;

create function pg_catalog.ordered_set_transition_multi(internal, "any")
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.ordered_set_transition_multi(internal, "any") is 'aggregate transition function';

alter function pg_catalog.ordered_set_transition_multi(internal, "any") owner to postgres;

create function pg_catalog.percentile_disc_final(internal, double precision, anyelement)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.percentile_disc_final(internal, double precision, anyelement) is 'aggregate final function';

alter function pg_catalog.percentile_disc_final(internal, double precision, anyelement) owner to postgres;

create function pg_catalog.percentile_cont_float8_final(internal, double precision)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.percentile_cont_float8_final(internal, double precision) is 'aggregate final function';

alter function pg_catalog.percentile_cont_float8_final(internal, double precision) owner to postgres;

create function pg_catalog.percentile_cont_interval_final(internal, double precision)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.percentile_cont_interval_final(internal, double precision) is 'aggregate final function';

alter function pg_catalog.percentile_cont_interval_final(internal, double precision) owner to postgres;

create function pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement) is 'aggregate final function';

alter function pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement) owner to postgres;

create function pg_catalog.percentile_cont_float8_multi_final(internal, double precision[])
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.percentile_cont_float8_multi_final(internal, double precision[]) is 'aggregate final function';

alter function pg_catalog.percentile_cont_float8_multi_final(internal, double precision[]) owner to postgres;

create function pg_catalog.percentile_cont_interval_multi_final(internal, double precision[])
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.percentile_cont_interval_multi_final(internal, double precision[]) is 'aggregate final function';

alter function pg_catalog.percentile_cont_interval_multi_final(internal, double precision[]) owner to postgres;

create function pg_catalog.mode_final(internal, anyelement)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.mode_final(internal, anyelement) is 'aggregate final function';

alter function pg_catalog.mode_final(internal, anyelement) owner to postgres;

create function pg_catalog.rank_final(internal, "any")
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.rank_final(internal, "any") is 'aggregate final function';

alter function pg_catalog.rank_final(internal, "any") owner to postgres;

create function pg_catalog.percent_rank_final(internal, "any")
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.percent_rank_final(internal, "any") is 'aggregate final function';

alter function pg_catalog.percent_rank_final(internal, "any") owner to postgres;

create function pg_catalog.cume_dist_final(internal, "any")
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.cume_dist_final(internal, "any") is 'aggregate final function';

alter function pg_catalog.cume_dist_final(internal, "any") owner to postgres;

create function pg_catalog.dense_rank_final(internal, "any")
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.dense_rank_final(internal, "any") is 'aggregate final function';

alter function pg_catalog.dense_rank_final(internal, "any") owner to postgres;

create function pg_catalog.timestamp_izone_transform(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_izone_transform(internal) is 'transform a time zone adjustment';

alter function pg_catalog.timestamp_izone_transform(internal) owner to postgres;

create function pg_catalog.timestamp_zone_transform(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.timestamp_zone_transform(internal) is 'transform a time zone adjustment';

alter function pg_catalog.timestamp_zone_transform(internal) owner to postgres;

create function pg_catalog.range_gist_fetch(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_gist_fetch(internal) is 'GiST support';

alter function pg_catalog.range_gist_fetch(internal) owner to postgres;

create function pg_catalog.spg_quad_config(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_quad_config(internal, internal) is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_config(internal, internal) owner to postgres;

create function pg_catalog.spg_quad_choose(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_quad_choose(internal, internal) is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_choose(internal, internal) owner to postgres;

create function pg_catalog.spg_quad_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_picksplit(internal, internal) owner to postgres;

create function pg_catalog.spg_quad_inner_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_inner_consistent(internal, internal) owner to postgres;

create function pg_catalog.spg_quad_leaf_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree and k-d tree over point';

alter function pg_catalog.spg_quad_leaf_consistent(internal, internal) owner to postgres;

create function pg_catalog.spg_kd_config(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_kd_config(internal, internal) is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_config(internal, internal) owner to postgres;

create function pg_catalog.spg_kd_choose(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_kd_choose(internal, internal) is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_choose(internal, internal) owner to postgres;

create function pg_catalog.spg_kd_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_kd_picksplit(internal, internal) is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_picksplit(internal, internal) owner to postgres;

create function pg_catalog.spg_kd_inner_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_kd_inner_consistent(internal, internal) is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_inner_consistent(internal, internal) owner to postgres;

create function pg_catalog.spg_text_config(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_text_config(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_config(internal, internal) owner to postgres;

create function pg_catalog.spg_text_choose(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_text_choose(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_choose(internal, internal) owner to postgres;

create function pg_catalog.spg_text_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_text_picksplit(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_picksplit(internal, internal) owner to postgres;

create function pg_catalog.spg_text_inner_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_text_inner_consistent(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_inner_consistent(internal, internal) owner to postgres;

create function pg_catalog.spg_text_leaf_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_text_leaf_consistent(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_leaf_consistent(internal, internal) owner to postgres;

create function pg_catalog.jsonb_ne(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_ne(jsonb, jsonb) is 'implementation of <> operator';

alter function pg_catalog.jsonb_ne(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_lt(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_lt(jsonb, jsonb) is 'implementation of < operator';

alter function pg_catalog.jsonb_lt(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_gt(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_gt(jsonb, jsonb) is 'implementation of > operator';

alter function pg_catalog.jsonb_gt(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_le(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_le(jsonb, jsonb) is 'implementation of <= operator';

alter function pg_catalog.jsonb_le(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_ge(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_ge(jsonb, jsonb) is 'implementation of >= operator';

alter function pg_catalog.jsonb_ge(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_eq(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_eq(jsonb, jsonb) is 'implementation of = operator';

alter function pg_catalog.jsonb_eq(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_cmp(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_cmp(jsonb, jsonb) is 'less-equal-greater';

alter function pg_catalog.jsonb_cmp(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_hash(jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_hash(jsonb) is 'hash';

alter function pg_catalog.jsonb_hash(jsonb) owner to postgres;

create function pg_catalog.jsonb_contains(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_contains(jsonb, jsonb) is 'implementation of @> operator';

alter function pg_catalog.jsonb_contains(jsonb, jsonb) owner to postgres;

create function pg_catalog.jsonb_exists(jsonb, text)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_exists(jsonb, text) is 'implementation of ? operator';

alter function pg_catalog.jsonb_exists(jsonb, text) owner to postgres;

create function pg_catalog.jsonb_exists_any(jsonb, text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_exists_any(jsonb, text[]) is 'implementation of ?| operator';

alter function pg_catalog.jsonb_exists_any(jsonb, text[]) owner to postgres;

create function pg_catalog.jsonb_exists_all(jsonb, text[])
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_exists_all(jsonb, text[]) is 'implementation of ?& operator';

alter function pg_catalog.jsonb_exists_all(jsonb, text[]) owner to postgres;

create function pg_catalog.jsonb_contained(jsonb, jsonb)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.jsonb_contained(jsonb, jsonb) is 'implementation of <@ operator';

alter function pg_catalog.jsonb_contained(jsonb, jsonb) owner to postgres;

create function pg_catalog.array_agg_array_transfn(internal, anyarray)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_agg_array_transfn(internal, anyarray) is 'aggregate transition function';

alter function pg_catalog.array_agg_array_transfn(internal, anyarray) owner to postgres;

create function pg_catalog.array_agg_array_finalfn(internal, anyarray)
    immutable
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.array_agg_array_finalfn(internal, anyarray) is 'aggregate final function';

alter function pg_catalog.array_agg_array_finalfn(internal, anyarray) owner to postgres;

create function pg_catalog.range_merge(anyrange, anyrange)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.range_merge(anyrange, anyrange) is 'the smallest range which includes both of the given ranges';

alter function pg_catalog.range_merge(anyrange, anyrange) owner to postgres;

create function pg_catalog.inet_merge(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_merge(inet, inet) is 'the smallest network which includes both of the given networks';

alter function pg_catalog.inet_merge(inet, inet) owner to postgres;

create function pg_catalog.bound_box(box, box)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.bound_box(box, box) is 'bounding box of two boxes';

alter function pg_catalog.bound_box(box, box) owner to postgres;

create function pg_catalog.inet_same_family(inet, inet)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.inet_same_family(inet, inet) is 'are the addresses from the same family?';

alter function pg_catalog.inet_same_family(inet, inet) owner to postgres;

create function pg_catalog.binary_upgrade_set_record_init_privs(boolean)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.binary_upgrade_set_record_init_privs(boolean) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_record_init_privs(boolean) owner to postgres;

create function pg_catalog.regnamespacein(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regnamespacein(cstring) is 'I/O';

alter function pg_catalog.regnamespacein(cstring) owner to postgres;

create function pg_catalog.regnamespaceout(regnamespace)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regnamespaceout(regnamespace) is 'I/O';

alter function pg_catalog.regnamespaceout(regnamespace) owner to postgres;

create function pg_catalog.to_regnamespace(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_regnamespace(text) is 'convert namespace name to regnamespace';

alter function pg_catalog.to_regnamespace(text) owner to postgres;

create function pg_catalog.regnamespacerecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regnamespacerecv(internal) is 'I/O';

alter function pg_catalog.regnamespacerecv(internal) owner to postgres;

create function pg_catalog.regnamespacesend(regnamespace)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regnamespacesend(regnamespace) is 'I/O';

alter function pg_catalog.regnamespacesend(regnamespace) owner to postgres;

create function pg_catalog.box(point)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.box(point) is 'convert point to empty box';

alter function pg_catalog.box(point) owner to postgres;

create function pg_catalog.regroleout(regrole)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regroleout(regrole) is 'I/O';

alter function pg_catalog.regroleout(regrole) owner to postgres;

create function pg_catalog.to_regrole(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.to_regrole(text) is 'convert role name to regrole';

alter function pg_catalog.to_regrole(text) owner to postgres;

create function pg_catalog.regrolerecv(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regrolerecv(internal) is 'I/O';

alter function pg_catalog.regrolerecv(internal) owner to postgres;

create function pg_catalog.regrolesend(regrole)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regrolesend(regrole) is 'I/O';

alter function pg_catalog.regrolesend(regrole) owner to postgres;

create function pg_catalog.regrolein(cstring)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.regrolein(cstring) is 'I/O';

alter function pg_catalog.regrolein(cstring) owner to postgres;

create function pg_catalog.brin_inclusion_opcinfo(internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_inclusion_opcinfo(internal) is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_opcinfo(internal) owner to postgres;

create function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) owner to postgres;

create function pg_catalog.brin_inclusion_consistent(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_inclusion_consistent(internal, internal, internal) is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_consistent(internal, internal, internal) owner to postgres;

create function pg_catalog.brin_inclusion_union(internal, internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.brin_inclusion_union(internal, internal, internal) is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_union(internal, internal, internal) owner to postgres;

create function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid oid)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid) is 'return Oid of the table getting rewritten';

alter function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid) owner to postgres;

create function pg_catalog.pg_event_trigger_table_rewrite_reason()
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_event_trigger_table_rewrite_reason() is 'return reason code for table getting rewritten';

alter function pg_catalog.pg_event_trigger_table_rewrite_reason() owner to postgres;

create function pg_catalog.pg_event_trigger_ddl_commands(out classid oid, out objid oid, out objsubid integer,
                                                         out command_tag text, out object_type text,
                                                         out schema_name text, out object_identity text,
                                                         out in_extension boolean, out command pg_ddl_command)
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_event_trigger_ddl_commands(out oid, out oid, out integer, out text, out text, out text, out text, out boolean, out pg_ddl_command) is 'list DDL actions being executed by the current command';

alter function pg_catalog.pg_event_trigger_ddl_commands(out oid, out oid, out integer, out text, out text, out text, out text, out boolean, out pg_ddl_command) owner to postgres;

create function pg_catalog.phraseto_tsquery(text)
    stable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.phraseto_tsquery(text) is 'transform to tsquery';

alter function pg_catalog.phraseto_tsquery(text) owner to postgres;

create function pg_catalog.tsquery_phrase(tsquery, tsquery)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery) is 'implementation of <-> operator';

alter function pg_catalog.tsquery_phrase(tsquery, tsquery) owner to postgres;

create function pg_catalog.tsquery_phrase(tsquery, tsquery, integer)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery, integer) is 'phrase-concatenate with distance';

alter function pg_catalog.tsquery_phrase(tsquery, tsquery, integer) owner to postgres;

create function pg_catalog.phraseto_tsquery(regconfig, text)
    immutable
    strict
    parallel safe
    language internal
as -- missing source code
;

comment on function pg_catalog.phraseto_tsquery(regconfig, text) is 'transform to tsquery';

alter function pg_catalog.phraseto_tsquery(regconfig, text) owner to postgres;

create function pg_catalog.spg_box_quad_config(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_box_quad_config(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_config(internal, internal) owner to postgres;

create function pg_catalog.spg_box_quad_choose(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_box_quad_choose(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_choose(internal, internal) owner to postgres;

create function pg_catalog.spg_box_quad_picksplit(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_box_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_picksplit(internal, internal) owner to postgres;

create function pg_catalog.spg_box_quad_inner_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_box_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_inner_consistent(internal, internal) owner to postgres;

create function pg_catalog.spg_box_quad_leaf_consistent(internal, internal)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.spg_box_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_leaf_consistent(internal, internal) owner to postgres;

create function pg_catalog.pg_replication_origin_create(text)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_create(text) is 'create a replication origin';

alter function pg_catalog.pg_replication_origin_create(text) owner to postgres;

create function pg_catalog.pg_replication_origin_drop(text)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_drop(text) is 'drop replication origin identified by its name';

alter function pg_catalog.pg_replication_origin_drop(text) owner to postgres;

create function pg_catalog.pg_replication_origin_oid(text)
    stable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_oid(text) is 'translate the replication origin''s name to its id';

alter function pg_catalog.pg_replication_origin_oid(text) owner to postgres;

create function pg_catalog.pg_replication_origin_session_setup(text)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_session_setup(text) is 'configure session to maintain replication progress tracking for the passed in origin';

alter function pg_catalog.pg_replication_origin_session_setup(text) owner to postgres;

create function pg_catalog.pg_replication_origin_session_reset()
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_session_reset() is 'teardown configured replication progress tracking';

alter function pg_catalog.pg_replication_origin_session_reset() owner to postgres;

create function pg_catalog.pg_replication_origin_session_is_setup()
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_session_is_setup() is 'is a replication origin configured in this session';

alter function pg_catalog.pg_replication_origin_session_is_setup() owner to postgres;

create function pg_catalog.pg_replication_origin_session_progress(boolean)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_session_progress(boolean) is 'get the replication progress of the current session';

alter function pg_catalog.pg_replication_origin_session_progress(boolean) owner to postgres;

create function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone)
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone) is 'setup the transaction''s origin lsn and timestamp';

alter function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone) owner to postgres;

create function pg_catalog.pg_replication_origin_xact_reset()
    strict
    parallel restricted
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_xact_reset() is 'reset the transaction''s origin lsn and timestamp';

alter function pg_catalog.pg_replication_origin_xact_reset() owner to postgres;

create function pg_catalog.pg_replication_origin_advance(text, pg_lsn)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_advance(text, pg_lsn) is 'advance replication itentifier to specific location';

alter function pg_catalog.pg_replication_origin_advance(text, pg_lsn) owner to postgres;

create function pg_catalog.pg_replication_origin_progress(text, boolean)
    strict
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_replication_origin_progress(text, boolean) is 'get an individual replication origin''s replication progress';

alter function pg_catalog.pg_replication_origin_progress(text, boolean) owner to postgres;

create function pg_catalog.pg_show_replication_origin_status(out local_id oid, out external_id text,
                                                             out remote_lsn pg_lsn, out local_lsn pg_lsn)
    parallel restricted
    cost 1
    rows 100
    language internal
as -- missing source code
;

comment on function pg_catalog.pg_show_replication_origin_status(out oid, out text, out pg_lsn, out pg_lsn) is 'get progress for all replication origins';

alter function pg_catalog.pg_show_replication_origin_status(out oid, out text, out pg_lsn, out pg_lsn) owner to postgres;

create function pg_catalog.scale(numeric)
    immutable
    strict
    parallel safe
    cost 1
    language internal
as -- missing source code
;

comment on function pg_catalog.scale(numeric) is 'number of decimal digits in the fractional part';

alter function pg_catalog.scale(numeric) owner to postgres;

create function pg_catalog.ts_debug(config regconfig, document text, OUT alias text, OUT description text,
                                    OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary,
                                    OUT lexemes text[]) returns SETOF record
    stable
    strict
    parallel safe
    language sql
as
$$
SELECT tt.alias       AS alias,
       tt.description AS description,
       parse.token    AS token,
       ARRAY(SELECT m.mapdict::pg_catalog.regdictionary
             FROM pg_catalog.pg_ts_config_map AS m
             WHERE m.mapcfg = $1
               AND m.maptokentype = parse.tokid
             ORDER BY m.mapseqno)
                      AS dictionaries,
       (SELECT mapdict::pg_catalog.regdictionary
        FROM pg_catalog.pg_ts_config_map AS m
        WHERE m.mapcfg = $1
          AND m.maptokentype = parse.tokid
        ORDER BY pg_catalog.ts_lexize(mapdict, parse.token) IS NULL, m.mapseqno
        LIMIT 1
       )              AS dictionary,
       (SELECT pg_catalog.ts_lexize(mapdict, parse.token)
        FROM pg_catalog.pg_ts_config_map AS m
        WHERE m.mapcfg = $1
          AND m.maptokentype = parse.tokid
        ORDER BY pg_catalog.ts_lexize(mapdict, parse.token) IS NULL, m.mapseqno
        LIMIT 1
       )              AS lexemes
FROM pg_catalog.ts_parse(
                 (SELECT cfgparser FROM pg_catalog.pg_ts_config WHERE oid = $1), $2
         ) AS parse,
     pg_catalog.ts_token_type(
                 (SELECT cfgparser FROM pg_catalog.pg_ts_config WHERE oid = $1)
         ) AS tt
WHERE tt.tokid = parse.tokid
$$;

comment on function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) is 'debug function for text search configuration';

alter function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) owner to postgres;

create function pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text,
                                    OUT dictionaries regdictionary[], OUT dictionary regdictionary,
                                    OUT lexemes text[]) returns SETOF record
    stable
    strict
    parallel safe
    language sql
as
$$
SELECT *
FROM pg_catalog.ts_debug(pg_catalog.get_current_ts_config(), $1);
$$;

comment on function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) is 'debug function for current text search configuration';

alter function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) owner to postgres;

create function pg_catalog.ascii_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.ascii_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for SQL_ASCII to MULE_INTERNAL';

alter function pg_catalog.ascii_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_ascii(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_ascii(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to SQL_ASCII';

alter function pg_catalog.mic_to_ascii(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to MULE_INTERNAL';

alter function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to KOI8R';

alter function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-5 to MULE_INTERNAL';

alter function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to ISO-8859-5';

alter function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1251 to MULE_INTERNAL';

alter function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to WIN1251';

alter function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN866 to MULE_INTERNAL';

alter function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to WIN866';

alter function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to WIN1251';

alter function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1251 to KOI8R';

alter function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to WIN866';

alter function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN866 to KOI8R';

alter function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN866 to WIN1251';

alter function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1251 to WIN866';

alter function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-5 to KOI8R';

alter function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to ISO-8859-5';

alter function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-5 to WIN1251';

alter function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1251 to ISO-8859-5';

alter function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-5 to WIN866';

alter function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN866 to ISO-8859-5';

alter function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_CN to MULE_INTERNAL';

alter function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to EUC_CN';

alter function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JP to SJIS';

alter function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer) is 'internal conversion function for SJIS to EUC_JP';

alter function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JP to MULE_INTERNAL';

alter function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for SJIS to MULE_INTERNAL';

alter function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to EUC_JP';

alter function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to SJIS';

alter function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_KR to MULE_INTERNAL';

alter function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to EUC_KR';

alter function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_TW to BIG5';

alter function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer) is 'internal conversion function for BIG5 to EUC_TW';

alter function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_TW to MULE_INTERNAL';

alter function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for BIG5 to MULE_INTERNAL';

alter function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to EUC_TW';

alter function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to BIG5';

alter function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN2 to MULE_INTERNAL';

alter function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to LATIN2';

alter function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1250 to MULE_INTERNAL';

alter function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to WIN1250';

alter function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN2 to WIN1250';

alter function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1250 to LATIN2';

alter function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN1 to MULE_INTERNAL';

alter function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to LATIN1';

alter function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN3 to MULE_INTERNAL';

alter function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to LATIN3';

alter function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN4 to MULE_INTERNAL';

alter function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer) is 'internal conversion function for MULE_INTERNAL to LATIN4';

alter function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.ascii_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.ascii_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for SQL_ASCII to UTF8';

alter function pg_catalog.ascii_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_ascii(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_ascii(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to SQL_ASCII';

alter function pg_catalog.utf8_to_ascii(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for BIG5 to UTF8';

alter function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to BIG5';

alter function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to KOI8R';

alter function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8R to UTF8';

alter function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to KOI8U';

alter function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for KOI8U to UTF8';

alter function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to WIN1258';

alter function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for WIN1258 to UTF8';

alter function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_CN to UTF8';

alter function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_CN';

alter function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JP to UTF8';

alter function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_JP';

alter function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_KR to UTF8';

alter function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_KR';

alter function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_TW to UTF8';

alter function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_TW';

alter function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for GB18030 to UTF8';

alter function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to GB18030';

alter function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for GBK to UTF8';

alter function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to GBK';

alter function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to ISO-8859-8';

alter function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for ISO-8859-8 to UTF8';

alter function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for LATIN1 to UTF8';

alter function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to LATIN1';

alter function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for JOHAB to UTF8';

alter function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to JOHAB';

alter function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for SJIS to UTF8';

alter function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to SJIS';

alter function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for UHC to UTF8';

alter function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to UHC';

alter function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JIS_2004 to UTF8';

alter function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to EUC_JIS_2004';

alter function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer) is 'internal conversion function for SHIFT_JIS_2004 to UTF8';

alter function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer) is 'internal conversion function for UTF8 to SHIFT_JIS_2004';

alter function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer) is 'internal conversion function for EUC_JIS_2004 to SHIFT_JIS_2004';

alter function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer)
    strict
    parallel safe
    language c
as -- missing source code
;

comment on function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer) is 'internal conversion function for SHIFT_JIS_2004 to EUC_JIS_2004';

alter function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer) owner to postgres;

create function pg_catalog.dsnowball_init(internal)
    strict
    language c
as -- missing source code
;

alter function pg_catalog.dsnowball_init(internal) owner to postgres;

create function pg_catalog.dsnowball_lexize(internal, internal, internal, internal)
    strict
    language c
as -- missing source code
;

alter function pg_catalog.dsnowball_lexize(internal, internal, internal, internal) owner to postgres;

create function information_schema._pg_expandarray(anyarray, OUT x anyelement, OUT n integer) returns SETOF record
    immutable
    strict
    language sql
as
$$
select $1[s], s - pg_catalog.array_lower($1, 1) + 1
from pg_catalog.generate_series(pg_catalog.array_lower($1, 1),
                                pg_catalog.array_upper($1, 1),
                                1) as g(s)
$$;

alter function information_schema._pg_expandarray(anyarray, out anyelement, out integer) owner to postgres;

create function information_schema._pg_keysequal(smallint[], smallint[]) returns boolean
    immutable
    language sql
as
$$
select $1 operator (pg_catalog.<@) $2 and $2 operator (pg_catalog.<@) $1
$$;

alter function information_schema._pg_keysequal(smallint[], smallint[]) owner to postgres;

create function information_schema._pg_index_position(oid, smallint) returns integer
    stable
    strict
    language sql
as
$$
SELECT (ss.a).n
FROM (SELECT information_schema._pg_expandarray(indkey) AS a
      FROM pg_catalog.pg_index
      WHERE indexrelid = $1) ss
WHERE (ss.a).x = $2;
$$;

alter function information_schema._pg_index_position(oid, smallint) owner to postgres;

create function information_schema._pg_truetypid(pg_attribute, pg_type) returns oid
    immutable
    strict
    language sql
as
$$
SELECT CASE WHEN $2.typtype = 'd' THEN $2.typbasetype ELSE $1.atttypid END
$$;

alter function information_schema._pg_truetypid(pg_attribute, pg_type) owner to postgres;

create function information_schema._pg_truetypmod(pg_attribute, pg_type) returns integer
    immutable
    strict
    language sql
as
$$
SELECT CASE WHEN $2.typtype = 'd' THEN $2.typtypmod ELSE $1.atttypmod END
$$;

alter function information_schema._pg_truetypmod(pg_attribute, pg_type) owner to postgres;

create function information_schema._pg_char_max_length(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
SELECT CASE
           WHEN $2 = -1 /* default typmod */
               THEN null
           WHEN $1 IN (1042, 1043) /* char, varchar */
               THEN $2 - 4
           WHEN $1 IN (1560, 1562) /* bit, varbit */
               THEN $2
           ELSE null
           END
$$;

alter function information_schema._pg_char_max_length(oid, integer) owner to postgres;

create function information_schema._pg_char_octet_length(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
SELECT CASE
           WHEN $1 IN (25, 1042, 1043) /* text, char, varchar */
               THEN CASE
                        WHEN $2 = -1 /* default typmod */
                            THEN CAST(2 ^ 30 AS integer)
                        ELSE information_schema._pg_char_max_length($1, $2) *
                             pg_catalog.pg_encoding_max_length((SELECT encoding
                                                                FROM pg_catalog.pg_database
                                                                WHERE datname = pg_catalog.current_database()))
               END
           ELSE null
           END
$$;

alter function information_schema._pg_char_octet_length(oid, integer) owner to postgres;

create function information_schema._pg_numeric_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
SELECT CASE $1
           WHEN 21 /*int2*/ THEN 16
           WHEN 23 /*int4*/ THEN 32
           WHEN 20 /*int8*/ THEN 64
           WHEN 1700 /*numeric*/ THEN
               CASE
                   WHEN $2 = -1
                       THEN null
                   ELSE (($2 - 4) >> 16) & 65535
                   END
           WHEN 700 /*float4*/ THEN 24 /*FLT_MANT_DIG*/
           WHEN 701 /*float8*/ THEN 53 /*DBL_MANT_DIG*/
           ELSE null
           END
$$;

alter function information_schema._pg_numeric_precision(oid, integer) owner to postgres;

create function information_schema._pg_numeric_precision_radix(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
SELECT CASE
           WHEN $1 IN (21, 23, 20, 700, 701) THEN 2
           WHEN $1 IN (1700) THEN 10
           ELSE null
           END
$$;

alter function information_schema._pg_numeric_precision_radix(oid, integer) owner to postgres;

create function information_schema._pg_numeric_scale(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
SELECT CASE
           WHEN $1 IN (21, 23, 20) THEN 0
           WHEN $1 IN (1700) THEN
               CASE
                   WHEN $2 = -1
                       THEN null
                   ELSE ($2 - 4) & 65535
                   END
           ELSE null
           END
$$;

alter function information_schema._pg_numeric_scale(oid, integer) owner to postgres;

create function information_schema._pg_datetime_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    language sql
as
$$
SELECT CASE
           WHEN $1 IN (1082) /* date */
               THEN 0
           WHEN $1 IN (1083, 1114, 1184, 1266) /* time, timestamp, same + tz */
               THEN CASE WHEN $2 < 0 THEN 6 ELSE $2 END
           WHEN $1 IN (1186) /* interval */
               THEN CASE WHEN $2 < 0 OR $2 & 65535 = 65535 THEN 6 ELSE $2 & 65535 END
           ELSE null
           END
$$;

alter function information_schema._pg_datetime_precision(oid, integer) owner to postgres;

create function information_schema._pg_interval_type(typid oid, mod integer) returns text
    immutable
    strict
    language sql
as
$$
SELECT CASE
           WHEN $1 IN (1186) /* interval */
               THEN upper(substring(format_type($1, $2) from 'interval[()0-9]* #"%#"' for '#'))
           ELSE null
           END
$$;

alter function information_schema._pg_interval_type(oid, integer) owner to postgres;

create function pg_catalog.plpgsql_call_handler()
    language c
as -- missing source code
;

alter function pg_catalog.plpgsql_call_handler() owner to postgres;

create function pg_catalog.plpgsql_inline_handler(internal)
    strict
    language c
as -- missing source code
;

alter function pg_catalog.plpgsql_inline_handler(internal) owner to postgres;

create function pg_catalog.plpgsql_validator(oid)
    strict
    language c
as -- missing source code
;

alter function pg_catalog.plpgsql_validator(oid) owner to postgres;

create function _timescaledb_internal.restart_background_workers()
    language c
as -- missing source code
;

alter function _timescaledb_internal.restart_background_workers() owner to postgres;

create function _timescaledb_internal.insert_blocker()
    language c
as -- missing source code
;

alter function _timescaledb_internal.insert_blocker() owner to postgres;

create trigger ts_insert_blocker
    before insert
    on rad_output
    for each row
execute procedure _timescaledb_internal.insert_blocker();

create trigger ts_insert_blocker
    before insert
    on collected
    for each row
execute procedure _timescaledb_internal.insert_blocker();

create function _timescaledb_internal.continuous_agg_invalidation_trigger()
    language c
as -- missing source code
;

alter function _timescaledb_internal.continuous_agg_invalidation_trigger() owner to postgres;

create function _timescaledb_internal.calculate_chunk_interval(dimension_id integer, dimension_coord bigint,
                                                               chunk_target_size bigint)
    language c
as -- missing source code
;

alter function _timescaledb_internal.calculate_chunk_interval(integer, bigint, bigint) owner to postgres;

create function _timescaledb_internal.chunks_in(record record, chunks integer[])
    strict
    language c
as -- missing source code
;

alter function _timescaledb_internal.chunks_in(record, integer[]) owner to postgres;

create function _timescaledb_internal.chunk_id_from_relid(relid oid)
    stable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.chunk_id_from_relid(oid) owner to postgres;

create function _timescaledb_internal.chunk_index_clone(chunk_index_oid oid)
    strict
    language c
as -- missing source code
;

alter function _timescaledb_internal.chunk_index_clone(oid) owner to postgres;

create function _timescaledb_internal.chunk_index_replace(chunk_index_oid_old oid, chunk_index_oid_new oid)
    strict
    language c
as -- missing source code
;

alter function _timescaledb_internal.chunk_index_replace(oid, oid) owner to postgres;

create function _timescaledb_internal.enterprise_enabled()
    language c
as -- missing source code
;

alter function _timescaledb_internal.enterprise_enabled() owner to postgres;

create function _timescaledb_internal.current_license_key()
    language c
as -- missing source code
;

alter function _timescaledb_internal.current_license_key() owner to postgres;

create function _timescaledb_internal.tsl_loaded()
    language c
as -- missing source code
;

alter function _timescaledb_internal.tsl_loaded() owner to postgres;

create function _timescaledb_internal.license_expiration_time()
    language c
as -- missing source code
;

alter function _timescaledb_internal.license_expiration_time() owner to postgres;

create function _timescaledb_internal.print_license_expiration_info()
    language c
as -- missing source code
;

alter function _timescaledb_internal.print_license_expiration_info() owner to postgres;

create function _timescaledb_internal.license_edition()
    language c
as -- missing source code
;

alter function _timescaledb_internal.license_edition() owner to postgres;

create function _timescaledb_internal.current_db_set_license_key(new_key text) returns text
    language plpgsql
as
$$
DECLARE
    db text;
BEGIN
    SELECT current_database() INTO db;
    EXECUTE format('ALTER DATABASE %I SET timescaledb.license_key = %L', db, new_key);
    EXECUTE format('SET SESSION timescaledb.license_key = %L', new_key);
    PERFORM _timescaledb_internal.restart_background_workers();
    RETURN new_key;
END
$$;

alter function _timescaledb_internal.current_db_set_license_key(text) owner to postgres;

create function _timescaledb_internal.to_unix_microseconds(ts timestamp with time zone)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.to_unix_microseconds(timestamp with time zone) owner to postgres;

create function _timescaledb_internal.to_timestamp(unixtime_us bigint)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.to_timestamp(bigint) owner to postgres;

create function _timescaledb_internal.to_timestamp_without_timezone(unixtime_us bigint)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.to_timestamp_without_timezone(bigint) owner to postgres;

create function _timescaledb_internal.to_date(unixtime_us bigint)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.to_date(bigint) owner to postgres;

create function _timescaledb_internal.to_interval(unixtime_us bigint)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.to_interval(bigint) owner to postgres;

create function _timescaledb_internal.time_literal_sql(time_value bigint, column_type regtype) returns text
    stable
    language plpgsql
as
$$
DECLARE
    ret text;
BEGIN
    IF time_value IS NULL THEN
        RETURN format('%L', NULL);
    END IF;
    CASE column_type
        WHEN 'BIGINT'::regtype , 'INTEGER'::regtype , 'SMALLINT'::regtype THEN
            RETURN format('%L', time_value); -- scale determined by user.
        WHEN 'TIMESTAMP'::regtype THEN
            --the time_value for timestamps w/o tz does not depend on local timezones. So perform at UTC.
            RETURN format('TIMESTAMP %1$L',
                          timezone('UTC', _timescaledb_internal.to_timestamp(time_value))); -- microseconds
        WHEN 'TIMESTAMPTZ'::regtype THEN
            -- assume time_value is in microsec
            RETURN format('TIMESTAMPTZ %1$L', _timescaledb_internal.to_timestamp(time_value)); -- microseconds
        WHEN 'DATE'::regtype THEN
            RETURN format('%L', timezone('UTC', _timescaledb_internal.to_timestamp(time_value))::date); ELSE
            EXECUTE 'SELECT format(''%L'', $1::' || column_type::text || ')' into ret using time_value;
            RETURN ret;
        END CASE;
END
$$;

alter function _timescaledb_internal.time_literal_sql(bigint, regtype) owner to postgres;

create function _timescaledb_internal.interval_to_usec(chunk_interval interval) returns bigint
    immutable
    parallel safe
    language sql
as
$$
SELECT (int_sec * 1000000)::bigint
from extract(epoch from chunk_interval) as int_sec;
$$;

alter function _timescaledb_internal.interval_to_usec(interval) owner to postgres;

create function _timescaledb_internal.time_to_internal(time_val anyelement)
    strict
    language c
as -- missing source code
;

alter function _timescaledb_internal.time_to_internal(anyelement) owner to postgres;

create function _timescaledb_internal.dimension_is_finite(val bigint) returns boolean
    immutable
    parallel safe
    language sql
as
$$
    --end values of bigint reserved for infinite
SELECT val > (-9223372036854775808)::bigint AND val < 9223372036854775807::bigint
$$;

alter function _timescaledb_internal.dimension_is_finite(bigint) owner to postgres;

create function _timescaledb_internal.dimension_slice_get_constraint_sql(dimension_slice_id integer) returns text
    language plpgsql
as
$$
DECLARE
    dimension_slice_row _timescaledb_catalog.dimension_slice;
    dimension_row       _timescaledb_catalog.dimension;
    dimension_def       TEXT;
    dimtype             REGTYPE;
    parts               TEXT[];
BEGIN
    SELECT *
    INTO STRICT dimension_slice_row
    FROM _timescaledb_catalog.dimension_slice
    WHERE id = dimension_slice_id;

    SELECT *
    INTO STRICT dimension_row
    FROM _timescaledb_catalog.dimension
    WHERE id = dimension_slice_row.dimension_id;

    IF dimension_row.partitioning_func_schema IS NOT NULL AND
       dimension_row.partitioning_func IS NOT NULL THEN
        SELECT prorettype
        INTO STRICT dimtype
        FROM pg_catalog.pg_proc pro
        WHERE pro.oid =
              format('%I.%I', dimension_row.partitioning_func_schema, dimension_row.partitioning_func)::regproc::oid;

        dimension_def := format('%1$I.%2$I(%3$I)',
                                dimension_row.partitioning_func_schema,
                                dimension_row.partitioning_func,
                                dimension_row.column_name);
    ELSE
        dimension_def := format('%1$I', dimension_row.column_name);
        dimtype := dimension_row.column_type;
    END IF;

    IF dimension_row.num_slices IS NOT NULL THEN

        IF _timescaledb_internal.dimension_is_finite(dimension_slice_row.range_start) THEN
            parts = parts || format(' %1$s >= %2$L ', dimension_def, dimension_slice_row.range_start);
        END IF;

        IF _timescaledb_internal.dimension_is_finite(dimension_slice_row.range_end) THEN
            parts = parts || format(' %1$s < %2$L ', dimension_def, dimension_slice_row.range_end);
        END IF;

        IF array_length(parts, 1) = 0 THEN
            RETURN NULL;
        END IF;
        return array_to_string(parts, 'AND');
    ELSE
        --TODO: only works with time for now
        IF _timescaledb_internal.time_literal_sql(dimension_slice_row.range_start, dimtype) =
           _timescaledb_internal.time_literal_sql(dimension_slice_row.range_end, dimtype) THEN
            RAISE 'time-based constraints have the same start and end values for column "%": %',
                dimension_row.column_name,
                _timescaledb_internal.time_literal_sql(dimension_slice_row.range_end, dimtype);
        END IF;

        parts = ARRAY []::text[];

        IF _timescaledb_internal.dimension_is_finite(dimension_slice_row.range_start) THEN
            parts = parts || format(' %1$s >= %2$s ',
                                    dimension_def,
                                    _timescaledb_internal.time_literal_sql(dimension_slice_row.range_start, dimtype));
        END IF;

        IF _timescaledb_internal.dimension_is_finite(dimension_slice_row.range_end) THEN
            parts = parts || format(' %1$s < %2$s ',
                                    dimension_def,
                                    _timescaledb_internal.time_literal_sql(dimension_slice_row.range_end, dimtype));
        END IF;

        return array_to_string(parts, 'AND');
    END IF;
END
$$;

alter function _timescaledb_internal.dimension_slice_get_constraint_sql(integer) owner to postgres;

create function _timescaledb_internal.get_create_command(table_name name) returns text
    language plpgsql
as
$fun$
DECLARE
    h_id             INTEGER;
    schema_name      NAME;
    time_column      NAME;
    time_interval    BIGINT;
    space_column     NAME;
    space_partitions INTEGER;
    dimension_cnt    INTEGER;
    dimension_row    record;
    ret              TEXT;
BEGIN
    SELECT h.id, h.schema_name
    FROM _timescaledb_catalog.hypertable AS h
    WHERE h.table_name = get_create_command.table_name
    INTO h_id, schema_name;

    IF h_id IS NULL THEN
        RAISE EXCEPTION 'hypertable "%" not found', table_name
            USING ERRCODE = 'TS101';
    END IF;

    SELECT COUNT(*)
    FROM _timescaledb_catalog.dimension d
    WHERE d.hypertable_id = h_id
    INTO STRICT dimension_cnt;

    IF dimension_cnt > 2 THEN
        RAISE EXCEPTION 'get_create_command only supports hypertables with up to 2 dimensions'
            USING ERRCODE = 'TS101';
    END IF;

    FOR dimension_row IN
        SELECT *
        FROM _timescaledb_catalog.dimension d
        WHERE d.hypertable_id = h_id
        LOOP
            IF dimension_row.interval_length IS NOT NULL THEN
                time_column := dimension_row.column_name;
                time_interval := dimension_row.interval_length;
            ELSIF dimension_row.num_slices IS NOT NULL THEN
                space_column := dimension_row.column_name;
                space_partitions := dimension_row.num_slices;
            END IF;
        END LOOP;

    ret := format($$SELECT create_hypertable('%I.%I', '%s'$$, schema_name, table_name, time_column);
    IF space_column IS NOT NULL THEN
        ret := ret || format($$, '%I', %s$$, space_column, space_partitions);
    END IF;
    ret := ret || format($$, chunk_time_interval => %s, create_default_indexes=>FALSE);$$, time_interval);

    RETURN ret;
END
$fun$;

alter function _timescaledb_internal.get_create_command(name) owner to postgres;

create function _timescaledb_internal.chunk_constraint_add_table_constraint(chunk_constraint_row _timescaledb_catalog.chunk_constraint) returns void
    language plpgsql
as
$fun$
DECLARE
    chunk_row      _timescaledb_catalog.chunk;
    hypertable_row _timescaledb_catalog.hypertable;
    constraint_oid OID;
    check_sql      TEXT;
    def            TEXT;
BEGIN
    SELECT * INTO STRICT chunk_row FROM _timescaledb_catalog.chunk c WHERE c.id = chunk_constraint_row.chunk_id;
    SELECT * INTO STRICT hypertable_row FROM _timescaledb_catalog.hypertable h WHERE h.id = chunk_row.hypertable_id;

    IF chunk_constraint_row.dimension_slice_id IS NOT NULL THEN
        check_sql = _timescaledb_internal.dimension_slice_get_constraint_sql(chunk_constraint_row.dimension_slice_id);
        IF check_sql IS NOT NULL THEN
            def := format('CHECK (%s)', check_sql);
        ELSE
            def := NULL;
        END IF;
    ELSIF chunk_constraint_row.hypertable_constraint_name IS NOT NULL THEN
        SELECT oid
        INTO STRICT constraint_oid
        FROM pg_constraint
        WHERE conname = chunk_constraint_row.hypertable_constraint_name
          AND conrelid = format('%I.%I', hypertable_row.schema_name, hypertable_row.table_name)::regclass::oid;
        def := pg_get_constraintdef(constraint_oid);
    ELSE
        RAISE 'unknown constraint type';
    END IF;

    IF def IS NOT NULL THEN
        EXECUTE format(
                $$ ALTER TABLE %I.%I ADD CONSTRAINT %I %s $$,
                chunk_row.schema_name, chunk_row.table_name, chunk_constraint_row.constraint_name, def
            );
    END IF;
END
$fun$;

alter function _timescaledb_internal.chunk_constraint_add_table_constraint(_timescaledb_catalog.chunk_constraint) owner to postgres;

create function _timescaledb_internal.get_partition_for_key(val anyelement)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.get_partition_for_key(anyelement) owner to postgres;

create function _timescaledb_internal.get_partition_hash(val anyelement)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.get_partition_hash(anyelement) owner to postgres;

create function _timescaledb_internal.get_time_type(hypertable_id integer)
    stable
    strict
    language c
as -- missing source code
;

alter function _timescaledb_internal.get_time_type(integer) owner to postgres;

create function _timescaledb_internal.is_main_table(table_oid regclass) returns boolean
    stable
    language sql
as
$$
SELECT EXISTS(SELECT 1 FROM _timescaledb_catalog.hypertable WHERE table_name = relname AND schema_name = nspname)
FROM pg_class c
         INNER JOIN pg_namespace n ON (n.OID = c.relnamespace)
WHERE c.OID = table_oid;
$$;

alter function _timescaledb_internal.is_main_table(regclass) owner to postgres;

create function _timescaledb_internal.is_main_table(schema_name name, table_name name) returns boolean
    stable
    language sql
as
$$
SELECT EXISTS(
               SELECT 1
               FROM _timescaledb_catalog.hypertable h
               WHERE h.schema_name = is_main_table.schema_name
                 AND h.table_name = is_main_table.table_name
           );
$$;

alter function _timescaledb_internal.is_main_table(name, name) owner to postgres;

create function _timescaledb_internal.hypertable_from_main_table(table_oid regclass) returns _timescaledb_catalog.hypertable
    stable
    language sql
as
$$
SELECT h.*
FROM pg_class c
         INNER JOIN pg_namespace n ON (n.OID = c.relnamespace)
         INNER JOIN _timescaledb_catalog.hypertable h ON (h.table_name = c.relname AND h.schema_name = n.nspname)
WHERE c.OID = table_oid;
$$;

alter function _timescaledb_internal.hypertable_from_main_table(regclass) owner to postgres;

create function _timescaledb_internal.main_table_from_hypertable(hypertable_id integer) returns regclass
    stable
    language sql
as
$$
SELECT format('%I.%I', h.schema_name, h.table_name)::regclass
FROM _timescaledb_catalog.hypertable h
WHERE id = hypertable_id;
$$;

alter function _timescaledb_internal.main_table_from_hypertable(integer) owner to postgres;

create function _timescaledb_internal.time_col_name_for_chunk(schema_name name, table_name name) returns name
    stable
    language plpgsql
as
$$
DECLARE
    time_col_name NAME;
BEGIN
    SELECT h.time_column_name
    INTO STRICT time_col_name
    FROM _timescaledb_catalog.hypertable h
             INNER JOIN _timescaledb_catalog.chunk c ON (c.hypertable_id = h.id)
    WHERE c.schema_name = time_col_name_for_chunk.schema_name
      AND c.table_name = time_col_name_for_chunk.table_name;
    RETURN time_col_name;
END
$$;

alter function _timescaledb_internal.time_col_name_for_chunk(name, name) owner to postgres;

create function _timescaledb_internal.time_col_type_for_chunk(schema_name name, table_name name) returns regtype
    stable
    language plpgsql
as
$$
DECLARE
    time_col_type REGTYPE;
BEGIN
    SELECT h.time_column_type
    INTO STRICT time_col_type
    FROM _timescaledb_catalog.hypertable h
             INNER JOIN _timescaledb_catalog.chunk c ON (c.hypertable_id = h.id)
    WHERE c.schema_name = time_col_type_for_chunk.schema_name
      AND c.table_name = time_col_type_for_chunk.table_name;
    RETURN time_col_type;
END
$$;

alter function _timescaledb_internal.time_col_type_for_chunk(name, name) owner to postgres;

create function create_hypertable(main_table regclass, time_column_name name,
                                  partitioning_column name default NULL::name,
                                  number_partitions integer default NULL::integer,
                                  associated_schema_name name default NULL::name,
                                  associated_table_prefix name default NULL::name,
                                  chunk_time_interval anyelement default NULL::bigint,
                                  create_default_indexes boolean default true, if_not_exists boolean default false,
                                  partitioning_func regproc default NULL::regproc, migrate_data boolean default false,
                                  chunk_target_size text default NULL::text,
                                  chunk_sizing_func regproc default '_timescaledb_internal.calculate_chunk_interval'::regproc,
                                  time_partitioning_func regproc default NULL::regproc)
    language c
as -- missing source code
;

alter function create_hypertable(regclass, name, name, integer, name, name, anyelement, boolean, boolean, regproc, boolean, text, regproc, regproc) owner to postgres;

create function set_adaptive_chunking(hypertable regclass, chunk_target_size text,
                                      inout chunk_sizing_func regproc default '_timescaledb_internal.calculate_chunk_interval'::regproc,
                                      out chunk_target_size bigint)
    language c
as -- missing source code
;

alter function set_adaptive_chunking(regclass, text, inout regproc, out bigint) owner to postgres;

create function set_chunk_time_interval(main_table regclass, chunk_time_interval anyelement,
                                        dimension_name name default NULL::name)
    language c
as -- missing source code
;

alter function set_chunk_time_interval(regclass, anyelement, name) owner to postgres;

create function set_number_partitions(main_table regclass, number_partitions integer,
                                      dimension_name name default NULL::name)
    language c
as -- missing source code
;

alter function set_number_partitions(regclass, integer, name) owner to postgres;

create function drop_chunks(older_than "any" default NULL::unknown, table_name name default NULL::name,
                            schema_name name default NULL::name, cascade boolean default false,
                            newer_than "any" default NULL::unknown, "verbose" boolean default false,
                            cascade_to_materializations boolean default NULL::boolean)
    language c
as -- missing source code
;

alter function drop_chunks("any", name, name, boolean, "any", boolean, boolean) owner to postgres;

create function show_chunks(hypertable regclass default NULL::regclass, older_than "any" default NULL::unknown,
                            newer_than "any" default NULL::unknown)
    stable
    parallel safe
    language c
as -- missing source code
;

alter function show_chunks(regclass, "any", "any") owner to postgres;

create function add_dimension(main_table regclass, column_name name, number_partitions integer default NULL::integer,
                              chunk_time_interval anyelement default NULL::bigint,
                              partitioning_func regproc default NULL::regproc, if_not_exists boolean default false)
    language c
as -- missing source code
;

alter function add_dimension(regclass, name, integer, anyelement, regproc, boolean) owner to postgres;

create function attach_tablespace(tablespace name, hypertable regclass, if_not_attached boolean default false)
    language c
as -- missing source code
;

alter function attach_tablespace(name, regclass, boolean) owner to postgres;

create function detach_tablespace(tablespace name, hypertable regclass default NULL::regclass,
                                  if_attached boolean default false)
    language c
as -- missing source code
;

alter function detach_tablespace(name, regclass, boolean) owner to postgres;

create function detach_tablespaces(hypertable regclass)
    language c
as -- missing source code
;

alter function detach_tablespaces(regclass) owner to postgres;

create function show_tablespaces(hypertable regclass)
    strict
    language c
as -- missing source code
;

alter function show_tablespaces(regclass) owner to postgres;

create function _timescaledb_internal.process_ddl_event()
    language c
as -- missing source code
;

alter function _timescaledb_internal.process_ddl_event() owner to postgres;

create function _timescaledb_internal.first_sfunc(internal, anyelement, "any")
    immutable
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.first_sfunc(internal, anyelement, "any") owner to postgres;

create function _timescaledb_internal.first_combinefunc(internal, internal)
    immutable
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.first_combinefunc(internal, internal) owner to postgres;

create function _timescaledb_internal.last_sfunc(internal, anyelement, "any")
    immutable
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.last_sfunc(internal, anyelement, "any") owner to postgres;

create function _timescaledb_internal.last_combinefunc(internal, internal)
    immutable
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.last_combinefunc(internal, internal) owner to postgres;

create function _timescaledb_internal.bookend_finalfunc(internal, anyelement, "any")
    immutable
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.bookend_finalfunc(internal, anyelement, "any") owner to postgres;

create function _timescaledb_internal.bookend_serializefunc(internal)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.bookend_serializefunc(internal) owner to postgres;

create function _timescaledb_internal.bookend_deserializefunc(bytea, internal)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.bookend_deserializefunc(bytea, internal) owner to postgres;

create function time_bucket(bucket_width interval, ts timestamp)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(interval, timestamp) owner to postgres;

create function time_bucket(bucket_width interval, ts timestamp with time zone)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(interval, timestamp with time zone) owner to postgres;

create function time_bucket(bucket_width interval, ts date)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(interval, date) owner to postgres;

create function time_bucket(bucket_width interval, ts timestamp, origin timestamp)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(interval, timestamp, timestamp) owner to postgres;

create function time_bucket(bucket_width interval, ts timestamp with time zone, origin timestamp with time zone)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(interval, timestamp with time zone, timestamp with time zone) owner to postgres;

create function time_bucket(bucket_width interval, ts date, origin date)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(interval, date, date) owner to postgres;

create function time_bucket(bucket_width smallint, ts smallint)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(smallint, smallint) owner to postgres;

create function time_bucket(bucket_width integer, ts integer)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(integer, integer) owner to postgres;

create function time_bucket(bucket_width bigint, ts bigint)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(bigint, bigint) owner to postgres;

create function time_bucket(bucket_width smallint, ts smallint, "offset" smallint)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(smallint, smallint, smallint) owner to postgres;

create function time_bucket(bucket_width integer, ts integer, "offset" integer)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(integer, integer, integer) owner to postgres;

create function time_bucket(bucket_width bigint, ts bigint, "offset" bigint)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket(bigint, bigint, bigint) owner to postgres;

create function time_bucket(bucket_width interval, ts timestamp without time zone,
                            "offset" interval) returns timestamp without time zone
    immutable
    strict
    parallel safe
    language sql
as
$$
SELECT public.time_bucket(bucket_width, ts - "offset") + "offset";
$$;

alter function time_bucket(interval, timestamp, interval) owner to postgres;

create function time_bucket(bucket_width interval, ts timestamp with time zone, "offset" interval) returns timestamp with time zone
    immutable
    strict
    parallel safe
    language sql
as
$$
SELECT public.time_bucket(bucket_width, ts - "offset") + "offset";
$$;

alter function time_bucket(interval, timestamp with time zone, interval) owner to postgres;

create function time_bucket(bucket_width interval, ts date, "offset" interval) returns date
    immutable
    strict
    parallel safe
    language sql
as
$$
SELECT (public.time_bucket(bucket_width, ts - "offset") + "offset")::date;
$$;

alter function time_bucket(interval, date, interval) owner to postgres;

create function _timescaledb_internal.get_git_commit()
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.get_git_commit() owner to postgres;

create function _timescaledb_internal.get_os_info()
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.get_os_info() owner to postgres;

create function get_telemetry_report(always_display_report boolean default false)
    stable
    parallel safe
    language c
as -- missing source code
;

alter function get_telemetry_report(boolean) owner to postgres;

create function hypertable_relation_size(main_table regclass)
    returns TABLE
            (
                table_bytes bigint,
                index_bytes bigint,
                toast_bytes bigint,
                total_bytes bigint
            )
    stable
    strict
    language plpgsql
as
$fun$
DECLARE
    table_name  NAME;
    schema_name NAME;
BEGIN
    SELECT relname, nspname
    INTO STRICT table_name, schema_name
    FROM pg_class c
             INNER JOIN pg_namespace n ON (n.OID = c.relnamespace)
    WHERE c.OID = main_table;

    RETURN QUERY EXECUTE format(
            $$
        SELECT table_bytes,
               index_bytes,
               toast_bytes,
               total_bytes
               FROM (
               SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes FROM (
                      SELECT
                      sum(pg_total_relation_size(format('%%I.%%I', c.schema_name, c.table_name)))::bigint as total_bytes,
                      sum(pg_indexes_size(format('%%I.%%I', c.schema_name, c.table_name)))::bigint AS index_bytes,
                      sum(pg_total_relation_size(reltoastrelid))::bigint AS toast_bytes
                      FROM
                      _timescaledb_catalog.hypertable h,
                      _timescaledb_catalog.chunk c,
                      pg_class pgc,
                      pg_namespace pns
                      WHERE h.schema_name = %L
                      AND h.table_name = %L
                      AND c.hypertable_id = h.id
                      AND pgc.relname = h.table_name
                      AND pns.oid = pgc.relnamespace
                      AND pns.nspname = h.schema_name
                      AND relkind = 'r'
                      ) sub1
               ) sub2;
        $$,
            schema_name, table_name);

END;
$fun$;

alter function hypertable_relation_size(regclass) owner to postgres;

create function _timescaledb_internal.range_value_to_pretty(time_value bigint, column_type regtype) returns text
    stable
    language plpgsql
as
$$
DECLARE
BEGIN
    IF NOT _timescaledb_internal.dimension_is_finite(time_value) THEN
        RETURN '';
    END IF;
    IF time_value IS NULL THEN
        RETURN format('%L', NULL);
    END IF;
    CASE column_type
        WHEN 'BIGINT'::regtype , 'INTEGER'::regtype , 'SMALLINT'::regtype THEN
            RETURN format('%L', time_value); -- scale determined by user.
        WHEN 'TIMESTAMP'::regtype , 'TIMESTAMPTZ'::regtype THEN
            -- assume time_value is in microsec
            RETURN format('%1$L', _timescaledb_internal.to_timestamp(time_value)); -- microseconds
        WHEN 'DATE'::regtype THEN
            RETURN format('%L', timezone('UTC', _timescaledb_internal.to_timestamp(time_value))::date); ELSE
            RETURN time_value;
        END CASE;
END
$$;

alter function _timescaledb_internal.range_value_to_pretty(bigint, regtype) owner to postgres;

create function _timescaledb_internal.partitioning_column_to_pretty(d _timescaledb_catalog.dimension) returns text
    stable
    strict
    language plpgsql
as
$$
DECLARE
BEGIN
    IF d.partitioning_func IS NULL THEN
        RETURN d.column_name;
    ELSE
        RETURN format('%I.%I(%I)', d.partitioning_func_schema, d.partitioning_func, d.column_name);
    END IF;
END
$$;

alter function _timescaledb_internal.partitioning_column_to_pretty(_timescaledb_catalog.dimension) owner to postgres;

create function hypertable_relation_size_pretty(main_table regclass)
    returns TABLE
            (
                table_size text,
                index_size text,
                toast_size text,
                total_size text
            )
    stable
    strict
    language plpgsql
as
$$
DECLARE
    table_name  NAME;
    schema_name NAME;
BEGIN
    RETURN QUERY
        SELECT pg_size_pretty(table_bytes) as table,
               pg_size_pretty(index_bytes) as index,
               pg_size_pretty(toast_bytes) as toast,
               pg_size_pretty(total_bytes) as total
        FROM public.hypertable_relation_size(main_table);

END;
$$;

alter function hypertable_relation_size_pretty(regclass) owner to postgres;

create function chunk_relation_size(main_table regclass)
    returns TABLE
            (
                chunk_id                    integer,
                chunk_table                 text,
                partitioning_columns        name[],
                partitioning_column_types   regtype[],
                partitioning_hash_functions text[],
                ranges                      int8range[],
                table_bytes                 bigint,
                index_bytes                 bigint,
                toast_bytes                 bigint,
                total_bytes                 bigint
            )
    stable
    strict
    language plpgsql
as
$fun$
DECLARE
    table_name  NAME;
    schema_name NAME;
BEGIN
    SELECT relname, nspname
    INTO STRICT table_name, schema_name
    FROM pg_class c
             INNER JOIN pg_namespace n ON (n.OID = c.relnamespace)
    WHERE c.OID = main_table;

    RETURN QUERY EXECUTE format(
            $$

        SELECT chunk_id,
        chunk_table,
        partitioning_columns,
        partitioning_column_types,
        partitioning_hash_functions,
        ranges,
        table_bytes,
        index_bytes,
        toast_bytes,
        total_bytes
        FROM (
        SELECT *,
              total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes
              FROM (
               SELECT c.id as chunk_id,
               format('%%I.%%I', c.schema_name, c.table_name) as chunk_table,
               pg_total_relation_size(format('%%I.%%I', c.schema_name, c.table_name)) AS total_bytes,
               pg_indexes_size(format('%%I.%%I', c.schema_name, c.table_name)) AS index_bytes,
               pg_total_relation_size(reltoastrelid) AS toast_bytes,
               array_agg(d.column_name ORDER BY d.interval_length, d.column_name ASC) as partitioning_columns,
               array_agg(d.column_type ORDER BY d.interval_length, d.column_name ASC) as partitioning_column_types,
               array_agg(d.partitioning_func_schema || '.' || d.partitioning_func ORDER BY d.interval_length, d.column_name ASC) as partitioning_hash_functions,
               array_agg(int8range(range_start, range_end) ORDER BY d.interval_length, d.column_name ASC) as ranges
               FROM
               _timescaledb_catalog.hypertable h,
               _timescaledb_catalog.chunk c,
               _timescaledb_catalog.chunk_constraint cc,
               _timescaledb_catalog.dimension d,
               _timescaledb_catalog.dimension_slice ds,
               pg_class pgc,
               pg_namespace pns
               WHERE h.schema_name = %L
                     AND h.table_name = %L
                     AND pgc.relname = c.table_name
                     AND pns.oid = pgc.relnamespace
                     AND pns.nspname = c.schema_name
                     AND relkind = 'r'
                     AND c.hypertable_id = h.id
                     AND c.id = cc.chunk_id
                     AND cc.dimension_slice_id = ds.id
                     AND ds.dimension_id = d.id
               GROUP BY c.id, pgc.reltoastrelid, pgc.oid ORDER BY c.id
               ) sub1
        ) sub2;
        $$,
            schema_name, table_name);

END;
$fun$;

alter function chunk_relation_size(regclass) owner to postgres;

create function chunk_relation_size_pretty(main_table regclass)
    returns TABLE
            (
                chunk_id                    integer,
                chunk_table                 text,
                partitioning_columns        name[],
                partitioning_column_types   regtype[],
                partitioning_hash_functions text[],
                ranges                      text[],
                table_size                  text,
                index_size                  text,
                toast_size                  text,
                total_size                  text
            )
    stable
    strict
    language plpgsql
as
$fun$
DECLARE
    table_name  NAME;
    schema_name NAME;
BEGIN
    SELECT relname, nspname
    INTO STRICT table_name, schema_name
    FROM pg_class c
             INNER JOIN pg_namespace n ON (n.OID = c.relnamespace)
    WHERE c.OID = main_table;

    RETURN QUERY EXECUTE format(
            $$

        SELECT chunk_id,
        chunk_table,
        partitioning_columns,
        partitioning_column_types,
        partitioning_functions,
        ranges,
        pg_size_pretty(table_bytes) AS table,
        pg_size_pretty(index_bytes) AS index,
        pg_size_pretty(toast_bytes) AS toast,
        pg_size_pretty(total_bytes) AS total
        FROM (
        SELECT *,
              total_bytes-index_bytes-COALESCE(toast_bytes,0) AS table_bytes
              FROM (
               SELECT c.id as chunk_id,
               format('%%I.%%I', c.schema_name, c.table_name) as chunk_table,
               pg_total_relation_size(format('%%I.%%I', c.schema_name, c.table_name)) AS total_bytes,
               pg_indexes_size(format('%%I.%%I', c.schema_name, c.table_name)) AS index_bytes,
               pg_total_relation_size(reltoastrelid) AS toast_bytes,
               array_agg(d.column_name ORDER BY d.interval_length, d.column_name ASC) as partitioning_columns,
               array_agg(d.column_type ORDER BY d.interval_length, d.column_name ASC) as partitioning_column_types,
               array_agg(d.partitioning_func_schema || '.' || d.partitioning_func ORDER BY d.interval_length, d.column_name ASC) as partitioning_functions,
               array_agg('[' || _timescaledb_internal.range_value_to_pretty(range_start, column_type) ||
                         ',' ||
                         _timescaledb_internal.range_value_to_pretty(range_end, column_type) || ')' ORDER BY d.interval_length, d.column_name ASC) as ranges
               FROM
               _timescaledb_catalog.hypertable h,
               _timescaledb_catalog.chunk c,
               _timescaledb_catalog.chunk_constraint cc,
               _timescaledb_catalog.dimension d,
               _timescaledb_catalog.dimension_slice ds,
               pg_class pgc,
               pg_namespace pns
               WHERE h.schema_name = %L
                     AND h.table_name = %L
                     AND pgc.relname = c.table_name
                     AND pns.oid = pgc.relnamespace
                     AND pns.nspname = c.schema_name
                     AND relkind = 'r'
                     AND c.hypertable_id = h.id
                     AND c.id = cc.chunk_id
                     AND cc.dimension_slice_id = ds.id
                     AND ds.dimension_id = d.id
               GROUP BY c.id, pgc.reltoastrelid, pgc.oid ORDER BY c.id
               ) sub1
        ) sub2;
        $$,
            schema_name, table_name);

END;
$fun$;

alter function chunk_relation_size_pretty(regclass) owner to postgres;

create function indexes_relation_size(main_table regclass)
    returns TABLE
            (
                index_name  text,
                total_bytes bigint
            )
    stable
    strict
    language plpgsql
as
$$
<<main>>
    DECLARE
    table_name  NAME;
    schema_name NAME;
BEGIN
    SELECT relname, nspname
    INTO STRICT table_name, schema_name
    FROM pg_class c
             INNER JOIN pg_namespace n ON (n.OID = c.relnamespace)
    WHERE c.OID = main_table;

    RETURN QUERY
        SELECT format('%I.%I', h.schema_name, ci.hypertable_index_name),
               sum(pg_relation_size(c.oid))::bigint
        FROM pg_class c,
             pg_namespace n,
             _timescaledb_catalog.hypertable h,
             _timescaledb_catalog.chunk ch,
             _timescaledb_catalog.chunk_index ci
        WHERE ch.schema_name = n.nspname
          AND c.relnamespace = n.oid
          AND c.relname = ci.index_name
          AND ch.id = ci.chunk_id
          AND h.id = ci.hypertable_id
          AND h.schema_name = main.schema_name
          AND h.table_name = main.table_name
        GROUP BY h.schema_name, ci.hypertable_index_name;
END;
$$;

alter function indexes_relation_size(regclass) owner to postgres;

create function indexes_relation_size_pretty(main_table regclass)
    returns TABLE
            (
                index_name text,
                total_size text
            )
    stable
    strict
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT s.index_name,
               pg_size_pretty(s.total_bytes)
        FROM public.indexes_relation_size(main_table) s;
END;
$$;

alter function indexes_relation_size_pretty(regclass) owner to postgres;

create function hypertable_approximate_row_count(main_table regclass DEFAULT NULL::regclass)
    returns TABLE
            (
                schema_name  name,
                table_name   name,
                row_estimate bigint
            )
    language plpgsql
as
$$
<<main>>
    DECLARE
    table_name  NAME;
    schema_name NAME;
BEGIN
    IF main_table IS NOT NULL THEN
        SELECT relname, nspname
        INTO STRICT table_name, schema_name
        FROM pg_class c
                 INNER JOIN pg_namespace n ON (n.OID = c.relnamespace)
        WHERE c.OID = main_table;
    END IF;

    -- Thanks to @fvannee on Github for providing the initial draft
-- of this query
    RETURN QUERY
        SELECT h.schema_name,
               h.table_name,
               row_estimate.row_estimate
        FROM _timescaledb_catalog.hypertable h
                 CROSS JOIN LATERAL (
            SELECT sum(cl.reltuples)::BIGINT AS row_estimate
            FROM _timescaledb_catalog.chunk c
                     JOIN pg_class cl ON cl.relname = c.table_name
            WHERE c.hypertable_id = h.id
            GROUP BY h.schema_name, h.table_name
            ) row_estimate
        WHERE (main.table_name IS NULL OR h.table_name = main.table_name)
          AND (main.schema_name IS NULL OR h.schema_name = main.schema_name)
        ORDER BY h.schema_name, h.table_name;
END
$$;

alter function hypertable_approximate_row_count(regclass) owner to postgres;

create function _timescaledb_internal.hist_sfunc(state internal, val double precision, min double precision,
                                                 max double precision, nbuckets integer)
    immutable
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.hist_sfunc(internal, double precision, double precision, double precision, integer) owner to postgres;

create function _timescaledb_internal.hist_combinefunc(state1 internal, state2 internal)
    immutable
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.hist_combinefunc(internal, internal) owner to postgres;

create function _timescaledb_internal.hist_serializefunc(internal)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.hist_serializefunc(internal) owner to postgres;

create function _timescaledb_internal.hist_deserializefunc(bytea, internal)
    immutable
    strict
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.hist_deserializefunc(bytea, internal) owner to postgres;

create function _timescaledb_internal.hist_finalfunc(state internal, val double precision, min double precision,
                                                     max double precision, nbuckets integer)
    immutable
    parallel safe
    language c
as -- missing source code
;

alter function _timescaledb_internal.hist_finalfunc(internal, double precision, double precision, double precision, integer) owner to postgres;

create function _timescaledb_internal.stop_background_workers()
    language c
as -- missing source code
;

alter function _timescaledb_internal.stop_background_workers() owner to postgres;

create function _timescaledb_internal.start_background_workers()
    language c
as -- missing source code
;

alter function _timescaledb_internal.start_background_workers() owner to postgres;

create function add_drop_chunks_policy(hypertable regclass, older_than interval, cascade boolean default false,
                                       if_not_exists boolean default false,
                                       cascade_to_materializations boolean default false)
    strict
    language c
as -- missing source code
;

alter function add_drop_chunks_policy(regclass, interval, boolean, boolean, boolean) owner to postgres;

create function add_reorder_policy(hypertable regclass, index_name name, if_not_exists boolean default false)
    strict
    language c
as -- missing source code
;

alter function add_reorder_policy(regclass, name, boolean) owner to postgres;

create function remove_drop_chunks_policy(hypertable regclass, if_exists boolean default false)
    strict
    language c
as -- missing source code
;

alter function remove_drop_chunks_policy(regclass, boolean) owner to postgres;

create function remove_reorder_policy(hypertable regclass, if_exists boolean default false)
    strict
    language c
as -- missing source code
;

alter function remove_reorder_policy(regclass, boolean) owner to postgres;

create function alter_job_schedule(job_id integer, schedule_interval interval default NULL::interval,
                                   max_runtime interval default NULL::interval,
                                   max_retries integer default NULL::integer,
                                   retry_period interval default NULL::interval, if_exists boolean default false)
    language c
as -- missing source code
;

alter function alter_job_schedule(integer, interval, interval, integer, interval, boolean) owner to postgres;

create function _timescaledb_internal.generate_uuid()
    strict
    language c
as -- missing source code
;

alter function _timescaledb_internal.generate_uuid() owner to postgres;

create function time_bucket_gapfill(bucket_width smallint, ts smallint, start smallint default NULL::smallint,
                                    finish smallint default NULL::smallint)
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket_gapfill(smallint, smallint, smallint, smallint) owner to postgres;

create function time_bucket_gapfill(bucket_width integer, ts integer, start integer default NULL::integer,
                                    finish integer default NULL::integer)
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket_gapfill(integer, integer, integer, integer) owner to postgres;

create function time_bucket_gapfill(bucket_width bigint, ts bigint, start bigint default NULL::bigint,
                                    finish bigint default NULL::bigint)
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket_gapfill(bigint, bigint, bigint, bigint) owner to postgres;

create function time_bucket_gapfill(bucket_width interval, ts date, start date default NULL::date,
                                    finish date default NULL::date)
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket_gapfill(interval, date, date, date) owner to postgres;

create function time_bucket_gapfill(bucket_width interval, ts timestamp,
                                    start timestamp default NULL::timestamp without time zone,
                                    finish timestamp default NULL::timestamp without time zone)
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket_gapfill(interval, timestamp, timestamp, timestamp) owner to postgres;

create function time_bucket_gapfill(bucket_width interval, ts timestamp with time zone,
                                    start timestamp with time zone default NULL::timestamp with time zone,
                                    finish timestamp with time zone default NULL::timestamp with time zone)
    parallel safe
    language c
as -- missing source code
;

alter function time_bucket_gapfill(interval, timestamp with time zone, timestamp with time zone, timestamp with time zone) owner to postgres;

create function locf(value anyelement, prev anyelement default NULL::unknown,
                     treat_null_as_missing boolean default false)
    parallel safe
    language c
as -- missing source code
;

alter function locf(anyelement, anyelement, boolean) owner to postgres;

create function interpolate(value smallint, prev record default NULL::record, next record default NULL::record)
    parallel safe
    language c
as -- missing source code
;

alter function interpolate(smallint, record, record) owner to postgres;

create function interpolate(value integer, prev record default NULL::record, next record default NULL::record)
    parallel safe
    language c
as -- missing source code
;

alter function interpolate(integer, record, record) owner to postgres;

create function interpolate(value bigint, prev record default NULL::record, next record default NULL::record)
    parallel safe
    language c
as -- missing source code
;

alter function interpolate(bigint, record, record) owner to postgres;

create function interpolate(value real, prev record default NULL::record, next record default NULL::record)
    parallel safe
    language c
as -- missing source code
;

alter function interpolate(real, record, record) owner to postgres;

create function interpolate(value double precision, prev record default NULL::record, next record default NULL::record)
    parallel safe
    language c
as -- missing source code
;

alter function interpolate(double precision, record, record) owner to postgres;

create function reorder_chunk(chunk regclass, index regclass default NULL::regclass, "verbose" boolean default false)
    language c
as -- missing source code
;

alter function reorder_chunk(regclass, regclass, boolean) owner to postgres;

create function _timescaledb_internal.partialize_agg(arg anyelement)
    language c
as -- missing source code
;

alter function _timescaledb_internal.partialize_agg(anyelement) owner to postgres;

create function _timescaledb_internal.finalize_agg_sfunc(tstate internal, aggfn text, inner_agg_collation_schema name,
                                                         inner_agg_collation_name name, inner_agg_input_types name[],
                                                         inner_agg_serialized_state bytea,
                                                         return_type_dummy_val anyelement)
    immutable
    language c
as -- missing source code
;

alter function _timescaledb_internal.finalize_agg_sfunc(internal, text, name, name, name[], bytea, anyelement) owner to postgres;

create function _timescaledb_internal.finalize_agg_ffunc(tstate internal, aggfn text, inner_agg_collation_schema name,
                                                         inner_agg_collation_name name, inner_agg_input_types name[],
                                                         inner_agg_serialized_state bytea,
                                                         return_type_dummy_val anyelement)
    immutable
    language c
as -- missing source code
;

alter function _timescaledb_internal.finalize_agg_ffunc(internal, text, name, name, name[], bytea, anyelement) owner to postgres;

create function timescaledb_pre_restore() returns boolean
    language plpgsql
as
$fun$
DECLARE
    db text;
BEGIN
    SELECT current_database() INTO db;
    EXECUTE format($$ALTER DATABASE %I SET timescaledb.restoring ='on'$$, db);
    SET SESSION timescaledb.restoring = 'on';
    PERFORM _timescaledb_internal.stop_background_workers();
    RETURN true;
END
$fun$;

alter function timescaledb_pre_restore() owner to postgres;

create function timescaledb_post_restore() returns boolean
    language plpgsql
as
$fun$
DECLARE
    db text;
BEGIN
    SELECT current_database() INTO db;
    EXECUTE format($$ALTER DATABASE %I SET timescaledb.restoring ='off'$$, db);
    SET SESSION timescaledb.restoring = 'off';
    PERFORM _timescaledb_internal.start_background_workers();
    RETURN true;
END
$fun$;

alter function timescaledb_post_restore() owner to postgres;

create operator pg_catalog.= (procedure = int48eq, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.=(integer , bigint) is 'equal';

alter operator pg_catalog.=(integer, bigint) owner to postgres;

create operator pg_catalog.<> (procedure = int48ne, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<>(integer , bigint) is 'not equal';

alter operator pg_catalog.<>(integer, bigint) owner to postgres;

create operator pg_catalog.< (procedure = int48lt, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<(integer , bigint) is 'less than';

alter operator pg_catalog.<(integer, bigint) owner to postgres;

create operator pg_catalog.< (procedure = boollt, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<(boolean , boolean) is 'less than';

alter operator pg_catalog.<(boolean, boolean) owner to postgres;

create operator pg_catalog.> (procedure = boolgt, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.>(boolean , boolean) is 'greater than';

alter operator pg_catalog.>(boolean, boolean) owner to postgres;

create operator pg_catalog.> (procedure = int48gt, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.>(integer , bigint) is 'greater than';

alter operator pg_catalog.>(integer, bigint) owner to postgres;

create operator pg_catalog.<= (procedure = int48le, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.<=(integer , bigint) is 'less than or equal';

alter operator pg_catalog.<=(integer, bigint) owner to postgres;

create operator pg_catalog.>= (procedure = int48ge, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.>=(integer , bigint) is 'greater than or equal';

alter operator pg_catalog.>=(integer, bigint) owner to postgres;

create operator pg_catalog.<> (procedure = boolne, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<>(boolean , boolean) is 'not equal';

alter operator pg_catalog.<>(boolean, boolean) owner to postgres;

create operator pg_catalog.= (procedure = booleq, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.=(boolean , boolean) is 'equal';

alter operator pg_catalog.=(boolean, boolean) owner to postgres;

create operator pg_catalog.= (procedure = chareq, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.=("char" , "char") is 'equal';

alter operator pg_catalog.=("char", "char") owner to postgres;

create operator pg_catalog.= (procedure = nameeq, leftarg = name, rightarg = name);

comment on operator pg_catalog.=(name , name) is 'equal';

alter operator pg_catalog.=(name, name) owner to postgres;

create operator pg_catalog.= (procedure = int2eq, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.=(smallint , smallint) is 'equal';

alter operator pg_catalog.=(smallint, smallint) owner to postgres;

create operator pg_catalog.< (procedure = int2lt, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<(smallint , smallint) is 'less than';

alter operator pg_catalog.<(smallint, smallint) owner to postgres;

create operator pg_catalog.= (procedure = int4eq, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.=(integer , integer) is 'equal';

alter operator pg_catalog.=(integer, integer) owner to postgres;

create operator pg_catalog.< (procedure = int4lt, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<(integer , integer) is 'less than';

alter operator pg_catalog.<(integer, integer) owner to postgres;

create operator pg_catalog.= (procedure = texteq, leftarg = text, rightarg = text);

comment on operator pg_catalog.=(text , text) is 'equal';

alter operator pg_catalog.=(text, text) owner to postgres;

create operator pg_catalog.|| (procedure = array_append, leftarg = anyarray, rightarg = anyelement);

comment on operator pg_catalog.||(anyarray , anyelement) is 'append element onto end of array';

alter operator pg_catalog.||(anyarray, anyelement) owner to postgres;

create operator pg_catalog.= (procedure = xideq, leftarg = xid, rightarg = xid);

comment on operator pg_catalog.=(xid , xid) is 'equal';

alter operator pg_catalog.=(xid, xid) owner to postgres;

create operator pg_catalog.= (procedure = xideqint4, leftarg = xid, rightarg = integer);

comment on operator pg_catalog.=(xid , integer) is 'equal';

alter operator pg_catalog.=(xid, integer) owner to postgres;

create operator pg_catalog.|| (procedure = array_prepend, leftarg = anyelement, rightarg = anyarray);

comment on operator pg_catalog.||(anyelement , anyarray) is 'prepend element onto front of array';

alter operator pg_catalog.||(anyelement, anyarray) owner to postgres;

create operator pg_catalog.|| (procedure = array_cat, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.||(anyarray , anyarray) is 'concatenate';

alter operator pg_catalog.||(anyarray, anyarray) owner to postgres;

create operator pg_catalog.= (procedure = cideq, leftarg = cid, rightarg = cid);

comment on operator pg_catalog.=(cid , cid) is 'equal';

alter operator pg_catalog.=(cid, cid) owner to postgres;

create operator pg_catalog.= (procedure = int2vectoreq, leftarg = int2vector, rightarg = int2vector);

comment on operator pg_catalog.=(int2vector , int2vector) is 'equal';

alter operator pg_catalog.=(int2vector, int2vector) owner to postgres;

create operator pg_catalog.= (procedure = tideq, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.=(tid , tid) is 'equal';

alter operator pg_catalog.=(tid, tid) owner to postgres;

create operator pg_catalog.! (procedure = numeric_fac, leftarg = bigint);

comment on operator pg_catalog.!(bigint , none) is 'factorial';

alter operator pg_catalog.!(bigint, none) owner to postgres;

create operator pg_catalog.!! (procedure = numeric_fac, rightarg = bigint);

comment on operator pg_catalog.!!(none , bigint) is 'deprecated, use ! instead';

alter operator pg_catalog.!!(none, bigint) owner to postgres;

create operator pg_catalog.<> (procedure = tidne, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<>(tid , tid) is 'not equal';

alter operator pg_catalog.<>(tid, tid) owner to postgres;

create operator pg_catalog.= (procedure = int8eq, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.=(bigint , bigint) is 'equal';

alter operator pg_catalog.=(bigint, bigint) owner to postgres;

create operator pg_catalog.<> (procedure = int8ne, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<>(bigint , bigint) is 'not equal';

alter operator pg_catalog.<>(bigint, bigint) owner to postgres;

create operator pg_catalog.< (procedure = int8lt, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<(bigint , bigint) is 'less than';

alter operator pg_catalog.<(bigint, bigint) owner to postgres;

create operator pg_catalog.> (procedure = int8gt, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.>(bigint , bigint) is 'greater than';

alter operator pg_catalog.>(bigint, bigint) owner to postgres;

create operator pg_catalog.<= (procedure = int8le, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.<=(bigint , bigint) is 'less than or equal';

alter operator pg_catalog.<=(bigint, bigint) owner to postgres;

create operator pg_catalog.>= (procedure = int8ge, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.>=(bigint , bigint) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, bigint) owner to postgres;

create operator pg_catalog.= (procedure = int84eq, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.=(bigint , integer) is 'equal';

alter operator pg_catalog.=(bigint, integer) owner to postgres;

create operator pg_catalog.<> (procedure = int84ne, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<>(bigint , integer) is 'not equal';

alter operator pg_catalog.<>(bigint, integer) owner to postgres;

create operator pg_catalog.< (procedure = int84lt, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<(bigint , integer) is 'less than';

alter operator pg_catalog.<(bigint, integer) owner to postgres;

create operator pg_catalog.> (procedure = int84gt, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>(bigint , integer) is 'greater than';

alter operator pg_catalog.>(bigint, integer) owner to postgres;

create operator pg_catalog.<= (procedure = int84le, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<=(bigint , integer) is 'less than or equal';

alter operator pg_catalog.<=(bigint, integer) owner to postgres;

create operator pg_catalog.>= (procedure = int84ge, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>=(bigint , integer) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, integer) owner to postgres;

create operator pg_catalog.@> (procedure = box_contain_pt, leftarg = box, rightarg = point);

comment on operator pg_catalog.@>(box , point) is 'contains';

alter operator pg_catalog.@>(box, point) owner to postgres;

create operator pg_catalog.% (procedure = int8mod, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.%(bigint , bigint) is 'modulus';

alter operator pg_catalog.%(bigint, bigint) owner to postgres;

create operator pg_catalog.@ (procedure = int8abs, rightarg = bigint);

comment on operator pg_catalog.@(none , bigint) is 'absolute value';

alter operator pg_catalog.@(none, bigint) owner to postgres;

create operator pg_catalog.- (procedure = int8um, rightarg = bigint);

comment on operator pg_catalog.-(none , bigint) is 'negate';

alter operator pg_catalog.-(none, bigint) owner to postgres;

create operator pg_catalog.<< (procedure = poly_left, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<<(polygon , polygon) is 'is left of';

alter operator pg_catalog.<<(polygon, polygon) owner to postgres;

create operator pg_catalog.&< (procedure = poly_overleft, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&<(polygon , polygon) is 'overlaps or is left of';

alter operator pg_catalog.&<(polygon, polygon) owner to postgres;

create operator pg_catalog.&> (procedure = poly_overright, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&>(polygon , polygon) is 'overlaps or is right of';

alter operator pg_catalog.&>(polygon, polygon) owner to postgres;

create operator pg_catalog.>> (procedure = poly_right, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.>>(polygon , polygon) is 'is right of';

alter operator pg_catalog.>>(polygon, polygon) owner to postgres;

create operator pg_catalog.<@ (procedure = poly_contained, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<@(polygon , polygon) is 'is contained by';

alter operator pg_catalog.<@(polygon, polygon) owner to postgres;

create operator pg_catalog.@> (procedure = poly_contain, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.@>(polygon , polygon) is 'contains';

alter operator pg_catalog.@>(polygon, polygon) owner to postgres;

create operator pg_catalog.~= (procedure = poly_same, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.~=(polygon , polygon) is 'same as';

alter operator pg_catalog.~=(polygon, polygon) owner to postgres;

create operator pg_catalog.&& (procedure = poly_overlap, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&&(polygon , polygon) is 'overlaps';

alter operator pg_catalog.&&(polygon, polygon) owner to postgres;

create operator pg_catalog.<< (procedure = box_left, leftarg = box, rightarg = box);

comment on operator pg_catalog.<<(box , box) is 'is left of';

alter operator pg_catalog.<<(box, box) owner to postgres;

create operator pg_catalog.&< (procedure = box_overleft, leftarg = box, rightarg = box);

comment on operator pg_catalog.&<(box , box) is 'overlaps or is left of';

alter operator pg_catalog.&<(box, box) owner to postgres;

create operator pg_catalog.&> (procedure = box_overright, leftarg = box, rightarg = box);

comment on operator pg_catalog.&>(box , box) is 'overlaps or is right of';

alter operator pg_catalog.&>(box, box) owner to postgres;

create operator pg_catalog.>> (procedure = box_right, leftarg = box, rightarg = box);

comment on operator pg_catalog.>>(box , box) is 'is right of';

alter operator pg_catalog.>>(box, box) owner to postgres;

create operator pg_catalog.<@ (procedure = box_contained, leftarg = box, rightarg = box);

comment on operator pg_catalog.<@(box , box) is 'is contained by';

alter operator pg_catalog.<@(box, box) owner to postgres;

create operator pg_catalog.@> (procedure = box_contain, leftarg = box, rightarg = box);

comment on operator pg_catalog.@>(box , box) is 'contains';

alter operator pg_catalog.@>(box, box) owner to postgres;

create operator pg_catalog.~= (procedure = box_same, leftarg = box, rightarg = box);

comment on operator pg_catalog.~=(box , box) is 'same as';

alter operator pg_catalog.~=(box, box) owner to postgres;

create operator pg_catalog.&& (procedure = box_overlap, leftarg = box, rightarg = box);

comment on operator pg_catalog.&&(box , box) is 'overlaps';

alter operator pg_catalog.&&(box, box) owner to postgres;

create operator pg_catalog.>= (procedure = box_ge, leftarg = box, rightarg = box);

comment on operator pg_catalog.>=(box , box) is 'greater than or equal by area';

alter operator pg_catalog.>=(box, box) owner to postgres;

create operator pg_catalog.> (procedure = box_gt, leftarg = box, rightarg = box);

comment on operator pg_catalog.>(box , box) is 'greater than by area';

alter operator pg_catalog.>(box, box) owner to postgres;

create operator pg_catalog.= (procedure = box_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.=(box , box) is 'equal by area';

alter operator pg_catalog.=(box, box) owner to postgres;

create operator pg_catalog.< (procedure = box_lt, leftarg = box, rightarg = box);

comment on operator pg_catalog.<(box , box) is 'less than by area';

alter operator pg_catalog.<(box, box) owner to postgres;

create operator pg_catalog.<= (procedure = box_le, leftarg = box, rightarg = box);

comment on operator pg_catalog.<=(box , box) is 'less than or equal by area';

alter operator pg_catalog.<=(box, box) owner to postgres;

create operator pg_catalog.>^ (procedure = point_above, leftarg = point, rightarg = point);

comment on operator pg_catalog.>^(point , point) is 'is above';

alter operator pg_catalog.>^(point, point) owner to postgres;

create operator pg_catalog.<< (procedure = point_left, leftarg = point, rightarg = point);

comment on operator pg_catalog.<<(point , point) is 'is left of';

alter operator pg_catalog.<<(point, point) owner to postgres;

create operator pg_catalog.>> (procedure = point_right, leftarg = point, rightarg = point);

comment on operator pg_catalog.>>(point , point) is 'is right of';

alter operator pg_catalog.>>(point, point) owner to postgres;

create operator pg_catalog.<^ (procedure = point_below, leftarg = point, rightarg = point);

comment on operator pg_catalog.<^(point , point) is 'is below';

alter operator pg_catalog.<^(point, point) owner to postgres;

create operator pg_catalog.~= (procedure = point_eq, leftarg = point, rightarg = point);

comment on operator pg_catalog.~=(point , point) is 'same as';

alter operator pg_catalog.~=(point, point) owner to postgres;

create operator pg_catalog.<@ (procedure = on_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.<@(point , box) is 'point inside box';

alter operator pg_catalog.<@(point, box) owner to postgres;

create operator pg_catalog.<@ (procedure = on_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.<@(point , path) is 'point within closed path, or point on open path';

alter operator pg_catalog.<@(point, path) owner to postgres;

create operator pg_catalog.@@ (procedure = box_center, rightarg = box);

comment on operator pg_catalog.@@(none , box) is 'center of';

alter operator pg_catalog.@@(none, box) owner to postgres;

create operator pg_catalog.* (procedure = int4mul, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.*(integer , integer) is 'multiply';

alter operator pg_catalog.*(integer, integer) owner to postgres;

create operator pg_catalog.<-> (procedure = point_distance, leftarg = point, rightarg = point);

comment on operator pg_catalog.<->(point , point) is 'distance between';

alter operator pg_catalog.<->(point, point) owner to postgres;

create operator pg_catalog.<> (procedure = int4ne, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<>(integer , integer) is 'not equal';

alter operator pg_catalog.<>(integer, integer) owner to postgres;

create operator pg_catalog.<> (procedure = int2ne, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<>(smallint , smallint) is 'not equal';

alter operator pg_catalog.<>(smallint, smallint) owner to postgres;

create operator pg_catalog.> (procedure = int2gt, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.>(smallint , smallint) is 'greater than';

alter operator pg_catalog.>(smallint, smallint) owner to postgres;

create operator pg_catalog.> (procedure = int4gt, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>(integer , integer) is 'greater than';

alter operator pg_catalog.>(integer, integer) owner to postgres;

create operator pg_catalog.<= (procedure = int2le, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.<=(smallint , smallint) is 'less than or equal';

alter operator pg_catalog.<=(smallint, smallint) owner to postgres;

create operator pg_catalog.<= (procedure = int4le, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<=(integer , integer) is 'less than or equal';

alter operator pg_catalog.<=(integer, integer) owner to postgres;

create operator pg_catalog.>= (procedure = int2ge, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.>=(smallint , smallint) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, smallint) owner to postgres;

create operator pg_catalog.>= (procedure = int4ge, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>=(integer , integer) is 'greater than or equal';

alter operator pg_catalog.>=(integer, integer) owner to postgres;

create operator pg_catalog.* (procedure = int2mul, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.*(smallint , smallint) is 'multiply';

alter operator pg_catalog.*(smallint, smallint) owner to postgres;

create operator pg_catalog./ (procedure = int2div, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog./(smallint , smallint) is 'divide';

alter operator pg_catalog./(smallint, smallint) owner to postgres;

create operator pg_catalog./ (procedure = int4div, leftarg = integer, rightarg = integer);

comment on operator pg_catalog./(integer , integer) is 'divide';

alter operator pg_catalog./(integer, integer) owner to postgres;

create operator pg_catalog.% (procedure = int2mod, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.%(smallint , smallint) is 'modulus';

alter operator pg_catalog.%(smallint, smallint) owner to postgres;

create operator pg_catalog.% (procedure = int4mod, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.%(integer , integer) is 'modulus';

alter operator pg_catalog.%(integer, integer) owner to postgres;

create operator pg_catalog.<> (procedure = textne, leftarg = text, rightarg = text);

comment on operator pg_catalog.<>(text , text) is 'not equal';

alter operator pg_catalog.<>(text, text) owner to postgres;

create operator pg_catalog.= (procedure = int24eq, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.=(smallint , integer) is 'equal';

alter operator pg_catalog.=(smallint, integer) owner to postgres;

create operator pg_catalog.= (procedure = int42eq, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.=(integer , smallint) is 'equal';

alter operator pg_catalog.=(integer, smallint) owner to postgres;

create operator pg_catalog.< (procedure = int24lt, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<(smallint , integer) is 'less than';

alter operator pg_catalog.<(smallint, integer) owner to postgres;

create operator pg_catalog.< (procedure = int42lt, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<(integer , smallint) is 'less than';

alter operator pg_catalog.<(integer, smallint) owner to postgres;

create operator pg_catalog.> (procedure = int24gt, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>(smallint , integer) is 'greater than';

alter operator pg_catalog.>(smallint, integer) owner to postgres;

create operator pg_catalog.> (procedure = int42gt, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.>(integer , smallint) is 'greater than';

alter operator pg_catalog.>(integer, smallint) owner to postgres;

create operator pg_catalog.<> (procedure = int24ne, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<>(smallint , integer) is 'not equal';

alter operator pg_catalog.<>(smallint, integer) owner to postgres;

create operator pg_catalog.<> (procedure = int42ne, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<>(integer , smallint) is 'not equal';

alter operator pg_catalog.<>(integer, smallint) owner to postgres;

create operator pg_catalog.<= (procedure = int24le, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<=(smallint , integer) is 'less than or equal';

alter operator pg_catalog.<=(smallint, integer) owner to postgres;

create operator pg_catalog.<= (procedure = int42le, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.<=(integer , smallint) is 'less than or equal';

alter operator pg_catalog.<=(integer, smallint) owner to postgres;

create operator pg_catalog.>= (procedure = int24ge, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>=(smallint , integer) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, integer) owner to postgres;

create operator pg_catalog.>= (procedure = int42ge, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.>=(integer , smallint) is 'greater than or equal';

alter operator pg_catalog.>=(integer, smallint) owner to postgres;

create operator pg_catalog.* (procedure = int24mul, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.*(smallint , integer) is 'multiply';

alter operator pg_catalog.*(smallint, integer) owner to postgres;

create operator pg_catalog.* (procedure = int42mul, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.*(integer , smallint) is 'multiply';

alter operator pg_catalog.*(integer, smallint) owner to postgres;

create operator pg_catalog./ (procedure = int24div, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog./(smallint , integer) is 'divide';

alter operator pg_catalog./(smallint, integer) owner to postgres;

create operator pg_catalog./ (procedure = int42div, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog./(integer , smallint) is 'divide';

alter operator pg_catalog./(integer, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = int2pl, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.+(smallint , smallint) is 'add';

alter operator pg_catalog.+(smallint, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = int4pl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.+(integer , integer) is 'add';

alter operator pg_catalog.+(integer, integer) owner to postgres;

create operator pg_catalog.+ (procedure = int24pl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.+(smallint , integer) is 'add';

alter operator pg_catalog.+(smallint, integer) owner to postgres;

create operator pg_catalog.+ (procedure = int42pl, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.+(integer , smallint) is 'add';

alter operator pg_catalog.+(integer, smallint) owner to postgres;

create operator pg_catalog.- (procedure = int2mi, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.-(smallint , smallint) is 'subtract';

alter operator pg_catalog.-(smallint, smallint) owner to postgres;

create operator pg_catalog.- (procedure = int4mi, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.-(integer , integer) is 'subtract';

alter operator pg_catalog.-(integer, integer) owner to postgres;

create operator pg_catalog.- (procedure = int24mi, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.-(smallint , integer) is 'subtract';

alter operator pg_catalog.-(smallint, integer) owner to postgres;

create operator pg_catalog.- (procedure = int42mi, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.-(integer , smallint) is 'subtract';

alter operator pg_catalog.-(integer, smallint) owner to postgres;

create operator pg_catalog.- (procedure = int4um, rightarg = integer);

comment on operator pg_catalog.-(none , integer) is 'negate';

alter operator pg_catalog.-(none, integer) owner to postgres;

create operator pg_catalog.- (procedure = int2um, rightarg = smallint);

comment on operator pg_catalog.-(none , smallint) is 'negate';

alter operator pg_catalog.-(none, smallint) owner to postgres;

create operator pg_catalog.= (procedure = abstimeeq, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.=(abstime , abstime) is 'equal';

alter operator pg_catalog.=(abstime, abstime) owner to postgres;

create operator pg_catalog.<> (procedure = abstimene, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<>(abstime , abstime) is 'not equal';

alter operator pg_catalog.<>(abstime, abstime) owner to postgres;

create operator pg_catalog.< (procedure = abstimelt, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<(abstime , abstime) is 'less than';

alter operator pg_catalog.<(abstime, abstime) owner to postgres;

create operator pg_catalog.> (procedure = abstimegt, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.>(abstime , abstime) is 'greater than';

alter operator pg_catalog.>(abstime, abstime) owner to postgres;

create operator pg_catalog.<= (procedure = abstimele, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<=(abstime , abstime) is 'less than or equal';

alter operator pg_catalog.<=(abstime, abstime) owner to postgres;

create operator pg_catalog.>= (procedure = abstimege, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.>=(abstime , abstime) is 'greater than or equal';

alter operator pg_catalog.>=(abstime, abstime) owner to postgres;

create operator pg_catalog.= (procedure = reltimeeq, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.=(reltime , reltime) is 'equal';

alter operator pg_catalog.=(reltime, reltime) owner to postgres;

create operator pg_catalog.<> (procedure = reltimene, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<>(reltime , reltime) is 'not equal';

alter operator pg_catalog.<>(reltime, reltime) owner to postgres;

create operator pg_catalog.< (procedure = reltimelt, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<(reltime , reltime) is 'less than';

alter operator pg_catalog.<(reltime, reltime) owner to postgres;

create operator pg_catalog.> (procedure = reltimegt, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.>(reltime , reltime) is 'greater than';

alter operator pg_catalog.>(reltime, reltime) owner to postgres;

create operator pg_catalog.<= (procedure = reltimele, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.<=(reltime , reltime) is 'less than or equal';

alter operator pg_catalog.<=(reltime, reltime) owner to postgres;

create operator pg_catalog.>= (procedure = reltimege, leftarg = reltime, rightarg = reltime);

comment on operator pg_catalog.>=(reltime , reltime) is 'greater than or equal';

alter operator pg_catalog.>=(reltime, reltime) owner to postgres;

create operator pg_catalog.~= (procedure = tintervalsame, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.~=(tinterval , tinterval) is 'same as';

alter operator pg_catalog.~=(tinterval, tinterval) owner to postgres;

create operator pg_catalog.<< (procedure = tintervalct, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<<(tinterval , tinterval) is 'contains';

alter operator pg_catalog.<<(tinterval, tinterval) owner to postgres;

create operator pg_catalog.&& (procedure = tintervalov, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.&&(tinterval , tinterval) is 'overlaps';

alter operator pg_catalog.&&(tinterval, tinterval) owner to postgres;

create operator pg_catalog.#= (procedure = tintervalleneq, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#=(tinterval , reltime) is 'equal by length';

alter operator pg_catalog.#=(tinterval, reltime) owner to postgres;

create operator pg_catalog.#<> (procedure = tintervallenne, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<>(tinterval , reltime) is 'not equal by length';

alter operator pg_catalog.#<>(tinterval, reltime) owner to postgres;

create operator pg_catalog.#< (procedure = tintervallenlt, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<(tinterval , reltime) is 'less than by length';

alter operator pg_catalog.#<(tinterval, reltime) owner to postgres;

create operator pg_catalog.#> (procedure = tintervallengt, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#>(tinterval , reltime) is 'greater than by length';

alter operator pg_catalog.#>(tinterval, reltime) owner to postgres;

create operator pg_catalog.#<= (procedure = tintervallenle, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#<=(tinterval , reltime) is 'less than or equal by length';

alter operator pg_catalog.#<=(tinterval, reltime) owner to postgres;

create operator pg_catalog.#>= (procedure = tintervallenge, leftarg = tinterval, rightarg = reltime);

comment on operator pg_catalog.#>=(tinterval , reltime) is 'greater than or equal by length';

alter operator pg_catalog.#>=(tinterval, reltime) owner to postgres;

create operator pg_catalog.+ (procedure = timepl, leftarg = abstime, rightarg = reltime);

comment on operator pg_catalog.+(abstime , reltime) is 'add';

alter operator pg_catalog.+(abstime, reltime) owner to postgres;

create operator pg_catalog.- (procedure = timemi, leftarg = abstime, rightarg = reltime);

comment on operator pg_catalog.-(abstime , reltime) is 'subtract';

alter operator pg_catalog.-(abstime, reltime) owner to postgres;

create operator pg_catalog.<?> (procedure = intinterval, leftarg = abstime, rightarg = tinterval);

comment on operator pg_catalog.<?>(abstime , tinterval) is 'is contained by';

alter operator pg_catalog.<?>(abstime, tinterval) owner to postgres;

create operator pg_catalog.- (procedure = float4um, rightarg = real);

comment on operator pg_catalog.-(none , real) is 'negate';

alter operator pg_catalog.-(none, real) owner to postgres;

create operator pg_catalog.- (procedure = float8um, rightarg = double precision);

comment on operator pg_catalog.-(none , double precision) is 'negate';

alter operator pg_catalog.-(none, double precision) owner to postgres;

create operator pg_catalog.+ (procedure = float4pl, leftarg = real, rightarg = real);

comment on operator pg_catalog.+(real , real) is 'add';

alter operator pg_catalog.+(real, real) owner to postgres;

create operator pg_catalog.- (procedure = float4mi, leftarg = real, rightarg = real);

comment on operator pg_catalog.-(real , real) is 'subtract';

alter operator pg_catalog.-(real, real) owner to postgres;

create operator pg_catalog./ (procedure = float4div, leftarg = real, rightarg = real);

comment on operator pg_catalog./(real , real) is 'divide';

alter operator pg_catalog./(real, real) owner to postgres;

create operator pg_catalog.* (procedure = float4mul, leftarg = real, rightarg = real);

comment on operator pg_catalog.*(real , real) is 'multiply';

alter operator pg_catalog.*(real, real) owner to postgres;

create operator pg_catalog.@ (procedure = float4abs, rightarg = real);

comment on operator pg_catalog.@(none , real) is 'absolute value';

alter operator pg_catalog.@(none, real) owner to postgres;

create operator pg_catalog.+ (procedure = float8pl, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.+(double precision , double precision) is 'add';

alter operator pg_catalog.+(double precision, double precision) owner to postgres;

create operator pg_catalog.- (procedure = float8mi, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.-(double precision , double precision) is 'subtract';

alter operator pg_catalog.-(double precision, double precision) owner to postgres;

create operator pg_catalog./ (procedure = float8div, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog./(double precision , double precision) is 'divide';

alter operator pg_catalog./(double precision, double precision) owner to postgres;

create operator pg_catalog.* (procedure = float8mul, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.*(double precision , double precision) is 'multiply';

alter operator pg_catalog.*(double precision, double precision) owner to postgres;

create operator pg_catalog.@ (procedure = float8abs, rightarg = double precision);

comment on operator pg_catalog.@(none , double precision) is 'absolute value';

alter operator pg_catalog.@(none, double precision) owner to postgres;

create operator pg_catalog.|/ (procedure = dsqrt, rightarg = double precision);

comment on operator pg_catalog.|/(none , double precision) is 'square root';

alter operator pg_catalog.|/(none, double precision) owner to postgres;

create operator pg_catalog.||/ (procedure = dcbrt, rightarg = double precision);

comment on operator pg_catalog.||/(none , double precision) is 'cube root';

alter operator pg_catalog.||/(none, double precision) owner to postgres;

create operator pg_catalog.<#> (procedure = mktinterval, leftarg = abstime, rightarg = abstime);

comment on operator pg_catalog.<#>(abstime , abstime) is 'convert to tinterval';

alter operator pg_catalog.<#>(abstime, abstime) owner to postgres;

create operator pg_catalog.= (procedure = oideq, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.=(oid , oid) is 'equal';

alter operator pg_catalog.=(oid, oid) owner to postgres;

create operator pg_catalog.<> (procedure = oidne, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<>(oid , oid) is 'not equal';

alter operator pg_catalog.<>(oid, oid) owner to postgres;

create operator pg_catalog.< (procedure = oidlt, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<(oid , oid) is 'less than';

alter operator pg_catalog.<(oid, oid) owner to postgres;

create operator pg_catalog.> (procedure = oidgt, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.>(oid , oid) is 'greater than';

alter operator pg_catalog.>(oid, oid) owner to postgres;

create operator pg_catalog.<= (procedure = oidle, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.<=(oid , oid) is 'less than or equal';

alter operator pg_catalog.<=(oid, oid) owner to postgres;

create operator pg_catalog.>= (procedure = oidge, leftarg = oid, rightarg = oid);

comment on operator pg_catalog.>=(oid , oid) is 'greater than or equal';

alter operator pg_catalog.>=(oid, oid) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<->(point , line) is 'distance between';

alter operator pg_catalog.<->(point, line) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<->(point , lseg) is 'distance between';

alter operator pg_catalog.<->(point, lseg) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.<->(point , box) is 'distance between';

alter operator pg_catalog.<->(point, box) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<->(lseg , line) is 'distance between';

alter operator pg_catalog.<->(lseg, line) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<->(lseg , box) is 'distance between';

alter operator pg_catalog.<->(lseg, box) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.<->(point , path) is 'distance between';

alter operator pg_catalog.<->(point, path) owner to postgres;

create operator pg_catalog.= (procedure = float4eq, leftarg = real, rightarg = real);

comment on operator pg_catalog.=(real , real) is 'equal';

alter operator pg_catalog.=(real, real) owner to postgres;

create operator pg_catalog.<> (procedure = float4ne, leftarg = real, rightarg = real);

comment on operator pg_catalog.<>(real , real) is 'not equal';

alter operator pg_catalog.<>(real, real) owner to postgres;

create operator pg_catalog.< (procedure = float4lt, leftarg = real, rightarg = real);

comment on operator pg_catalog.<(real , real) is 'less than';

alter operator pg_catalog.<(real, real) owner to postgres;

create operator pg_catalog.> (procedure = float4gt, leftarg = real, rightarg = real);

comment on operator pg_catalog.>(real , real) is 'greater than';

alter operator pg_catalog.>(real, real) owner to postgres;

create operator pg_catalog.<= (procedure = float4le, leftarg = real, rightarg = real);

comment on operator pg_catalog.<=(real , real) is 'less than or equal';

alter operator pg_catalog.<=(real, real) owner to postgres;

create operator pg_catalog.>= (procedure = float4ge, leftarg = real, rightarg = real);

comment on operator pg_catalog.>=(real , real) is 'greater than or equal';

alter operator pg_catalog.>=(real, real) owner to postgres;

create operator pg_catalog.<> (procedure = charne, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<>("char" , "char") is 'not equal';

alter operator pg_catalog.<>("char", "char") owner to postgres;

create operator pg_catalog.< (procedure = charlt, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<("char" , "char") is 'less than';

alter operator pg_catalog.<("char", "char") owner to postgres;

create operator pg_catalog.<= (procedure = charle, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.<=("char" , "char") is 'less than or equal';

alter operator pg_catalog.<=("char", "char") owner to postgres;

create operator pg_catalog.> (procedure = chargt, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.>("char" , "char") is 'greater than';

alter operator pg_catalog.>("char", "char") owner to postgres;

create operator pg_catalog.>= (procedure = charge, leftarg = "char", rightarg = "char");

comment on operator pg_catalog.>=("char" , "char") is 'greater than or equal';

alter operator pg_catalog.>=("char", "char") owner to postgres;

create operator pg_catalog.~ (procedure = nameregexeq, leftarg = name, rightarg = text);

comment on operator pg_catalog.~(name , text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(name, text) owner to postgres;

create operator pg_catalog.!~ (procedure = nameregexne, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~(name , text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(name, text) owner to postgres;

create operator pg_catalog.~ (procedure = textregexeq, leftarg = text, rightarg = text);

comment on operator pg_catalog.~(text , text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(text, text) owner to postgres;

create operator pg_catalog.!~ (procedure = textregexne, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~(text , text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(text, text) owner to postgres;

create operator pg_catalog.<> (procedure = namene, leftarg = name, rightarg = name);

comment on operator pg_catalog.<>(name , name) is 'not equal';

alter operator pg_catalog.<>(name, name) owner to postgres;

create operator pg_catalog.<> (procedure = oidvectorne, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<>(oidvector , oidvector) is 'not equal';

alter operator pg_catalog.<>(oidvector, oidvector) owner to postgres;

create operator pg_catalog.< (procedure = oidvectorlt, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<(oidvector , oidvector) is 'less than';

alter operator pg_catalog.<(oidvector, oidvector) owner to postgres;

create operator pg_catalog.> (procedure = oidvectorgt, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.>(oidvector , oidvector) is 'greater than';

alter operator pg_catalog.>(oidvector, oidvector) owner to postgres;

create operator pg_catalog.<= (procedure = oidvectorle, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.<=(oidvector , oidvector) is 'less than or equal';

alter operator pg_catalog.<=(oidvector, oidvector) owner to postgres;

create operator pg_catalog.>= (procedure = oidvectorge, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.>=(oidvector , oidvector) is 'greater than or equal';

alter operator pg_catalog.>=(oidvector, oidvector) owner to postgres;

create operator pg_catalog.= (procedure = oidvectoreq, leftarg = oidvector, rightarg = oidvector);

comment on operator pg_catalog.=(oidvector , oidvector) is 'equal';

alter operator pg_catalog.=(oidvector, oidvector) owner to postgres;

create operator pg_catalog.|| (procedure = textcat, leftarg = text, rightarg = text);

comment on operator pg_catalog.||(text , text) is 'concatenate';

alter operator pg_catalog.||(text, text) owner to postgres;

create operator pg_catalog.< (procedure = namelt, leftarg = name, rightarg = name);

comment on operator pg_catalog.<(name , name) is 'less than';

alter operator pg_catalog.<(name, name) owner to postgres;

create operator pg_catalog.<= (procedure = namele, leftarg = name, rightarg = name);

comment on operator pg_catalog.<=(name , name) is 'less than or equal';

alter operator pg_catalog.<=(name, name) owner to postgres;

create operator pg_catalog.> (procedure = namegt, leftarg = name, rightarg = name);

comment on operator pg_catalog.>(name , name) is 'greater than';

alter operator pg_catalog.>(name, name) owner to postgres;

create operator pg_catalog.>= (procedure = namege, leftarg = name, rightarg = name);

comment on operator pg_catalog.>=(name , name) is 'greater than or equal';

alter operator pg_catalog.>=(name, name) owner to postgres;

create operator pg_catalog.< (procedure = text_lt, leftarg = text, rightarg = text);

comment on operator pg_catalog.<(text , text) is 'less than';

alter operator pg_catalog.<(text, text) owner to postgres;

create operator pg_catalog.<= (procedure = text_le, leftarg = text, rightarg = text);

comment on operator pg_catalog.<=(text , text) is 'less than or equal';

alter operator pg_catalog.<=(text, text) owner to postgres;

create operator pg_catalog.> (procedure = text_gt, leftarg = text, rightarg = text);

comment on operator pg_catalog.>(text , text) is 'greater than';

alter operator pg_catalog.>(text, text) owner to postgres;

create operator pg_catalog.>= (procedure = text_ge, leftarg = text, rightarg = text);

comment on operator pg_catalog.>=(text , text) is 'greater than or equal';

alter operator pg_catalog.>=(text, text) owner to postgres;

create operator pg_catalog.= (procedure = float8eq, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.=(double precision , double precision) is 'equal';

alter operator pg_catalog.=(double precision, double precision) owner to postgres;

create operator pg_catalog.<> (procedure = float8ne, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<>(double precision , double precision) is 'not equal';

alter operator pg_catalog.<>(double precision, double precision) owner to postgres;

create operator pg_catalog.< (procedure = float8lt, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<(double precision , double precision) is 'less than';

alter operator pg_catalog.<(double precision, double precision) owner to postgres;

create operator pg_catalog.<= (procedure = float8le, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.<=(double precision , double precision) is 'less than or equal';

alter operator pg_catalog.<=(double precision, double precision) owner to postgres;

create operator pg_catalog.> (procedure = float8gt, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.>(double precision , double precision) is 'greater than';

alter operator pg_catalog.>(double precision, double precision) owner to postgres;

create operator pg_catalog.>= (procedure = float8ge, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.>=(double precision , double precision) is 'greater than or equal';

alter operator pg_catalog.>=(double precision, double precision) owner to postgres;

create operator pg_catalog.@ (procedure = int2abs, rightarg = smallint);

comment on operator pg_catalog.@(none , smallint) is 'absolute value';

alter operator pg_catalog.@(none, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = int8pl, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.+(bigint , bigint) is 'add';

alter operator pg_catalog.+(bigint, bigint) owner to postgres;

create operator pg_catalog.- (procedure = int8mi, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.-(bigint , bigint) is 'subtract';

alter operator pg_catalog.-(bigint, bigint) owner to postgres;

create operator pg_catalog.* (procedure = int8mul, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.*(bigint , bigint) is 'multiply';

alter operator pg_catalog.*(bigint, bigint) owner to postgres;

create operator pg_catalog./ (procedure = int8div, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog./(bigint , bigint) is 'divide';

alter operator pg_catalog./(bigint, bigint) owner to postgres;

create operator pg_catalog.+ (procedure = int84pl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.+(bigint , integer) is 'add';

alter operator pg_catalog.+(bigint, integer) owner to postgres;

create operator pg_catalog.- (procedure = int84mi, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.-(bigint , integer) is 'subtract';

alter operator pg_catalog.-(bigint, integer) owner to postgres;

create operator pg_catalog.* (procedure = int84mul, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.*(bigint , integer) is 'multiply';

alter operator pg_catalog.*(bigint, integer) owner to postgres;

create operator pg_catalog./ (procedure = int84div, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog./(bigint , integer) is 'divide';

alter operator pg_catalog./(bigint, integer) owner to postgres;

create operator pg_catalog.+ (procedure = int48pl, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.+(integer , bigint) is 'add';

alter operator pg_catalog.+(integer, bigint) owner to postgres;

create operator pg_catalog.- (procedure = int48mi, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.-(integer , bigint) is 'subtract';

alter operator pg_catalog.-(integer, bigint) owner to postgres;

create operator pg_catalog.* (procedure = int48mul, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.*(integer , bigint) is 'multiply';

alter operator pg_catalog.*(integer, bigint) owner to postgres;

create operator pg_catalog./ (procedure = int48div, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog./(integer , bigint) is 'divide';

alter operator pg_catalog./(integer, bigint) owner to postgres;

create operator pg_catalog.<-> (procedure = box_distance, leftarg = box, rightarg = box);

comment on operator pg_catalog.<->(box , box) is 'distance between';

alter operator pg_catalog.<->(box, box) owner to postgres;

create operator pg_catalog.<-> (procedure = path_distance, leftarg = path, rightarg = path);

comment on operator pg_catalog.<->(path , path) is 'distance between';

alter operator pg_catalog.<->(path, path) owner to postgres;

create operator pg_catalog.<-> (procedure = line_distance, leftarg = line, rightarg = line);

comment on operator pg_catalog.<->(line , line) is 'distance between';

alter operator pg_catalog.<->(line, line) owner to postgres;

create operator pg_catalog.<-> (procedure = lseg_distance, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<->(lseg , lseg) is 'distance between';

alter operator pg_catalog.<->(lseg, lseg) owner to postgres;

create operator pg_catalog.<-> (procedure = poly_distance, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<->(polygon , polygon) is 'distance between';

alter operator pg_catalog.<->(polygon, polygon) owner to postgres;

create operator pg_catalog.<> (procedure = point_ne, leftarg = point, rightarg = point);

comment on operator pg_catalog.<>(point , point) is 'not equal';

alter operator pg_catalog.<>(point, point) owner to postgres;

create operator pg_catalog.+ (procedure = point_add, leftarg = point, rightarg = point);

comment on operator pg_catalog.+(point , point) is 'add points (translate)';

alter operator pg_catalog.+(point, point) owner to postgres;

create operator pg_catalog.- (procedure = point_sub, leftarg = point, rightarg = point);

comment on operator pg_catalog.-(point , point) is 'subtract points (translate)';

alter operator pg_catalog.-(point, point) owner to postgres;

create operator pg_catalog.* (procedure = point_mul, leftarg = point, rightarg = point);

comment on operator pg_catalog.*(point , point) is 'multiply points (scale/rotate)';

alter operator pg_catalog.*(point, point) owner to postgres;

create operator pg_catalog./ (procedure = point_div, leftarg = point, rightarg = point);

comment on operator pg_catalog./(point , point) is 'divide points (scale/rotate)';

alter operator pg_catalog./(point, point) owner to postgres;

create operator pg_catalog.+ (procedure = path_add, leftarg = path, rightarg = path);

comment on operator pg_catalog.+(path , path) is 'concatenate';

alter operator pg_catalog.+(path, path) owner to postgres;

create operator pg_catalog.+ (procedure = path_add_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.+(path , point) is 'add (translate path)';

alter operator pg_catalog.+(path, point) owner to postgres;

create operator pg_catalog.- (procedure = path_sub_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.-(path , point) is 'subtract (translate path)';

alter operator pg_catalog.-(path, point) owner to postgres;

create operator pg_catalog.* (procedure = path_mul_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.*(path , point) is 'multiply (rotate/scale path)';

alter operator pg_catalog.*(path, point) owner to postgres;

create operator pg_catalog./ (procedure = path_div_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog./(path , point) is 'divide (rotate/scale path)';

alter operator pg_catalog./(path, point) owner to postgres;

create operator pg_catalog.@> (procedure = path_contain_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.@>(path , point) is 'contains';

alter operator pg_catalog.@>(path, point) owner to postgres;

create operator pg_catalog.<@ (procedure = pt_contained_poly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.<@(point , polygon) is 'is contained by';

alter operator pg_catalog.<@(point, polygon) owner to postgres;

create operator pg_catalog.@> (procedure = poly_contain_pt, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.@>(polygon , point) is 'contains';

alter operator pg_catalog.@>(polygon, point) owner to postgres;

create operator pg_catalog.<@ (procedure = pt_contained_circle, leftarg = point, rightarg = circle);

comment on operator pg_catalog.<@(point , circle) is 'is contained by';

alter operator pg_catalog.<@(point, circle) owner to postgres;

create operator pg_catalog.@> (procedure = circle_contain_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.@>(circle , point) is 'contains';

alter operator pg_catalog.@>(circle, point) owner to postgres;

create operator pg_catalog.@ (procedure = int4abs, rightarg = integer);

comment on operator pg_catalog.@(none , integer) is 'absolute value';

alter operator pg_catalog.@(none, integer) owner to postgres;

create operator pg_catalog.= (procedure = path_n_eq, leftarg = path, rightarg = path);

comment on operator pg_catalog.=(path , path) is 'equal';

alter operator pg_catalog.=(path, path) owner to postgres;

create operator pg_catalog.< (procedure = path_n_lt, leftarg = path, rightarg = path);

comment on operator pg_catalog.<(path , path) is 'less than';

alter operator pg_catalog.<(path, path) owner to postgres;

create operator pg_catalog.> (procedure = path_n_gt, leftarg = path, rightarg = path);

comment on operator pg_catalog.>(path , path) is 'greater than';

alter operator pg_catalog.>(path, path) owner to postgres;

create operator pg_catalog.<= (procedure = path_n_le, leftarg = path, rightarg = path);

comment on operator pg_catalog.<=(path , path) is 'less than or equal';

alter operator pg_catalog.<=(path, path) owner to postgres;

create operator pg_catalog.>= (procedure = path_n_ge, leftarg = path, rightarg = path);

comment on operator pg_catalog.>=(path , path) is 'greater than or equal';

alter operator pg_catalog.>=(path, path) owner to postgres;

create operator pg_catalog.# (procedure = path_npoints, rightarg = path);

comment on operator pg_catalog.#(none , path) is 'number of points';

alter operator pg_catalog.#(none, path) owner to postgres;

create operator pg_catalog.?# (procedure = path_inter, leftarg = path, rightarg = path);

comment on operator pg_catalog.?#(path , path) is 'intersect';

alter operator pg_catalog.?#(path, path) owner to postgres;

create operator pg_catalog.@-@ (procedure = path_length, rightarg = path);

comment on operator pg_catalog.@-@(none , path) is 'sum of path segment lengths';

alter operator pg_catalog.@-@(none, path) owner to postgres;

create operator pg_catalog.>^ (procedure = box_above_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.>^(box , box) is 'is above (allows touching)';

alter operator pg_catalog.>^(box, box) owner to postgres;

create operator pg_catalog.<^ (procedure = box_below_eq, leftarg = box, rightarg = box);

comment on operator pg_catalog.<^(box , box) is 'is below (allows touching)';

alter operator pg_catalog.<^(box, box) owner to postgres;

create operator pg_catalog.?# (procedure = box_overlap, leftarg = box, rightarg = box);

comment on operator pg_catalog.?#(box , box) is 'deprecated, use && instead';

alter operator pg_catalog.?#(box, box) owner to postgres;

create operator pg_catalog.# (procedure = box_intersect, leftarg = box, rightarg = box);

comment on operator pg_catalog.#(box , box) is 'box intersection';

alter operator pg_catalog.#(box, box) owner to postgres;

create operator pg_catalog.+ (procedure = box_add, leftarg = box, rightarg = point);

comment on operator pg_catalog.+(box , point) is 'add point to box (translate)';

alter operator pg_catalog.+(box, point) owner to postgres;

create operator pg_catalog.- (procedure = box_sub, leftarg = box, rightarg = point);

comment on operator pg_catalog.-(box , point) is 'subtract point from box (translate)';

alter operator pg_catalog.-(box, point) owner to postgres;

create operator pg_catalog.* (procedure = box_mul, leftarg = box, rightarg = point);

comment on operator pg_catalog.*(box , point) is 'multiply box by point (scale)';

alter operator pg_catalog.*(box, point) owner to postgres;

create operator pg_catalog./ (procedure = box_div, leftarg = box, rightarg = point);

comment on operator pg_catalog./(box , point) is 'divide box by point (scale)';

alter operator pg_catalog./(box, point) owner to postgres;

create operator pg_catalog.?- (procedure = point_horiz, leftarg = point, rightarg = point);

comment on operator pg_catalog.?-(point , point) is 'horizontally aligned';

alter operator pg_catalog.?-(point, point) owner to postgres;

create operator pg_catalog.?| (procedure = point_vert, leftarg = point, rightarg = point);

comment on operator pg_catalog.?|(point , point) is 'vertically aligned';

alter operator pg_catalog.?|(point, point) owner to postgres;

create operator pg_catalog.= (procedure = tintervaleq, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.=(tinterval , tinterval) is 'equal';

alter operator pg_catalog.=(tinterval, tinterval) owner to postgres;

create operator pg_catalog.<> (procedure = tintervalne, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<>(tinterval , tinterval) is 'not equal';

alter operator pg_catalog.<>(tinterval, tinterval) owner to postgres;

create operator pg_catalog.< (procedure = tintervallt, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<(tinterval , tinterval) is 'less than';

alter operator pg_catalog.<(tinterval, tinterval) owner to postgres;

create operator pg_catalog.> (procedure = tintervalgt, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.>(tinterval , tinterval) is 'greater than';

alter operator pg_catalog.>(tinterval, tinterval) owner to postgres;

create operator pg_catalog.<= (procedure = tintervalle, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.<=(tinterval , tinterval) is 'less than or equal';

alter operator pg_catalog.<=(tinterval, tinterval) owner to postgres;

create operator pg_catalog.>= (procedure = tintervalge, leftarg = tinterval, rightarg = tinterval);

comment on operator pg_catalog.>=(tinterval , tinterval) is 'greater than or equal';

alter operator pg_catalog.>=(tinterval, tinterval) owner to postgres;

create operator pg_catalog.+ (procedure = int82pl, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.+(bigint , smallint) is 'add';

alter operator pg_catalog.+(bigint, smallint) owner to postgres;

create operator pg_catalog.- (procedure = int82mi, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.-(bigint , smallint) is 'subtract';

alter operator pg_catalog.-(bigint, smallint) owner to postgres;

create operator pg_catalog.* (procedure = int82mul, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.*(bigint , smallint) is 'multiply';

alter operator pg_catalog.*(bigint, smallint) owner to postgres;

create operator pg_catalog./ (procedure = int82div, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog./(bigint , smallint) is 'divide';

alter operator pg_catalog./(bigint, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = int28pl, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.+(smallint , bigint) is 'add';

alter operator pg_catalog.+(smallint, bigint) owner to postgres;

create operator pg_catalog.- (procedure = int28mi, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.-(smallint , bigint) is 'subtract';

alter operator pg_catalog.-(smallint, bigint) owner to postgres;

create operator pg_catalog.* (procedure = int28mul, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.*(smallint , bigint) is 'multiply';

alter operator pg_catalog.*(smallint, bigint) owner to postgres;

create operator pg_catalog./ (procedure = int28div, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog./(smallint , bigint) is 'divide';

alter operator pg_catalog./(smallint, bigint) owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog.*(money , real) is 'multiply';

alter operator pg_catalog.*(money, real) owner to postgres;

create operator pg_catalog./ (procedure = cash_div_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog./(money , real) is 'divide';

alter operator pg_catalog./(money, real) owner to postgres;

create operator pg_catalog.* (procedure = flt4_mul_cash, leftarg = real, rightarg = money);

comment on operator pg_catalog.*(real , money) is 'multiply';

alter operator pg_catalog.*(real, money) owner to postgres;

create operator pg_catalog.= (procedure = cash_eq, leftarg = money, rightarg = money);

comment on operator pg_catalog.=(money , money) is 'equal';

alter operator pg_catalog.=(money, money) owner to postgres;

create operator pg_catalog.<> (procedure = cash_ne, leftarg = money, rightarg = money);

comment on operator pg_catalog.<>(money , money) is 'not equal';

alter operator pg_catalog.<>(money, money) owner to postgres;

create operator pg_catalog.< (procedure = cash_lt, leftarg = money, rightarg = money);

comment on operator pg_catalog.<(money , money) is 'less than';

alter operator pg_catalog.<(money, money) owner to postgres;

create operator pg_catalog.> (procedure = cash_gt, leftarg = money, rightarg = money);

comment on operator pg_catalog.>(money , money) is 'greater than';

alter operator pg_catalog.>(money, money) owner to postgres;

create operator pg_catalog.<= (procedure = cash_le, leftarg = money, rightarg = money);

comment on operator pg_catalog.<=(money , money) is 'less than or equal';

alter operator pg_catalog.<=(money, money) owner to postgres;

create operator pg_catalog.>= (procedure = cash_ge, leftarg = money, rightarg = money);

comment on operator pg_catalog.>=(money , money) is 'greater than or equal';

alter operator pg_catalog.>=(money, money) owner to postgres;

create operator pg_catalog.+ (procedure = cash_pl, leftarg = money, rightarg = money);

comment on operator pg_catalog.+(money , money) is 'add';

alter operator pg_catalog.+(money, money) owner to postgres;

create operator pg_catalog.- (procedure = cash_mi, leftarg = money, rightarg = money);

comment on operator pg_catalog.-(money , money) is 'subtract';

alter operator pg_catalog.-(money, money) owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog.*(money , double precision) is 'multiply';

alter operator pg_catalog.*(money, double precision) owner to postgres;

create operator pg_catalog./ (procedure = cash_div_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog./(money , double precision) is 'divide';

alter operator pg_catalog./(money, double precision) owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog.*(money , integer) is 'multiply';

alter operator pg_catalog.*(money, integer) owner to postgres;

create operator pg_catalog./ (procedure = cash_div_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog./(money , integer) is 'divide';

alter operator pg_catalog./(money, integer) owner to postgres;

create operator pg_catalog.* (procedure = cash_mul_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog.*(money , smallint) is 'multiply';

alter operator pg_catalog.*(money, smallint) owner to postgres;

create operator pg_catalog./ (procedure = cash_div_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog./(money , smallint) is 'divide';

alter operator pg_catalog./(money, smallint) owner to postgres;

create operator pg_catalog.* (procedure = flt8_mul_cash, leftarg = double precision, rightarg = money);

comment on operator pg_catalog.*(double precision , money) is 'multiply';

alter operator pg_catalog.*(double precision, money) owner to postgres;

create operator pg_catalog.* (procedure = int4_mul_cash, leftarg = integer, rightarg = money);

comment on operator pg_catalog.*(integer , money) is 'multiply';

alter operator pg_catalog.*(integer, money) owner to postgres;

create operator pg_catalog.* (procedure = int2_mul_cash, leftarg = smallint, rightarg = money);

comment on operator pg_catalog.*(smallint , money) is 'multiply';

alter operator pg_catalog.*(smallint, money) owner to postgres;

create operator pg_catalog.<< (procedure = network_sub, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<<(inet , inet) is 'is subnet';

alter operator pg_catalog.<<(inet, inet) owner to postgres;

create operator pg_catalog.<<= (procedure = network_subeq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<<=(inet , inet) is 'is subnet or equal';

alter operator pg_catalog.<<=(inet, inet) owner to postgres;

create operator pg_catalog.>> (procedure = network_sup, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>>(inet , inet) is 'is supernet';

alter operator pg_catalog.>>(inet, inet) owner to postgres;

create operator pg_catalog.>>= (procedure = network_supeq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>>=(inet , inet) is 'is supernet or equal';

alter operator pg_catalog.>>=(inet, inet) owner to postgres;

create operator pg_catalog.^ (procedure = dpow, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.^(double precision , double precision) is 'exponentiation';

alter operator pg_catalog.^(double precision, double precision) owner to postgres;

create operator pg_catalog.+ (procedure = aclinsert, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.+(aclitem[] , aclitem) is 'add/update ACL item';

alter operator pg_catalog.+(aclitem[], aclitem) owner to postgres;

create operator pg_catalog.- (procedure = aclremove, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.-(aclitem[] , aclitem) is 'remove ACL item';

alter operator pg_catalog.-(aclitem[], aclitem) owner to postgres;

create operator pg_catalog.@> (procedure = aclcontains, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.@>(aclitem[] , aclitem) is 'contains';

alter operator pg_catalog.@>(aclitem[], aclitem) owner to postgres;

create operator pg_catalog.@@ (procedure = lseg_center, rightarg = lseg);

comment on operator pg_catalog.@@(none , lseg) is 'center of';

alter operator pg_catalog.@@(none, lseg) owner to postgres;

create operator pg_catalog.@@ (procedure = path_center, rightarg = path);

comment on operator pg_catalog.@@(none , path) is 'center of';

alter operator pg_catalog.@@(none, path) owner to postgres;

create operator pg_catalog.@@ (procedure = poly_center, rightarg = polygon);

comment on operator pg_catalog.@@(none , polygon) is 'center of';

alter operator pg_catalog.@@(none, polygon) owner to postgres;

create operator pg_catalog.= (procedure = aclitemeq, leftarg = aclitem, rightarg = aclitem);

comment on operator pg_catalog.=(aclitem , aclitem) is 'equal';

alter operator pg_catalog.=(aclitem, aclitem) owner to postgres;

create operator pg_catalog.^ (procedure = numeric_power, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.^(numeric , numeric) is 'exponentiation';

alter operator pg_catalog.^(numeric, numeric) owner to postgres;

create operator pg_catalog.= (procedure = bpchareq, leftarg = char, rightarg = char);

comment on operator pg_catalog.=(char , char) is 'equal';

alter operator pg_catalog.=(char, char) owner to postgres;

create operator pg_catalog.~ (procedure = bpcharregexeq, leftarg = char, rightarg = text);

comment on operator pg_catalog.~(char , text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(char, text) owner to postgres;

create operator pg_catalog.!~ (procedure = bpcharregexne, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~(char , text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(char, text) owner to postgres;

create operator pg_catalog.<> (procedure = bpcharne, leftarg = char, rightarg = char);

comment on operator pg_catalog.<>(char , char) is 'not equal';

alter operator pg_catalog.<>(char, char) owner to postgres;

create operator pg_catalog.< (procedure = bpcharlt, leftarg = char, rightarg = char);

comment on operator pg_catalog.<(char , char) is 'less than';

alter operator pg_catalog.<(char, char) owner to postgres;

create operator pg_catalog.<= (procedure = bpcharle, leftarg = char, rightarg = char);

comment on operator pg_catalog.<=(char , char) is 'less than or equal';

alter operator pg_catalog.<=(char, char) owner to postgres;

create operator pg_catalog.> (procedure = bpchargt, leftarg = char, rightarg = char);

comment on operator pg_catalog.>(char , char) is 'greater than';

alter operator pg_catalog.>(char, char) owner to postgres;

create operator pg_catalog.>= (procedure = bpcharge, leftarg = char, rightarg = char);

comment on operator pg_catalog.>=(char , char) is 'greater than or equal';

alter operator pg_catalog.>=(char, char) owner to postgres;

create operator pg_catalog.= (procedure = array_eq, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.=(anyarray , anyarray) is 'equal';

alter operator pg_catalog.=(anyarray, anyarray) owner to postgres;

create operator pg_catalog.<> (procedure = array_ne, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<>(anyarray , anyarray) is 'not equal';

alter operator pg_catalog.<>(anyarray, anyarray) owner to postgres;

create operator pg_catalog.< (procedure = array_lt, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<(anyarray , anyarray) is 'less than';

alter operator pg_catalog.<(anyarray, anyarray) owner to postgres;

create operator pg_catalog.> (procedure = array_gt, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.>(anyarray , anyarray) is 'greater than';

alter operator pg_catalog.>(anyarray, anyarray) owner to postgres;

create operator pg_catalog.<= (procedure = array_le, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<=(anyarray , anyarray) is 'less than or equal';

alter operator pg_catalog.<=(anyarray, anyarray) owner to postgres;

create operator pg_catalog.>= (procedure = array_ge, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.>=(anyarray , anyarray) is 'greater than or equal';

alter operator pg_catalog.>=(anyarray, anyarray) owner to postgres;

create operator pg_catalog.+ (procedure = date_pl_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.+(date , interval) is 'add';

alter operator pg_catalog.+(date, interval) owner to postgres;

create operator pg_catalog.- (procedure = date_mi_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.-(date , interval) is 'subtract';

alter operator pg_catalog.-(date, interval) owner to postgres;

create operator pg_catalog.= (procedure = date_eq, leftarg = date, rightarg = date);

comment on operator pg_catalog.=(date , date) is 'equal';

alter operator pg_catalog.=(date, date) owner to postgres;

create operator pg_catalog.<> (procedure = date_ne, leftarg = date, rightarg = date);

comment on operator pg_catalog.<>(date , date) is 'not equal';

alter operator pg_catalog.<>(date, date) owner to postgres;

create operator pg_catalog.< (procedure = date_lt, leftarg = date, rightarg = date);

comment on operator pg_catalog.<(date , date) is 'less than';

alter operator pg_catalog.<(date, date) owner to postgres;

create operator pg_catalog.<= (procedure = date_le, leftarg = date, rightarg = date);

comment on operator pg_catalog.<=(date , date) is 'less than or equal';

alter operator pg_catalog.<=(date, date) owner to postgres;

create operator pg_catalog.> (procedure = date_gt, leftarg = date, rightarg = date);

comment on operator pg_catalog.>(date , date) is 'greater than';

alter operator pg_catalog.>(date, date) owner to postgres;

create operator pg_catalog.>= (procedure = date_ge, leftarg = date, rightarg = date);

comment on operator pg_catalog.>=(date , date) is 'greater than or equal';

alter operator pg_catalog.>=(date, date) owner to postgres;

create operator pg_catalog.- (procedure = date_mi, leftarg = date, rightarg = date);

comment on operator pg_catalog.-(date , date) is 'subtract';

alter operator pg_catalog.-(date, date) owner to postgres;

create operator pg_catalog.+ (procedure = date_pli, leftarg = date, rightarg = integer);

comment on operator pg_catalog.+(date , integer) is 'add';

alter operator pg_catalog.+(date, integer) owner to postgres;

create operator pg_catalog.- (procedure = date_mii, leftarg = date, rightarg = integer);

comment on operator pg_catalog.-(date , integer) is 'subtract';

alter operator pg_catalog.-(date, integer) owner to postgres;

create operator pg_catalog.= (procedure = time_eq, leftarg = time, rightarg = time);

comment on operator pg_catalog.=(time , time) is 'equal';

alter operator pg_catalog.=(time, time) owner to postgres;

create operator pg_catalog.<> (procedure = time_ne, leftarg = time, rightarg = time);

comment on operator pg_catalog.<>(time , time) is 'not equal';

alter operator pg_catalog.<>(time, time) owner to postgres;

create operator pg_catalog.< (procedure = time_lt, leftarg = time, rightarg = time);

comment on operator pg_catalog.<(time , time) is 'less than';

alter operator pg_catalog.<(time, time) owner to postgres;

create operator pg_catalog.<= (procedure = time_le, leftarg = time, rightarg = time);

comment on operator pg_catalog.<=(time , time) is 'less than or equal';

alter operator pg_catalog.<=(time, time) owner to postgres;

create operator pg_catalog.> (procedure = time_gt, leftarg = time, rightarg = time);

comment on operator pg_catalog.>(time , time) is 'greater than';

alter operator pg_catalog.>(time, time) owner to postgres;

create operator pg_catalog.>= (procedure = time_ge, leftarg = time, rightarg = time);

comment on operator pg_catalog.>=(time , time) is 'greater than or equal';

alter operator pg_catalog.>=(time, time) owner to postgres;

create operator pg_catalog.+ (procedure = float48pl, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.+(real , double precision) is 'add';

alter operator pg_catalog.+(real, double precision) owner to postgres;

create operator pg_catalog.- (procedure = float48mi, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.-(real , double precision) is 'subtract';

alter operator pg_catalog.-(real, double precision) owner to postgres;

create operator pg_catalog./ (procedure = float48div, leftarg = real, rightarg = double precision);

comment on operator pg_catalog./(real , double precision) is 'divide';

alter operator pg_catalog./(real, double precision) owner to postgres;

create operator pg_catalog.* (procedure = float48mul, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.*(real , double precision) is 'multiply';

alter operator pg_catalog.*(real, double precision) owner to postgres;

create operator pg_catalog.= (procedure = float48eq, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.=(real , double precision) is 'equal';

alter operator pg_catalog.=(real, double precision) owner to postgres;

create operator pg_catalog.<> (procedure = float48ne, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<>(real , double precision) is 'not equal';

alter operator pg_catalog.<>(real, double precision) owner to postgres;

create operator pg_catalog.< (procedure = float48lt, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<(real , double precision) is 'less than';

alter operator pg_catalog.<(real, double precision) owner to postgres;

create operator pg_catalog.> (procedure = float48gt, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.>(real , double precision) is 'greater than';

alter operator pg_catalog.>(real, double precision) owner to postgres;

create operator pg_catalog.<= (procedure = float48le, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.<=(real , double precision) is 'less than or equal';

alter operator pg_catalog.<=(real, double precision) owner to postgres;

create operator pg_catalog.>= (procedure = float48ge, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.>=(real , double precision) is 'greater than or equal';

alter operator pg_catalog.>=(real, double precision) owner to postgres;

create operator pg_catalog.+ (procedure = float84pl, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.+(double precision , real) is 'add';

alter operator pg_catalog.+(double precision, real) owner to postgres;

create operator pg_catalog.- (procedure = float84mi, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.-(double precision , real) is 'subtract';

alter operator pg_catalog.-(double precision, real) owner to postgres;

create operator pg_catalog./ (procedure = float84div, leftarg = double precision, rightarg = real);

comment on operator pg_catalog./(double precision , real) is 'divide';

alter operator pg_catalog./(double precision, real) owner to postgres;

create operator pg_catalog.* (procedure = float84mul, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.*(double precision , real) is 'multiply';

alter operator pg_catalog.*(double precision, real) owner to postgres;

create operator pg_catalog.= (procedure = float84eq, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.=(double precision , real) is 'equal';

alter operator pg_catalog.=(double precision, real) owner to postgres;

create operator pg_catalog.<> (procedure = float84ne, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<>(double precision , real) is 'not equal';

alter operator pg_catalog.<>(double precision, real) owner to postgres;

create operator pg_catalog.< (procedure = float84lt, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<(double precision , real) is 'less than';

alter operator pg_catalog.<(double precision, real) owner to postgres;

create operator pg_catalog.> (procedure = float84gt, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.>(double precision , real) is 'greater than';

alter operator pg_catalog.>(double precision, real) owner to postgres;

create operator pg_catalog.<= (procedure = float84le, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.<=(double precision , real) is 'less than or equal';

alter operator pg_catalog.<=(double precision, real) owner to postgres;

create operator pg_catalog.>= (procedure = float84ge, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.>=(double precision , real) is 'greater than or equal';

alter operator pg_catalog.>=(double precision, real) owner to postgres;

create operator pg_catalog.= (procedure = network_eq, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.=(inet , inet) is 'equal';

alter operator pg_catalog.=(inet, inet) owner to postgres;

create operator pg_catalog.<> (procedure = network_ne, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<>(inet , inet) is 'not equal';

alter operator pg_catalog.<>(inet, inet) owner to postgres;

create operator pg_catalog.< (procedure = network_lt, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<(inet , inet) is 'less than';

alter operator pg_catalog.<(inet, inet) owner to postgres;

create operator pg_catalog.<= (procedure = network_le, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.<=(inet , inet) is 'less than or equal';

alter operator pg_catalog.<=(inet, inet) owner to postgres;

create operator pg_catalog.> (procedure = network_gt, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>(inet , inet) is 'greater than';

alter operator pg_catalog.>(inet, inet) owner to postgres;

create operator pg_catalog.>= (procedure = network_ge, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.>=(inet , inet) is 'greater than or equal';

alter operator pg_catalog.>=(inet, inet) owner to postgres;

create operator pg_catalog.~~ (procedure = namelike, leftarg = name, rightarg = text);

comment on operator pg_catalog.~~(name , text) is 'matches LIKE expression';

alter operator pg_catalog.~~(name, text) owner to postgres;

create operator pg_catalog.!~~ (procedure = namenlike, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~~(name , text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(name, text) owner to postgres;

create operator pg_catalog.~~ (procedure = textlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.~~(text , text) is 'matches LIKE expression';

alter operator pg_catalog.~~(text, text) owner to postgres;

create operator pg_catalog.!~~ (procedure = textnlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~~(text , text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(text, text) owner to postgres;

create operator pg_catalog.~~ (procedure = bpcharlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.~~(char , text) is 'matches LIKE expression';

alter operator pg_catalog.~~(char, text) owner to postgres;

create operator pg_catalog.!~~ (procedure = bpcharnlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~~(char , text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(char, text) owner to postgres;

create operator pg_catalog.= (procedure = macaddr_eq, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.=(macaddr , macaddr) is 'equal';

alter operator pg_catalog.=(macaddr, macaddr) owner to postgres;

create operator pg_catalog.<> (procedure = macaddr_ne, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<>(macaddr , macaddr) is 'not equal';

alter operator pg_catalog.<>(macaddr, macaddr) owner to postgres;

create operator pg_catalog.< (procedure = macaddr_lt, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<(macaddr , macaddr) is 'less than';

alter operator pg_catalog.<(macaddr, macaddr) owner to postgres;

create operator pg_catalog.<= (procedure = macaddr_le, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.<=(macaddr , macaddr) is 'less than or equal';

alter operator pg_catalog.<=(macaddr, macaddr) owner to postgres;

create operator pg_catalog.> (procedure = macaddr_gt, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.>(macaddr , macaddr) is 'greater than';

alter operator pg_catalog.>(macaddr, macaddr) owner to postgres;

create operator pg_catalog.>= (procedure = macaddr_ge, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.>=(macaddr , macaddr) is 'greater than or equal';

alter operator pg_catalog.>=(macaddr, macaddr) owner to postgres;

create operator pg_catalog.~* (procedure = nameicregexeq, leftarg = name, rightarg = text);

comment on operator pg_catalog.~*(name , text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(name, text) owner to postgres;

create operator pg_catalog.!~* (procedure = nameicregexne, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~*(name , text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(name, text) owner to postgres;

create operator pg_catalog.~* (procedure = texticregexeq, leftarg = text, rightarg = text);

comment on operator pg_catalog.~*(text , text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(text, text) owner to postgres;

create operator pg_catalog.!~* (procedure = texticregexne, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~*(text , text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(text, text) owner to postgres;

create operator pg_catalog.~* (procedure = bpcharicregexeq, leftarg = char, rightarg = text);

comment on operator pg_catalog.~*(char , text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(char, text) owner to postgres;

create operator pg_catalog.!~* (procedure = bpcharicregexne, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~*(char , text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(char, text) owner to postgres;

create operator pg_catalog.| (procedure = tintervalstart, rightarg = tinterval);

comment on operator pg_catalog.|(none , tinterval) is 'start of interval';

alter operator pg_catalog.|(none, tinterval) owner to postgres;

create operator pg_catalog.= (procedure = timestamptz_eq, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(timestamp with time zone , timestamp with time zone) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.<> (procedure = timestamptz_ne, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(timestamp with time zone , timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.< (procedure = timestamptz_lt, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(timestamp with time zone , timestamp with time zone) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.<= (procedure = timestamptz_le, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(timestamp with time zone , timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.> (procedure = timestamptz_gt, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(timestamp with time zone , timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.>= (procedure = timestamptz_ge, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(timestamp with time zone , timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.+ (procedure = timestamptz_pl_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.+(timestamp with time zone , interval) is 'add';

alter operator pg_catalog.+(timestamp with time zone, interval) owner to postgres;

create operator pg_catalog.- (procedure = timestamptz_mi, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.-(timestamp with time zone , timestamp with time zone) is 'subtract';

alter operator pg_catalog.-(timestamp with time zone, timestamp with time zone) owner to postgres;

create operator pg_catalog.- (procedure = timestamptz_mi_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.-(timestamp with time zone , interval) is 'subtract';

alter operator pg_catalog.-(timestamp with time zone, interval) owner to postgres;

create operator pg_catalog.= (procedure = interval_eq, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.=(interval , interval) is 'equal';

alter operator pg_catalog.=(interval, interval) owner to postgres;

create operator pg_catalog.<> (procedure = interval_ne, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<>(interval , interval) is 'not equal';

alter operator pg_catalog.<>(interval, interval) owner to postgres;

create operator pg_catalog.< (procedure = interval_lt, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<(interval , interval) is 'less than';

alter operator pg_catalog.<(interval, interval) owner to postgres;

create operator pg_catalog.<= (procedure = interval_le, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.<=(interval , interval) is 'less than or equal';

alter operator pg_catalog.<=(interval, interval) owner to postgres;

create operator pg_catalog.> (procedure = interval_gt, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.>(interval , interval) is 'greater than';

alter operator pg_catalog.>(interval, interval) owner to postgres;

create operator pg_catalog.>= (procedure = interval_ge, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.>=(interval , interval) is 'greater than or equal';

alter operator pg_catalog.>=(interval, interval) owner to postgres;

create operator pg_catalog.- (procedure = interval_um, rightarg = interval);

comment on operator pg_catalog.-(none , interval) is 'negate';

alter operator pg_catalog.-(none, interval) owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.+(interval , interval) is 'add';

alter operator pg_catalog.+(interval, interval) owner to postgres;

create operator pg_catalog.- (procedure = interval_mi, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.-(interval , interval) is 'subtract';

alter operator pg_catalog.-(interval, interval) owner to postgres;

create operator pg_catalog.+ (procedure = datetime_pl, leftarg = date, rightarg = time);

comment on operator pg_catalog.+(date , time) is 'convert date and time to timestamp';

alter operator pg_catalog.+(date, time) owner to postgres;

create operator pg_catalog.+ (procedure = datetimetz_pl, leftarg = date, rightarg = time with time zone);

comment on operator pg_catalog.+(date , time with time zone) is 'convert date and time with time zone to timestamp with time zone';

alter operator pg_catalog.+(date, time with time zone) owner to postgres;

create operator pg_catalog.+ (procedure = timedate_pl, leftarg = time, rightarg = date);

comment on operator pg_catalog.+(time , date) is 'convert time and date to timestamp';

alter operator pg_catalog.+(time, date) owner to postgres;

create operator pg_catalog.+ (procedure = timetzdate_pl, leftarg = time with time zone, rightarg = date);

comment on operator pg_catalog.+(time with time zone , date) is 'convert time with time zone and date to timestamp with time zone';

alter operator pg_catalog.+(time with time zone, date) owner to postgres;

create operator pg_catalog.- (procedure = time_mi_time, leftarg = time, rightarg = time);

comment on operator pg_catalog.-(time , time) is 'subtract';

alter operator pg_catalog.-(time, time) owner to postgres;

create operator pg_catalog.@@ (procedure = circle_center, rightarg = circle);

comment on operator pg_catalog.@@(none , circle) is 'center of';

alter operator pg_catalog.@@(none, circle) owner to postgres;

create operator pg_catalog.= (procedure = circle_eq, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.=(circle , circle) is 'equal by area';

alter operator pg_catalog.=(circle, circle) owner to postgres;

create operator pg_catalog.<> (procedure = circle_ne, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<>(circle , circle) is 'not equal by area';

alter operator pg_catalog.<>(circle, circle) owner to postgres;

create operator pg_catalog.< (procedure = circle_lt, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<(circle , circle) is 'less than by area';

alter operator pg_catalog.<(circle, circle) owner to postgres;

create operator pg_catalog.> (procedure = circle_gt, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>(circle , circle) is 'greater than by area';

alter operator pg_catalog.>(circle, circle) owner to postgres;

create operator pg_catalog.<= (procedure = circle_le, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<=(circle , circle) is 'less than or equal by area';

alter operator pg_catalog.<=(circle, circle) owner to postgres;

create operator pg_catalog.>= (procedure = circle_ge, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>=(circle , circle) is 'greater than or equal by area';

alter operator pg_catalog.>=(circle, circle) owner to postgres;

create operator pg_catalog.<< (procedure = circle_left, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<<(circle , circle) is 'is left of';

alter operator pg_catalog.<<(circle, circle) owner to postgres;

create operator pg_catalog.&< (procedure = circle_overleft, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&<(circle , circle) is 'overlaps or is left of';

alter operator pg_catalog.&<(circle, circle) owner to postgres;

create operator pg_catalog.&> (procedure = circle_overright, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&>(circle , circle) is 'overlaps or is right of';

alter operator pg_catalog.&>(circle, circle) owner to postgres;

create operator pg_catalog.>> (procedure = circle_right, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.>>(circle , circle) is 'is right of';

alter operator pg_catalog.>>(circle, circle) owner to postgres;

create operator pg_catalog.<@ (procedure = circle_contained, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<@(circle , circle) is 'is contained by';

alter operator pg_catalog.<@(circle, circle) owner to postgres;

create operator pg_catalog.@> (procedure = circle_contain, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.@>(circle , circle) is 'contains';

alter operator pg_catalog.@>(circle, circle) owner to postgres;

create operator pg_catalog.~= (procedure = circle_same, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.~=(circle , circle) is 'same as';

alter operator pg_catalog.~=(circle, circle) owner to postgres;

create operator pg_catalog.&& (procedure = circle_overlap, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&&(circle , circle) is 'overlaps';

alter operator pg_catalog.&&(circle, circle) owner to postgres;

create operator pg_catalog.|>> (procedure = circle_above, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.|>>(circle , circle) is 'is above';

alter operator pg_catalog.|>>(circle, circle) owner to postgres;

create operator pg_catalog.<<| (procedure = circle_below, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<<|(circle , circle) is 'is below';

alter operator pg_catalog.<<|(circle, circle) owner to postgres;

create operator pg_catalog.+ (procedure = circle_add_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.+(circle , point) is 'add';

alter operator pg_catalog.+(circle, point) owner to postgres;

create operator pg_catalog.- (procedure = circle_sub_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.-(circle , point) is 'subtract';

alter operator pg_catalog.-(circle, point) owner to postgres;

create operator pg_catalog.* (procedure = circle_mul_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.*(circle , point) is 'multiply';

alter operator pg_catalog.*(circle, point) owner to postgres;

create operator pg_catalog./ (procedure = circle_div_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog./(circle , point) is 'divide';

alter operator pg_catalog./(circle, point) owner to postgres;

create operator pg_catalog.<-> (procedure = circle_distance, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.<->(circle , circle) is 'distance between';

alter operator pg_catalog.<->(circle, circle) owner to postgres;

create operator pg_catalog.# (procedure = poly_npoints, rightarg = polygon);

comment on operator pg_catalog.#(none , polygon) is 'number of points';

alter operator pg_catalog.#(none, polygon) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_pc, leftarg = point, rightarg = circle);

comment on operator pg_catalog.<->(point , circle) is 'distance between';

alter operator pg_catalog.<->(point, circle) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_cpoly, leftarg = circle, rightarg = polygon);

comment on operator pg_catalog.<->(circle , polygon) is 'distance between';

alter operator pg_catalog.<->(circle, polygon) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.<->(line , box) is 'distance between';

alter operator pg_catalog.<->(line, box) owner to postgres;

create operator pg_catalog.?# (procedure = lseg_intersect, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?#(lseg , lseg) is 'intersect';

alter operator pg_catalog.?#(lseg, lseg) owner to postgres;

create operator pg_catalog.?|| (procedure = lseg_parallel, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?||(lseg , lseg) is 'parallel';

alter operator pg_catalog.?||(lseg, lseg) owner to postgres;

create operator pg_catalog.?-| (procedure = lseg_perp, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.?-|(lseg , lseg) is 'perpendicular';

alter operator pg_catalog.?-|(lseg, lseg) owner to postgres;

create operator pg_catalog.?- (procedure = lseg_horizontal, rightarg = lseg);

comment on operator pg_catalog.?-(none , lseg) is 'horizontal';

alter operator pg_catalog.?-(none, lseg) owner to postgres;

create operator pg_catalog.?| (procedure = lseg_vertical, rightarg = lseg);

comment on operator pg_catalog.?|(none , lseg) is 'vertical';

alter operator pg_catalog.?|(none, lseg) owner to postgres;

create operator pg_catalog.= (procedure = lseg_eq, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.=(lseg , lseg) is 'equal';

alter operator pg_catalog.=(lseg, lseg) owner to postgres;

create operator pg_catalog.# (procedure = lseg_interpt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.#(lseg , lseg) is 'intersection point';

alter operator pg_catalog.#(lseg, lseg) owner to postgres;

create operator pg_catalog.?# (procedure = inter_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.?#(lseg , line) is 'intersect';

alter operator pg_catalog.?#(lseg, line) owner to postgres;

create operator pg_catalog.?# (procedure = inter_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.?#(lseg , box) is 'intersect';

alter operator pg_catalog.?#(lseg, box) owner to postgres;

create operator pg_catalog.?# (procedure = inter_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.?#(line , box) is 'intersect';

alter operator pg_catalog.?#(line, box) owner to postgres;

create operator pg_catalog.<@ (procedure = on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<@(point , line) is 'point on line';

alter operator pg_catalog.<@(point, line) owner to postgres;

create operator pg_catalog.<@ (procedure = on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<@(point , lseg) is 'is contained by';

alter operator pg_catalog.<@(point, lseg) owner to postgres;

create operator pg_catalog.<@ (procedure = on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<@(lseg , line) is 'lseg on line';

alter operator pg_catalog.<@(lseg, line) owner to postgres;

create operator pg_catalog.<@ (procedure = on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<@(lseg , box) is 'is contained by';

alter operator pg_catalog.<@(lseg, box) owner to postgres;

create operator pg_catalog.= (procedure = timetz_eq, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.=(time with time zone , time with time zone) is 'equal';

alter operator pg_catalog.=(time with time zone, time with time zone) owner to postgres;

create operator pg_catalog.<> (procedure = timetz_ne, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<>(time with time zone , time with time zone) is 'not equal';

alter operator pg_catalog.<>(time with time zone, time with time zone) owner to postgres;

create operator pg_catalog.< (procedure = timetz_lt, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<(time with time zone , time with time zone) is 'less than';

alter operator pg_catalog.<(time with time zone, time with time zone) owner to postgres;

create operator pg_catalog.<= (procedure = timetz_le, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.<=(time with time zone , time with time zone) is 'less than or equal';

alter operator pg_catalog.<=(time with time zone, time with time zone) owner to postgres;

create operator pg_catalog.> (procedure = timetz_gt, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.>(time with time zone , time with time zone) is 'greater than';

alter operator pg_catalog.>(time with time zone, time with time zone) owner to postgres;

create operator pg_catalog.>= (procedure = timetz_ge, leftarg = time with time zone, rightarg = time with time zone);

comment on operator pg_catalog.>=(time with time zone , time with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(time with time zone, time with time zone) owner to postgres;

create operator pg_catalog.## (procedure = close_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.##(point , line) is 'closest point to A on B';

alter operator pg_catalog.##(point, line) owner to postgres;

create operator pg_catalog.## (procedure = close_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.##(point , lseg) is 'closest point to A on B';

alter operator pg_catalog.##(point, lseg) owner to postgres;

create operator pg_catalog.## (procedure = close_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.##(point , box) is 'closest point to A on B';

alter operator pg_catalog.##(point, box) owner to postgres;

create operator pg_catalog.## (procedure = close_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.##(lseg , line) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, line) owner to postgres;

create operator pg_catalog.## (procedure = close_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.##(lseg , box) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, box) owner to postgres;

create operator pg_catalog.## (procedure = close_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.##(line , box) is 'closest point to A on B';

alter operator pg_catalog.##(line, box) owner to postgres;

create operator pg_catalog.## (procedure = close_ls, leftarg = line, rightarg = lseg);

comment on operator pg_catalog.##(line , lseg) is 'closest point to A on B';

alter operator pg_catalog.##(line, lseg) owner to postgres;

create operator pg_catalog.## (procedure = close_lseg, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.##(lseg , lseg) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, lseg) owner to postgres;

create operator pg_catalog.* (procedure = interval_mul, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog.*(interval , double precision) is 'multiply';

alter operator pg_catalog.*(interval, double precision) owner to postgres;

create operator pg_catalog.* (procedure = mul_d_interval, leftarg = double precision, rightarg = interval);

comment on operator pg_catalog.*(double precision , interval) is 'multiply';

alter operator pg_catalog.*(double precision, interval) owner to postgres;

create operator pg_catalog./ (procedure = interval_div, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog./(interval , double precision) is 'divide';

alter operator pg_catalog./(interval, double precision) owner to postgres;

create operator pg_catalog.<> (procedure = lseg_ne, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<>(lseg , lseg) is 'not equal';

alter operator pg_catalog.<>(lseg, lseg) owner to postgres;

create operator pg_catalog.< (procedure = lseg_lt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<(lseg , lseg) is 'less than by length';

alter operator pg_catalog.<(lseg, lseg) owner to postgres;

create operator pg_catalog.<= (procedure = lseg_le, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.<=(lseg , lseg) is 'less than or equal by length';

alter operator pg_catalog.<=(lseg, lseg) owner to postgres;

create operator pg_catalog.> (procedure = lseg_gt, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.>(lseg , lseg) is 'greater than by length';

alter operator pg_catalog.>(lseg, lseg) owner to postgres;

create operator pg_catalog.>= (procedure = lseg_ge, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.>=(lseg , lseg) is 'greater than or equal by length';

alter operator pg_catalog.>=(lseg, lseg) owner to postgres;

create operator pg_catalog.@-@ (procedure = lseg_length, rightarg = lseg);

comment on operator pg_catalog.@-@(none , lseg) is 'distance between endpoints';

alter operator pg_catalog.@-@(none, lseg) owner to postgres;

create operator pg_catalog.?# (procedure = line_intersect, leftarg = line, rightarg = line);

comment on operator pg_catalog.?#(line , line) is 'intersect';

alter operator pg_catalog.?#(line, line) owner to postgres;

create operator pg_catalog.?|| (procedure = line_parallel, leftarg = line, rightarg = line);

comment on operator pg_catalog.?||(line , line) is 'parallel';

alter operator pg_catalog.?||(line, line) owner to postgres;

create operator pg_catalog.?-| (procedure = line_perp, leftarg = line, rightarg = line);

comment on operator pg_catalog.?-|(line , line) is 'perpendicular';

alter operator pg_catalog.?-|(line, line) owner to postgres;

create operator pg_catalog.?- (procedure = line_horizontal, rightarg = line);

comment on operator pg_catalog.?-(none , line) is 'horizontal';

alter operator pg_catalog.?-(none, line) owner to postgres;

create operator pg_catalog.?| (procedure = line_vertical, rightarg = line);

comment on operator pg_catalog.?|(none , line) is 'vertical';

alter operator pg_catalog.?|(none, line) owner to postgres;

create operator pg_catalog.= (procedure = line_eq, leftarg = line, rightarg = line);

comment on operator pg_catalog.=(line , line) is 'equal';

alter operator pg_catalog.=(line, line) owner to postgres;

create operator pg_catalog.# (procedure = line_interpt, leftarg = line, rightarg = line);

comment on operator pg_catalog.#(line , line) is 'intersection point';

alter operator pg_catalog.#(line, line) owner to postgres;

create operator pg_catalog.~~* (procedure = nameiclike, leftarg = name, rightarg = text);

comment on operator pg_catalog.~~*(name , text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(name, text) owner to postgres;

create operator pg_catalog.!~~* (procedure = nameicnlike, leftarg = name, rightarg = text);

comment on operator pg_catalog.!~~*(name , text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(name, text) owner to postgres;

create operator pg_catalog.~~* (procedure = texticlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.~~*(text , text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(text, text) owner to postgres;

create operator pg_catalog.!~~* (procedure = texticnlike, leftarg = text, rightarg = text);

comment on operator pg_catalog.!~~*(text , text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(text, text) owner to postgres;

create operator pg_catalog.~~* (procedure = bpchariclike, leftarg = char, rightarg = text);

comment on operator pg_catalog.~~*(char , text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(char, text) owner to postgres;

create operator pg_catalog.!~~* (procedure = bpcharicnlike, leftarg = char, rightarg = text);

comment on operator pg_catalog.!~~*(char , text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(char, text) owner to postgres;

create operator pg_catalog.<= (procedure = boolle, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.<=(boolean , boolean) is 'less than or equal';

alter operator pg_catalog.<=(boolean, boolean) owner to postgres;

create operator pg_catalog.>= (procedure = boolge, leftarg = boolean, rightarg = boolean);

comment on operator pg_catalog.>=(boolean , boolean) is 'greater than or equal';

alter operator pg_catalog.>=(boolean, boolean) owner to postgres;

create operator pg_catalog.- (procedure = numeric_uminus, rightarg = numeric);

comment on operator pg_catalog.-(none , numeric) is 'negate';

alter operator pg_catalog.-(none, numeric) owner to postgres;

create operator pg_catalog.= (procedure = numeric_eq, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.=(numeric , numeric) is 'equal';

alter operator pg_catalog.=(numeric, numeric) owner to postgres;

create operator pg_catalog.<> (procedure = numeric_ne, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<>(numeric , numeric) is 'not equal';

alter operator pg_catalog.<>(numeric, numeric) owner to postgres;

create operator pg_catalog.< (procedure = numeric_lt, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<(numeric , numeric) is 'less than';

alter operator pg_catalog.<(numeric, numeric) owner to postgres;

create operator pg_catalog.<= (procedure = numeric_le, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.<=(numeric , numeric) is 'less than or equal';

alter operator pg_catalog.<=(numeric, numeric) owner to postgres;

create operator pg_catalog.> (procedure = numeric_gt, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.>(numeric , numeric) is 'greater than';

alter operator pg_catalog.>(numeric, numeric) owner to postgres;

create operator pg_catalog.>= (procedure = numeric_ge, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.>=(numeric , numeric) is 'greater than or equal';

alter operator pg_catalog.>=(numeric, numeric) owner to postgres;

create operator pg_catalog.+ (procedure = numeric_add, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.+(numeric , numeric) is 'add';

alter operator pg_catalog.+(numeric, numeric) owner to postgres;

create operator pg_catalog.- (procedure = numeric_sub, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.-(numeric , numeric) is 'subtract';

alter operator pg_catalog.-(numeric, numeric) owner to postgres;

create operator pg_catalog.* (procedure = numeric_mul, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.*(numeric , numeric) is 'multiply';

alter operator pg_catalog.*(numeric, numeric) owner to postgres;

create operator pg_catalog./ (procedure = numeric_div, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog./(numeric , numeric) is 'divide';

alter operator pg_catalog./(numeric, numeric) owner to postgres;

create operator pg_catalog.% (procedure = numeric_mod, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.%(numeric , numeric) is 'modulus';

alter operator pg_catalog.%(numeric, numeric) owner to postgres;

create operator pg_catalog.@ (procedure = numeric_abs, rightarg = numeric);

comment on operator pg_catalog.@(none , numeric) is 'absolute value';

alter operator pg_catalog.@(none, numeric) owner to postgres;

create operator pg_catalog.= (procedure = biteq, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.=(bit , bit) is 'equal';

alter operator pg_catalog.=(bit, bit) owner to postgres;

create operator pg_catalog.<> (procedure = bitne, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<>(bit , bit) is 'not equal';

alter operator pg_catalog.<>(bit, bit) owner to postgres;

create operator pg_catalog.< (procedure = bitlt, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<(bit , bit) is 'less than';

alter operator pg_catalog.<(bit, bit) owner to postgres;

create operator pg_catalog.> (procedure = bitgt, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.>(bit , bit) is 'greater than';

alter operator pg_catalog.>(bit, bit) owner to postgres;

create operator pg_catalog.<= (procedure = bitle, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.<=(bit , bit) is 'less than or equal';

alter operator pg_catalog.<=(bit, bit) owner to postgres;

create operator pg_catalog.>= (procedure = bitge, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.>=(bit , bit) is 'greater than or equal';

alter operator pg_catalog.>=(bit, bit) owner to postgres;

create operator pg_catalog.& (procedure = bitand, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.&(bit , bit) is 'bitwise and';

alter operator pg_catalog.&(bit, bit) owner to postgres;

create operator pg_catalog.| (procedure = bitor, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.|(bit , bit) is 'bitwise or';

alter operator pg_catalog.|(bit, bit) owner to postgres;

create operator pg_catalog.# (procedure = bitxor, leftarg = bit, rightarg = bit);

comment on operator pg_catalog.#(bit , bit) is 'bitwise exclusive or';

alter operator pg_catalog.#(bit, bit) owner to postgres;

create operator pg_catalog.~ (procedure = bitnot, rightarg = bit);

comment on operator pg_catalog.~(none , bit) is 'bitwise not';

alter operator pg_catalog.~(none, bit) owner to postgres;

create operator pg_catalog.<< (procedure = bitshiftleft, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.<<(bit , integer) is 'bitwise shift left';

alter operator pg_catalog.<<(bit, integer) owner to postgres;

create operator pg_catalog.>> (procedure = bitshiftright, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.>>(bit , integer) is 'bitwise shift right';

alter operator pg_catalog.>>(bit, integer) owner to postgres;

create operator pg_catalog.|| (procedure = bitcat, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.||(bit varying , bit varying) is 'concatenate';

alter operator pg_catalog.||(bit varying, bit varying) owner to postgres;

create operator pg_catalog.+ (procedure = time_pl_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.+(time , interval) is 'add';

alter operator pg_catalog.+(time, interval) owner to postgres;

create operator pg_catalog.- (procedure = time_mi_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.-(time , interval) is 'subtract';

alter operator pg_catalog.-(time, interval) owner to postgres;

create operator pg_catalog.+ (procedure = timetz_pl_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.+(time with time zone , interval) is 'add';

alter operator pg_catalog.+(time with time zone, interval) owner to postgres;

create operator pg_catalog.- (procedure = timetz_mi_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.-(time with time zone , interval) is 'subtract';

alter operator pg_catalog.-(time with time zone, interval) owner to postgres;

create operator pg_catalog.= (procedure = varbiteq, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.=(bit varying , bit varying) is 'equal';

alter operator pg_catalog.=(bit varying, bit varying) owner to postgres;

create operator pg_catalog.<> (procedure = varbitne, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<>(bit varying , bit varying) is 'not equal';

alter operator pg_catalog.<>(bit varying, bit varying) owner to postgres;

create operator pg_catalog.< (procedure = varbitlt, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<(bit varying , bit varying) is 'less than';

alter operator pg_catalog.<(bit varying, bit varying) owner to postgres;

create operator pg_catalog.> (procedure = varbitgt, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.>(bit varying , bit varying) is 'greater than';

alter operator pg_catalog.>(bit varying, bit varying) owner to postgres;

create operator pg_catalog.<= (procedure = varbitle, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.<=(bit varying , bit varying) is 'less than or equal';

alter operator pg_catalog.<=(bit varying, bit varying) owner to postgres;

create operator pg_catalog.>= (procedure = varbitge, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.>=(bit varying , bit varying) is 'greater than or equal';

alter operator pg_catalog.>=(bit varying, bit varying) owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_time, leftarg = interval, rightarg = time);

comment on operator pg_catalog.+(interval , time) is 'add';

alter operator pg_catalog.+(interval, time) owner to postgres;

create operator pg_catalog.= (procedure = int28eq, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.=(smallint , bigint) is 'equal';

alter operator pg_catalog.=(smallint, bigint) owner to postgres;

create operator pg_catalog.<> (procedure = int28ne, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<>(smallint , bigint) is 'not equal';

alter operator pg_catalog.<>(smallint, bigint) owner to postgres;

create operator pg_catalog.< (procedure = int28lt, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<(smallint , bigint) is 'less than';

alter operator pg_catalog.<(smallint, bigint) owner to postgres;

create operator pg_catalog.> (procedure = int28gt, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.>(smallint , bigint) is 'greater than';

alter operator pg_catalog.>(smallint, bigint) owner to postgres;

create operator pg_catalog.<= (procedure = int28le, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.<=(smallint , bigint) is 'less than or equal';

alter operator pg_catalog.<=(smallint, bigint) owner to postgres;

create operator pg_catalog.>= (procedure = int28ge, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.>=(smallint , bigint) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, bigint) owner to postgres;

create operator pg_catalog.= (procedure = int82eq, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.=(bigint , smallint) is 'equal';

alter operator pg_catalog.=(bigint, smallint) owner to postgres;

create operator pg_catalog.<> (procedure = int82ne, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<>(bigint , smallint) is 'not equal';

alter operator pg_catalog.<>(bigint, smallint) owner to postgres;

create operator pg_catalog.< (procedure = int82lt, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<(bigint , smallint) is 'less than';

alter operator pg_catalog.<(bigint, smallint) owner to postgres;

create operator pg_catalog.> (procedure = int82gt, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.>(bigint , smallint) is 'greater than';

alter operator pg_catalog.>(bigint, smallint) owner to postgres;

create operator pg_catalog.<= (procedure = int82le, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.<=(bigint , smallint) is 'less than or equal';

alter operator pg_catalog.<=(bigint, smallint) owner to postgres;

create operator pg_catalog.>= (procedure = int82ge, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.>=(bigint , smallint) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, smallint) owner to postgres;

create operator pg_catalog.& (procedure = int2and, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.&(smallint , smallint) is 'bitwise and';

alter operator pg_catalog.&(smallint, smallint) owner to postgres;

create operator pg_catalog.| (procedure = int2or, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.|(smallint , smallint) is 'bitwise or';

alter operator pg_catalog.|(smallint, smallint) owner to postgres;

create operator pg_catalog.# (procedure = int2xor, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.#(smallint , smallint) is 'bitwise exclusive or';

alter operator pg_catalog.#(smallint, smallint) owner to postgres;

create operator pg_catalog.~ (procedure = int2not, rightarg = smallint);

comment on operator pg_catalog.~(none , smallint) is 'bitwise not';

alter operator pg_catalog.~(none, smallint) owner to postgres;

create operator pg_catalog.<< (procedure = int2shl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<<(smallint , integer) is 'bitwise shift left';

alter operator pg_catalog.<<(smallint, integer) owner to postgres;

create operator pg_catalog.>> (procedure = int2shr, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>>(smallint , integer) is 'bitwise shift right';

alter operator pg_catalog.>>(smallint, integer) owner to postgres;

create operator pg_catalog.& (procedure = int4and, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.&(integer , integer) is 'bitwise and';

alter operator pg_catalog.&(integer, integer) owner to postgres;

create operator pg_catalog.| (procedure = int4or, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.|(integer , integer) is 'bitwise or';

alter operator pg_catalog.|(integer, integer) owner to postgres;

create operator pg_catalog.# (procedure = int4xor, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.#(integer , integer) is 'bitwise exclusive or';

alter operator pg_catalog.#(integer, integer) owner to postgres;

create operator pg_catalog.~ (procedure = int4not, rightarg = integer);

comment on operator pg_catalog.~(none , integer) is 'bitwise not';

alter operator pg_catalog.~(none, integer) owner to postgres;

create operator pg_catalog.<< (procedure = int4shl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<<(integer , integer) is 'bitwise shift left';

alter operator pg_catalog.<<(integer, integer) owner to postgres;

create operator pg_catalog.>> (procedure = int4shr, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>>(integer , integer) is 'bitwise shift right';

alter operator pg_catalog.>>(integer, integer) owner to postgres;

create operator pg_catalog.& (procedure = int8and, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.&(bigint , bigint) is 'bitwise and';

alter operator pg_catalog.&(bigint, bigint) owner to postgres;

create operator pg_catalog.| (procedure = int8or, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.|(bigint , bigint) is 'bitwise or';

alter operator pg_catalog.|(bigint, bigint) owner to postgres;

create operator pg_catalog.# (procedure = int8xor, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.#(bigint , bigint) is 'bitwise exclusive or';

alter operator pg_catalog.#(bigint, bigint) owner to postgres;

create operator pg_catalog.~ (procedure = int8not, rightarg = bigint);

comment on operator pg_catalog.~(none , bigint) is 'bitwise not';

alter operator pg_catalog.~(none, bigint) owner to postgres;

create operator pg_catalog.<< (procedure = int8shl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<<(bigint , integer) is 'bitwise shift left';

alter operator pg_catalog.<<(bigint, integer) owner to postgres;

create operator pg_catalog.>> (procedure = int8shr, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>>(bigint , integer) is 'bitwise shift right';

alter operator pg_catalog.>>(bigint, integer) owner to postgres;

create operator pg_catalog.+ (procedure = int8up, rightarg = bigint);

comment on operator pg_catalog.+(none , bigint) is 'unary plus';

alter operator pg_catalog.+(none, bigint) owner to postgres;

create operator pg_catalog.+ (procedure = int2up, rightarg = smallint);

comment on operator pg_catalog.+(none , smallint) is 'unary plus';

alter operator pg_catalog.+(none, smallint) owner to postgres;

create operator pg_catalog.+ (procedure = int4up, rightarg = integer);

comment on operator pg_catalog.+(none , integer) is 'unary plus';

alter operator pg_catalog.+(none, integer) owner to postgres;

create operator pg_catalog.+ (procedure = float4up, rightarg = real);

comment on operator pg_catalog.+(none , real) is 'unary plus';

alter operator pg_catalog.+(none, real) owner to postgres;

create operator pg_catalog.+ (procedure = float8up, rightarg = double precision);

comment on operator pg_catalog.+(none , double precision) is 'unary plus';

alter operator pg_catalog.+(none, double precision) owner to postgres;

create operator pg_catalog.+ (procedure = numeric_uplus, rightarg = numeric);

comment on operator pg_catalog.+(none , numeric) is 'unary plus';

alter operator pg_catalog.+(none, numeric) owner to postgres;

create operator pg_catalog.= (procedure = byteaeq, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.=(bytea , bytea) is 'equal';

alter operator pg_catalog.=(bytea, bytea) owner to postgres;

create operator pg_catalog.<> (procedure = byteane, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<>(bytea , bytea) is 'not equal';

alter operator pg_catalog.<>(bytea, bytea) owner to postgres;

create operator pg_catalog.< (procedure = bytealt, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<(bytea , bytea) is 'less than';

alter operator pg_catalog.<(bytea, bytea) owner to postgres;

create operator pg_catalog.<= (procedure = byteale, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.<=(bytea , bytea) is 'less than or equal';

alter operator pg_catalog.<=(bytea, bytea) owner to postgres;

create operator pg_catalog.> (procedure = byteagt, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.>(bytea , bytea) is 'greater than';

alter operator pg_catalog.>(bytea, bytea) owner to postgres;

create operator pg_catalog.>= (procedure = byteage, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.>=(bytea , bytea) is 'greater than or equal';

alter operator pg_catalog.>=(bytea, bytea) owner to postgres;

create operator pg_catalog.~~ (procedure = bytealike, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.~~(bytea , bytea) is 'matches LIKE expression';

alter operator pg_catalog.~~(bytea, bytea) owner to postgres;

create operator pg_catalog.!~~ (procedure = byteanlike, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.!~~(bytea , bytea) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(bytea, bytea) owner to postgres;

create operator pg_catalog.|| (procedure = byteacat, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.||(bytea , bytea) is 'concatenate';

alter operator pg_catalog.||(bytea, bytea) owner to postgres;

create operator pg_catalog.= (procedure = timestamp_eq, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.=(timestamp , timestamp) is 'equal';

alter operator pg_catalog.=(timestamp, timestamp) owner to postgres;

create operator pg_catalog.<> (procedure = timestamp_ne, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<>(timestamp , timestamp) is 'not equal';

alter operator pg_catalog.<>(timestamp, timestamp) owner to postgres;

create operator pg_catalog.< (procedure = timestamp_lt, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<(timestamp , timestamp) is 'less than';

alter operator pg_catalog.<(timestamp, timestamp) owner to postgres;

create operator pg_catalog.<= (procedure = timestamp_le, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.<=(timestamp , timestamp) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, timestamp) owner to postgres;

create operator pg_catalog.> (procedure = timestamp_gt, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.>(timestamp , timestamp) is 'greater than';

alter operator pg_catalog.>(timestamp, timestamp) owner to postgres;

create operator pg_catalog.>= (procedure = timestamp_ge, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.>=(timestamp , timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, timestamp) owner to postgres;

create operator pg_catalog.+ (procedure = timestamp_pl_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.+(timestamp , interval) is 'add';

alter operator pg_catalog.+(timestamp, interval) owner to postgres;

create operator pg_catalog.- (procedure = timestamp_mi, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.-(timestamp , timestamp) is 'subtract';

alter operator pg_catalog.-(timestamp, timestamp) owner to postgres;

create operator pg_catalog.- (procedure = timestamp_mi_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.-(timestamp , interval) is 'subtract';

alter operator pg_catalog.-(timestamp, interval) owner to postgres;

create operator pg_catalog.~<~ (procedure = text_pattern_lt, leftarg = text, rightarg = text);

comment on operator pg_catalog.~<~(text , text) is 'less than';

alter operator pg_catalog.~<~(text, text) owner to postgres;

create operator pg_catalog.~<=~ (procedure = text_pattern_le, leftarg = text, rightarg = text);

comment on operator pg_catalog.~<=~(text , text) is 'less than or equal';

alter operator pg_catalog.~<=~(text, text) owner to postgres;

create operator pg_catalog.~>=~ (procedure = text_pattern_ge, leftarg = text, rightarg = text);

comment on operator pg_catalog.~>=~(text , text) is 'greater than or equal';

alter operator pg_catalog.~>=~(text, text) owner to postgres;

create operator pg_catalog.~>~ (procedure = text_pattern_gt, leftarg = text, rightarg = text);

comment on operator pg_catalog.~>~(text , text) is 'greater than';

alter operator pg_catalog.~>~(text, text) owner to postgres;

create operator pg_catalog.~<~ (procedure = bpchar_pattern_lt, leftarg = char, rightarg = char);

comment on operator pg_catalog.~<~(char , char) is 'less than';

alter operator pg_catalog.~<~(char, char) owner to postgres;

create operator pg_catalog.~<=~ (procedure = bpchar_pattern_le, leftarg = char, rightarg = char);

comment on operator pg_catalog.~<=~(char , char) is 'less than or equal';

alter operator pg_catalog.~<=~(char, char) owner to postgres;

create operator pg_catalog.~>=~ (procedure = bpchar_pattern_ge, leftarg = char, rightarg = char);

comment on operator pg_catalog.~>=~(char , char) is 'greater than or equal';

alter operator pg_catalog.~>=~(char, char) owner to postgres;

create operator pg_catalog.~>~ (procedure = bpchar_pattern_gt, leftarg = char, rightarg = char);

comment on operator pg_catalog.~>~(char , char) is 'greater than';

alter operator pg_catalog.~>~(char, char) owner to postgres;

create operator pg_catalog.< (procedure = date_lt_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<(date , timestamp) is 'less than';

alter operator pg_catalog.<(date, timestamp) owner to postgres;

create operator pg_catalog.<= (procedure = date_le_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<=(date , timestamp) is 'less than or equal';

alter operator pg_catalog.<=(date, timestamp) owner to postgres;

create operator pg_catalog.= (procedure = date_eq_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.=(date , timestamp) is 'equal';

alter operator pg_catalog.=(date, timestamp) owner to postgres;

create operator pg_catalog.>= (procedure = date_ge_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.>=(date , timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(date, timestamp) owner to postgres;

create operator pg_catalog.> (procedure = date_gt_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.>(date , timestamp) is 'greater than';

alter operator pg_catalog.>(date, timestamp) owner to postgres;

create operator pg_catalog.<> (procedure = date_ne_timestamp, leftarg = date, rightarg = timestamp);

comment on operator pg_catalog.<>(date , timestamp) is 'not equal';

alter operator pg_catalog.<>(date, timestamp) owner to postgres;

create operator pg_catalog.< (procedure = date_lt_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(date , timestamp with time zone) is 'less than';

alter operator pg_catalog.<(date, timestamp with time zone) owner to postgres;

create operator pg_catalog.<= (procedure = date_le_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(date , timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(date, timestamp with time zone) owner to postgres;

create operator pg_catalog.= (procedure = date_eq_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(date , timestamp with time zone) is 'equal';

alter operator pg_catalog.=(date, timestamp with time zone) owner to postgres;

create operator pg_catalog.>= (procedure = date_ge_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(date , timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(date, timestamp with time zone) owner to postgres;

create operator pg_catalog.> (procedure = date_gt_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(date , timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(date, timestamp with time zone) owner to postgres;

create operator pg_catalog.<> (procedure = date_ne_timestamptz, leftarg = date, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(date , timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(date, timestamp with time zone) owner to postgres;

create operator pg_catalog.< (procedure = timestamp_lt_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<(timestamp , date) is 'less than';

alter operator pg_catalog.<(timestamp, date) owner to postgres;

create operator pg_catalog.<= (procedure = timestamp_le_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<=(timestamp , date) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, date) owner to postgres;

create operator pg_catalog.= (procedure = timestamp_eq_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.=(timestamp , date) is 'equal';

alter operator pg_catalog.=(timestamp, date) owner to postgres;

create operator pg_catalog.>= (procedure = timestamp_ge_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.>=(timestamp , date) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, date) owner to postgres;

create operator pg_catalog.> (procedure = timestamp_gt_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.>(timestamp , date) is 'greater than';

alter operator pg_catalog.>(timestamp, date) owner to postgres;

create operator pg_catalog.<> (procedure = timestamp_ne_date, leftarg = timestamp, rightarg = date);

comment on operator pg_catalog.<>(timestamp , date) is 'not equal';

alter operator pg_catalog.<>(timestamp, date) owner to postgres;

create operator pg_catalog.< (procedure = timestamptz_lt_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<(timestamp with time zone , date) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, date) owner to postgres;

create operator pg_catalog.<= (procedure = timestamptz_le_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<=(timestamp with time zone , date) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, date) owner to postgres;

create operator pg_catalog.= (procedure = timestamptz_eq_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.=(timestamp with time zone , date) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, date) owner to postgres;

create operator pg_catalog.>= (procedure = timestamptz_ge_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.>=(timestamp with time zone , date) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, date) owner to postgres;

create operator pg_catalog.> (procedure = timestamptz_gt_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.>(timestamp with time zone , date) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, date) owner to postgres;

create operator pg_catalog.<> (procedure = timestamptz_ne_date, leftarg = timestamp with time zone, rightarg = date);

comment on operator pg_catalog.<>(timestamp with time zone , date) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, date) owner to postgres;

create operator pg_catalog.< (procedure = timestamp_lt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<(timestamp , timestamp with time zone) is 'less than';

alter operator pg_catalog.<(timestamp, timestamp with time zone) owner to postgres;

create operator pg_catalog.<= (procedure = timestamp_le_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<=(timestamp , timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, timestamp with time zone) owner to postgres;

create operator pg_catalog.= (procedure = timestamp_eq_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.=(timestamp , timestamp with time zone) is 'equal';

alter operator pg_catalog.=(timestamp, timestamp with time zone) owner to postgres;

create operator pg_catalog.>= (procedure = timestamp_ge_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.>=(timestamp , timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, timestamp with time zone) owner to postgres;

create operator pg_catalog.> (procedure = timestamp_gt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.>(timestamp , timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(timestamp, timestamp with time zone) owner to postgres;

create operator pg_catalog.<> (procedure = timestamp_ne_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone);

comment on operator pg_catalog.<>(timestamp , timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(timestamp, timestamp with time zone) owner to postgres;

create operator pg_catalog.< (procedure = timestamptz_lt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<(timestamp with time zone , timestamp) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, timestamp) owner to postgres;

create operator pg_catalog.<= (procedure = timestamptz_le_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<=(timestamp with time zone , timestamp) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, timestamp) owner to postgres;

create operator pg_catalog.= (procedure = timestamptz_eq_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.=(timestamp with time zone , timestamp) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, timestamp) owner to postgres;

create operator pg_catalog.>= (procedure = timestamptz_ge_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.>=(timestamp with time zone , timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, timestamp) owner to postgres;

create operator pg_catalog.> (procedure = timestamptz_gt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.>(timestamp with time zone , timestamp) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, timestamp) owner to postgres;

create operator pg_catalog.<> (procedure = timestamptz_ne_timestamp, leftarg = timestamp with time zone, rightarg = timestamp);

comment on operator pg_catalog.<>(timestamp with time zone , timestamp) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, timestamp) owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_date, leftarg = interval, rightarg = date);

comment on operator pg_catalog.+(interval , date) is 'add';

alter operator pg_catalog.+(interval, date) owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_timetz, leftarg = interval, rightarg = time with time zone);

comment on operator pg_catalog.+(interval , time with time zone) is 'add';

alter operator pg_catalog.+(interval, time with time zone) owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_timestamp, leftarg = interval, rightarg = timestamp);

comment on operator pg_catalog.+(interval , timestamp) is 'add';

alter operator pg_catalog.+(interval, timestamp) owner to postgres;

create operator pg_catalog.+ (procedure = interval_pl_timestamptz, leftarg = interval, rightarg = timestamp with time zone);

comment on operator pg_catalog.+(interval , timestamp with time zone) is 'add';

alter operator pg_catalog.+(interval, timestamp with time zone) owner to postgres;

create operator pg_catalog.+ (procedure = integer_pl_date, leftarg = integer, rightarg = date);

comment on operator pg_catalog.+(integer , date) is 'add';

alter operator pg_catalog.+(integer, date) owner to postgres;

create operator pg_catalog.<<| (procedure = box_below, leftarg = box, rightarg = box);

comment on operator pg_catalog.<<|(box , box) is 'is below';

alter operator pg_catalog.<<|(box, box) owner to postgres;

create operator pg_catalog.&<| (procedure = box_overbelow, leftarg = box, rightarg = box);

comment on operator pg_catalog.&<|(box , box) is 'overlaps or is below';

alter operator pg_catalog.&<|(box, box) owner to postgres;

create operator pg_catalog.|&> (procedure = box_overabove, leftarg = box, rightarg = box);

comment on operator pg_catalog.|&>(box , box) is 'overlaps or is above';

alter operator pg_catalog.|&>(box, box) owner to postgres;

create operator pg_catalog.|>> (procedure = box_above, leftarg = box, rightarg = box);

comment on operator pg_catalog.|>>(box , box) is 'is above';

alter operator pg_catalog.|>>(box, box) owner to postgres;

create operator pg_catalog.<<| (procedure = poly_below, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.<<|(polygon , polygon) is 'is below';

alter operator pg_catalog.<<|(polygon, polygon) owner to postgres;

create operator pg_catalog.&<| (procedure = poly_overbelow, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.&<|(polygon , polygon) is 'overlaps or is below';

alter operator pg_catalog.&<|(polygon, polygon) owner to postgres;

create operator pg_catalog.|&> (procedure = poly_overabove, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.|&>(polygon , polygon) is 'overlaps or is above';

alter operator pg_catalog.|&>(polygon, polygon) owner to postgres;

create operator pg_catalog.|>> (procedure = poly_above, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.|>>(polygon , polygon) is 'is above';

alter operator pg_catalog.|>>(polygon, polygon) owner to postgres;

create operator pg_catalog.&<| (procedure = circle_overbelow, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.&<|(circle , circle) is 'overlaps or is below';

alter operator pg_catalog.&<|(circle, circle) owner to postgres;

create operator pg_catalog.|&> (procedure = circle_overabove, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.|&>(circle , circle) is 'overlaps or is above';

alter operator pg_catalog.|&>(circle, circle) owner to postgres;

create operator pg_catalog.~ (procedure = inetnot, rightarg = inet);

comment on operator pg_catalog.~(none , inet) is 'bitwise not';

alter operator pg_catalog.~(none, inet) owner to postgres;

create operator pg_catalog.& (procedure = inetand, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&(inet , inet) is 'bitwise and';

alter operator pg_catalog.&(inet, inet) owner to postgres;

create operator pg_catalog.| (procedure = inetor, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.|(inet , inet) is 'bitwise or';

alter operator pg_catalog.|(inet, inet) owner to postgres;

create operator pg_catalog.+ (procedure = inetpl, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.+(inet , bigint) is 'add';

alter operator pg_catalog.+(inet, bigint) owner to postgres;

create operator pg_catalog.+ (procedure = int8pl_inet, leftarg = bigint, rightarg = inet);

comment on operator pg_catalog.+(bigint , inet) is 'add';

alter operator pg_catalog.+(bigint, inet) owner to postgres;

create operator pg_catalog.- (procedure = inetmi_int8, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.-(inet , bigint) is 'subtract';

alter operator pg_catalog.-(inet, bigint) owner to postgres;

create operator pg_catalog.- (procedure = inetmi, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.-(inet , inet) is 'subtract';

alter operator pg_catalog.-(inet, inet) owner to postgres;

create operator pg_catalog.&& (procedure = arrayoverlap, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.&&(anyarray , anyarray) is 'overlaps';

alter operator pg_catalog.&&(anyarray, anyarray) owner to postgres;

create operator pg_catalog.@> (procedure = arraycontains, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.@>(anyarray , anyarray) is 'contains';

alter operator pg_catalog.@>(anyarray, anyarray) owner to postgres;

create operator pg_catalog.<@ (procedure = arraycontained, leftarg = anyarray, rightarg = anyarray);

comment on operator pg_catalog.<@(anyarray , anyarray) is 'is contained by';

alter operator pg_catalog.<@(anyarray, anyarray) owner to postgres;

create operator pg_catalog.|| (procedure = textanycat, leftarg = text, rightarg = anynonarray);

comment on operator pg_catalog.||(text , anynonarray) is 'concatenate';

alter operator pg_catalog.||(text, anynonarray) owner to postgres;

create operator pg_catalog.|| (procedure = anytextcat, leftarg = anynonarray, rightarg = text);

comment on operator pg_catalog.||(anynonarray , text) is 'concatenate';

alter operator pg_catalog.||(anynonarray, text) owner to postgres;

create operator pg_catalog.< (procedure = tidlt, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<(tid , tid) is 'less than';

alter operator pg_catalog.<(tid, tid) owner to postgres;

create operator pg_catalog.> (procedure = tidgt, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.>(tid , tid) is 'greater than';

alter operator pg_catalog.>(tid, tid) owner to postgres;

create operator pg_catalog.<= (procedure = tidle, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.<=(tid , tid) is 'less than or equal';

alter operator pg_catalog.<=(tid, tid) owner to postgres;

create operator pg_catalog.>= (procedure = tidge, leftarg = tid, rightarg = tid);

comment on operator pg_catalog.>=(tid , tid) is 'greater than or equal';

alter operator pg_catalog.>=(tid, tid) owner to postgres;

create operator pg_catalog.@ (procedure = poly_contained, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.@(polygon , polygon) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(polygon, polygon) owner to postgres;

create operator pg_catalog.~ (procedure = poly_contain, leftarg = polygon, rightarg = polygon);

comment on operator pg_catalog.~(polygon , polygon) is 'deprecated, use @> instead';

alter operator pg_catalog.~(polygon, polygon) owner to postgres;

create operator pg_catalog.@ (procedure = box_contained, leftarg = box, rightarg = box);

comment on operator pg_catalog.@(box , box) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(box, box) owner to postgres;

create operator pg_catalog.~ (procedure = box_contain, leftarg = box, rightarg = box);

comment on operator pg_catalog.~(box , box) is 'deprecated, use @> instead';

alter operator pg_catalog.~(box, box) owner to postgres;

create operator pg_catalog.@ (procedure = circle_contained, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.@(circle , circle) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(circle, circle) owner to postgres;

create operator pg_catalog.~ (procedure = circle_contain, leftarg = circle, rightarg = circle);

comment on operator pg_catalog.~(circle , circle) is 'deprecated, use @> instead';

alter operator pg_catalog.~(circle, circle) owner to postgres;

create operator pg_catalog.@ (procedure = on_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.@(point , box) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, box) owner to postgres;

create operator pg_catalog.@ (procedure = on_ppath, leftarg = point, rightarg = path);

comment on operator pg_catalog.@(point , path) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, path) owner to postgres;

create operator pg_catalog.~ (procedure = path_contain_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.~(path , point) is 'deprecated, use @> instead';

alter operator pg_catalog.~(path, point) owner to postgres;

create operator pg_catalog.@ (procedure = pt_contained_poly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.@(point , polygon) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, polygon) owner to postgres;

create operator pg_catalog.~ (procedure = poly_contain_pt, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.~(polygon , point) is 'deprecated, use @> instead';

alter operator pg_catalog.~(polygon, point) owner to postgres;

create operator pg_catalog.@ (procedure = pt_contained_circle, leftarg = point, rightarg = circle);

comment on operator pg_catalog.@(point , circle) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, circle) owner to postgres;

create operator pg_catalog.~ (procedure = circle_contain_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.~(circle , point) is 'deprecated, use @> instead';

alter operator pg_catalog.~(circle, point) owner to postgres;

create operator pg_catalog.@ (procedure = on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.@(point , line) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, line) owner to postgres;

create operator pg_catalog.@ (procedure = on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.@(point , lseg) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(point, lseg) owner to postgres;

create operator pg_catalog.@ (procedure = on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.@(lseg , line) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(lseg, line) owner to postgres;

create operator pg_catalog.@ (procedure = on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.@(lseg , box) is 'deprecated, use <@ instead';

alter operator pg_catalog.@(lseg, box) owner to postgres;

create operator pg_catalog.~ (procedure = aclcontains, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.~(aclitem[] , aclitem) is 'deprecated, use @> instead';

alter operator pg_catalog.~(aclitem[], aclitem) owner to postgres;

create operator pg_catalog.= (procedure = uuid_eq, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.=(uuid , uuid) is 'equal';

alter operator pg_catalog.=(uuid, uuid) owner to postgres;

create operator pg_catalog.<> (procedure = uuid_ne, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<>(uuid , uuid) is 'not equal';

alter operator pg_catalog.<>(uuid, uuid) owner to postgres;

create operator pg_catalog.< (procedure = uuid_lt, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<(uuid , uuid) is 'less than';

alter operator pg_catalog.<(uuid, uuid) owner to postgres;

create operator pg_catalog.> (procedure = uuid_gt, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.>(uuid , uuid) is 'greater than';

alter operator pg_catalog.>(uuid, uuid) owner to postgres;

create operator pg_catalog.<= (procedure = uuid_le, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.<=(uuid , uuid) is 'less than or equal';

alter operator pg_catalog.<=(uuid, uuid) owner to postgres;

create operator pg_catalog.>= (procedure = uuid_ge, leftarg = uuid, rightarg = uuid);

comment on operator pg_catalog.>=(uuid , uuid) is 'greater than or equal';

alter operator pg_catalog.>=(uuid, uuid) owner to postgres;

create operator pg_catalog.= (procedure = record_eq, leftarg = record, rightarg = record);

comment on operator pg_catalog.=(record , record) is 'equal';

alter operator pg_catalog.=(record, record) owner to postgres;

create operator pg_catalog.<> (procedure = record_ne, leftarg = record, rightarg = record);

comment on operator pg_catalog.<>(record , record) is 'not equal';

alter operator pg_catalog.<>(record, record) owner to postgres;

create operator pg_catalog.< (procedure = record_lt, leftarg = record, rightarg = record);

comment on operator pg_catalog.<(record , record) is 'less than';

alter operator pg_catalog.<(record, record) owner to postgres;

create operator pg_catalog.> (procedure = record_gt, leftarg = record, rightarg = record);

comment on operator pg_catalog.>(record , record) is 'greater than';

alter operator pg_catalog.>(record, record) owner to postgres;

create operator pg_catalog.<= (procedure = record_le, leftarg = record, rightarg = record);

comment on operator pg_catalog.<=(record , record) is 'less than or equal';

alter operator pg_catalog.<=(record, record) owner to postgres;

create operator pg_catalog.>= (procedure = record_ge, leftarg = record, rightarg = record);

comment on operator pg_catalog.>=(record , record) is 'greater than or equal';

alter operator pg_catalog.>=(record, record) owner to postgres;

create operator pg_catalog.~ (procedure = macaddr_not, rightarg = macaddr);

comment on operator pg_catalog.~(none , macaddr) is 'bitwise not';

alter operator pg_catalog.~(none, macaddr) owner to postgres;

create operator pg_catalog.& (procedure = macaddr_and, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.&(macaddr , macaddr) is 'bitwise and';

alter operator pg_catalog.&(macaddr, macaddr) owner to postgres;

create operator pg_catalog.| (procedure = macaddr_or, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.|(macaddr , macaddr) is 'bitwise or';

alter operator pg_catalog.|(macaddr, macaddr) owner to postgres;

create operator pg_catalog.*= (procedure = record_image_eq, leftarg = record, rightarg = record);

comment on operator pg_catalog.*=(record , record) is 'identical';

alter operator pg_catalog.*=(record, record) owner to postgres;

create operator pg_catalog.*<> (procedure = record_image_ne, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<>(record , record) is 'not identical';

alter operator pg_catalog.*<>(record, record) owner to postgres;

create operator pg_catalog.*< (procedure = record_image_lt, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<(record , record) is 'less than';

alter operator pg_catalog.*<(record, record) owner to postgres;

create operator pg_catalog.*> (procedure = record_image_gt, leftarg = record, rightarg = record);

comment on operator pg_catalog.*>(record , record) is 'greater than';

alter operator pg_catalog.*>(record, record) owner to postgres;

create operator pg_catalog.*<= (procedure = record_image_le, leftarg = record, rightarg = record);

comment on operator pg_catalog.*<=(record , record) is 'less than or equal';

alter operator pg_catalog.*<=(record, record) owner to postgres;

create operator pg_catalog.*>= (procedure = record_image_ge, leftarg = record, rightarg = record);

comment on operator pg_catalog.*>=(record , record) is 'greater than or equal';

alter operator pg_catalog.*>=(record, record) owner to postgres;

create operator pg_catalog.#>> (procedure = jsonb_extract_path_text, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>>(jsonb , text[]) is 'get value from jsonb as text with path elements';

alter operator pg_catalog.#>>(jsonb, text[]) owner to postgres;

create operator pg_catalog.-> (procedure = jsonb_object_field, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->(jsonb , text) is 'get jsonb object field';

alter operator pg_catalog.->(jsonb, text) owner to postgres;

create operator pg_catalog.-> (procedure = jsonb_array_element, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->(jsonb , integer) is 'get jsonb array element';

alter operator pg_catalog.->(jsonb, integer) owner to postgres;

create operator pg_catalog.#> (procedure = jsonb_extract_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>(jsonb , text[]) is 'get value from jsonb with path elements';

alter operator pg_catalog.#>(jsonb, text[]) owner to postgres;

create operator pg_catalog.= (procedure = pg_lsn_eq, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.=(pg_lsn , pg_lsn) is 'equal';

alter operator pg_catalog.=(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.<> (procedure = pg_lsn_ne, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<>(pg_lsn , pg_lsn) is 'not equal';

alter operator pg_catalog.<>(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.< (procedure = pg_lsn_lt, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<(pg_lsn , pg_lsn) is 'less than';

alter operator pg_catalog.<(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.> (procedure = pg_lsn_gt, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.>(pg_lsn , pg_lsn) is 'greater than';

alter operator pg_catalog.>(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.<= (procedure = pg_lsn_le, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.<=(pg_lsn , pg_lsn) is 'less than or equal';

alter operator pg_catalog.<=(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.>= (procedure = pg_lsn_ge, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.>=(pg_lsn , pg_lsn) is 'greater than or equal';

alter operator pg_catalog.>=(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.- (procedure = pg_lsn_mi, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.-(pg_lsn , pg_lsn) is 'minus';

alter operator pg_catalog.-(pg_lsn, pg_lsn) owner to postgres;

create operator pg_catalog.= (procedure = jsonb_eq, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.=(jsonb , jsonb) is 'equal';

alter operator pg_catalog.=(jsonb, jsonb) owner to postgres;

create operator pg_catalog.<> (procedure = jsonb_ne, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<>(jsonb , jsonb) is 'not equal';

alter operator pg_catalog.<>(jsonb, jsonb) owner to postgres;

create operator pg_catalog.< (procedure = jsonb_lt, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<(jsonb , jsonb) is 'less than';

alter operator pg_catalog.<(jsonb, jsonb) owner to postgres;

create operator pg_catalog.> (procedure = jsonb_gt, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.>(jsonb , jsonb) is 'greater than';

alter operator pg_catalog.>(jsonb, jsonb) owner to postgres;

create operator pg_catalog.<= (procedure = jsonb_le, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<=(jsonb , jsonb) is 'less than or equal';

alter operator pg_catalog.<=(jsonb, jsonb) owner to postgres;

create operator pg_catalog.>= (procedure = jsonb_ge, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.>=(jsonb , jsonb) is 'greater than or equal';

alter operator pg_catalog.>=(jsonb, jsonb) owner to postgres;

create operator pg_catalog.@> (procedure = jsonb_contains, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.@>(jsonb , jsonb) is 'contains';

alter operator pg_catalog.@>(jsonb, jsonb) owner to postgres;

create operator pg_catalog.? (procedure = jsonb_exists, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.?(jsonb , text) is 'key exists';

alter
operator
pg_catalog
.
?
    (jsonb, text)
    owner to postgres;

create operator pg_catalog.?| (procedure = jsonb_exists_any, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.?|(jsonb , text[]) is 'any key exists';

alter operator pg_catalog.?|(jsonb, text[]) owner to postgres;

create operator pg_catalog.?& (procedure = jsonb_exists_all, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.?&(jsonb , text[]) is 'all keys exist';

alter operator pg_catalog.?&(jsonb, text[]) owner to postgres;

create operator pg_catalog.<@ (procedure = jsonb_contained, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.<@(jsonb , jsonb) is 'is contained by';

alter operator pg_catalog.<@(jsonb, jsonb) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_ppoly, leftarg = point, rightarg = polygon);

comment on operator pg_catalog.<->(point , polygon) is 'distance between';

alter operator pg_catalog.<->(point, polygon) owner to postgres;

create operator pg_catalog.|| (procedure = jsonb_concat, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.||(jsonb , jsonb) is 'concatenate';

alter operator pg_catalog.||(jsonb, jsonb) owner to postgres;

create operator pg_catalog.- (procedure = "pg_catalog.jsonb_delete", leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.-(jsonb , text) is 'delete object field';

alter operator pg_catalog.-(jsonb, text) owner to postgres;

create operator pg_catalog.- (procedure = "pg_catalog.jsonb_delete", leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.-(jsonb , integer) is 'delete array element';

alter operator pg_catalog.-(jsonb, integer) owner to postgres;

create operator pg_catalog.#- (procedure = jsonb_delete_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#-(jsonb , text[]) is 'delete path';

alter operator pg_catalog.#-(jsonb, text[]) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_polyp, leftarg = polygon, rightarg = point);

comment on operator pg_catalog.<->(polygon , point) is 'distance between';

alter operator pg_catalog.<->(polygon, point) owner to postgres;

create operator pg_catalog.<-> (procedure = dist_cpoint, leftarg = circle, rightarg = point);

comment on operator pg_catalog.<->(circle , point) is 'distance between';

alter operator pg_catalog.<->(circle, point) owner to postgres;

create operator pg_catalog.<> (procedure = xidneq, leftarg = xid, rightarg = xid);

comment on operator pg_catalog.<>(xid , xid) is 'not equal';

alter operator pg_catalog.<>(xid, xid) owner to postgres;

create operator pg_catalog.<> (procedure = xidneqint4, leftarg = xid, rightarg = integer);

comment on operator pg_catalog.<>(xid , integer) is 'not equal';

alter operator pg_catalog.<>(xid, integer) owner to postgres;

create operator pg_catalog.->> (procedure = jsonb_object_field_text, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->>(jsonb , text) is 'get jsonb object field as text';

alter operator pg_catalog.->>(jsonb, text) owner to postgres;

create operator pg_catalog.->> (procedure = jsonb_array_element_text, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->>(jsonb , integer) is 'get jsonb array element as text';

alter operator pg_catalog.->>(jsonb, integer) owner to postgres;

create operator pg_catalog.= (procedure = enum_eq, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.=(anyenum , anyenum) is 'equal';

alter operator pg_catalog.=(anyenum, anyenum) owner to postgres;

create operator pg_catalog.<> (procedure = enum_ne, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<>(anyenum , anyenum) is 'not equal';

alter operator pg_catalog.<>(anyenum, anyenum) owner to postgres;

create operator pg_catalog.< (procedure = enum_lt, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<(anyenum , anyenum) is 'less than';

alter operator pg_catalog.<(anyenum, anyenum) owner to postgres;

create operator pg_catalog.> (procedure = enum_gt, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.>(anyenum , anyenum) is 'greater than';

alter operator pg_catalog.>(anyenum, anyenum) owner to postgres;

create operator pg_catalog.<= (procedure = enum_le, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.<=(anyenum , anyenum) is 'less than or equal';

alter operator pg_catalog.<=(anyenum, anyenum) owner to postgres;

create operator pg_catalog.>= (procedure = enum_ge, leftarg = anyenum, rightarg = anyenum);

comment on operator pg_catalog.>=(anyenum , anyenum) is 'greater than or equal';

alter operator pg_catalog.>=(anyenum, anyenum) owner to postgres;

create operator pg_catalog.&& (procedure = network_overlap, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&&(inet , inet) is 'overlaps (is subnet or supernet)';

alter operator pg_catalog.&&(inet, inet) owner to postgres;

create operator pg_catalog.< (procedure = tsvector_lt, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<(tsvector , tsvector) is 'less than';

alter operator pg_catalog.<(tsvector, tsvector) owner to postgres;

create operator pg_catalog.<= (procedure = tsvector_le, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<=(tsvector , tsvector) is 'less than or equal';

alter operator pg_catalog.<=(tsvector, tsvector) owner to postgres;

create operator pg_catalog.= (procedure = tsvector_eq, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.=(tsvector , tsvector) is 'equal';

alter operator pg_catalog.=(tsvector, tsvector) owner to postgres;

create operator pg_catalog.<> (procedure = tsvector_ne, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.<>(tsvector , tsvector) is 'not equal';

alter operator pg_catalog.<>(tsvector, tsvector) owner to postgres;

create operator pg_catalog.>= (procedure = tsvector_ge, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.>=(tsvector , tsvector) is 'greater than or equal';

alter operator pg_catalog.>=(tsvector, tsvector) owner to postgres;

create operator pg_catalog.> (procedure = tsvector_gt, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.>(tsvector , tsvector) is 'greater than';

alter operator pg_catalog.>(tsvector, tsvector) owner to postgres;

create operator pg_catalog.|| (procedure = tsvector_concat, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.||(tsvector , tsvector) is 'concatenate';

alter operator pg_catalog.||(tsvector, tsvector) owner to postgres;

create operator pg_catalog.@@ (procedure = ts_match_vq, leftarg = tsvector, rightarg = tsquery);

comment on operator pg_catalog.@@(tsvector , tsquery) is 'text search match';

alter operator pg_catalog.@@(tsvector, tsquery) owner to postgres;

create operator pg_catalog.@@ (procedure = ts_match_qv, leftarg = tsquery, rightarg = tsvector);

comment on operator pg_catalog.@@(tsquery , tsvector) is 'text search match';

alter operator pg_catalog.@@(tsquery, tsvector) owner to postgres;

create operator pg_catalog.@@@ (procedure = ts_match_vq, leftarg = tsvector, rightarg = tsquery);

comment on operator pg_catalog.@@@(tsvector , tsquery) is 'deprecated, use @@ instead';

alter operator pg_catalog.@@@(tsvector, tsquery) owner to postgres;

create operator pg_catalog.@@@ (procedure = ts_match_qv, leftarg = tsquery, rightarg = tsvector);

comment on operator pg_catalog.@@@(tsquery , tsvector) is 'deprecated, use @@ instead';

alter operator pg_catalog.@@@(tsquery, tsvector) owner to postgres;

create operator pg_catalog.< (procedure = tsquery_lt, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<(tsquery , tsquery) is 'less than';

alter operator pg_catalog.<(tsquery, tsquery) owner to postgres;

create operator pg_catalog.<= (procedure = tsquery_le, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<=(tsquery , tsquery) is 'less than or equal';

alter operator pg_catalog.<=(tsquery, tsquery) owner to postgres;

create operator pg_catalog.= (procedure = tsquery_eq, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.=(tsquery , tsquery) is 'equal';

alter operator pg_catalog.=(tsquery, tsquery) owner to postgres;

create operator pg_catalog.<> (procedure = tsquery_ne, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<>(tsquery , tsquery) is 'not equal';

alter operator pg_catalog.<>(tsquery, tsquery) owner to postgres;

create operator pg_catalog.>= (procedure = tsquery_ge, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.>=(tsquery , tsquery) is 'greater than or equal';

alter operator pg_catalog.>=(tsquery, tsquery) owner to postgres;

create operator pg_catalog.> (procedure = tsquery_gt, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.>(tsquery , tsquery) is 'greater than';

alter operator pg_catalog.>(tsquery, tsquery) owner to postgres;

create operator pg_catalog.&& (procedure = tsquery_and, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.&&(tsquery , tsquery) is 'AND-concatenate';

alter operator pg_catalog.&&(tsquery, tsquery) owner to postgres;

create operator pg_catalog.|| (procedure = tsquery_or, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.||(tsquery , tsquery) is 'OR-concatenate';

alter operator pg_catalog.||(tsquery, tsquery) owner to postgres;

create operator pg_catalog.!! (procedure = tsquery_not, rightarg = tsquery);

comment on operator pg_catalog.!!(none , tsquery) is 'NOT tsquery';

alter operator pg_catalog.!!(none, tsquery) owner to postgres;

create operator pg_catalog.@> (procedure = tsq_mcontains, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.@>(tsquery , tsquery) is 'contains';

alter operator pg_catalog.@>(tsquery, tsquery) owner to postgres;

create operator pg_catalog.<@ (procedure = tsq_mcontained, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<@(tsquery , tsquery) is 'is contained by';

alter operator pg_catalog.<@(tsquery, tsquery) owner to postgres;

create operator pg_catalog.@@ (procedure = ts_match_tt, leftarg = text, rightarg = text);

comment on operator pg_catalog.@@(text , text) is 'text search match';

alter operator pg_catalog.@@(text, text) owner to postgres;

create operator pg_catalog.@@ (procedure = ts_match_tq, leftarg = text, rightarg = tsquery);

comment on operator pg_catalog.@@(text , tsquery) is 'text search match';

alter operator pg_catalog.@@(text, tsquery) owner to postgres;

create operator pg_catalog./ (procedure = cash_div_cash, leftarg = money, rightarg = money);

comment on operator pg_catalog./(money , money) is 'divide';

alter operator pg_catalog./(money, money) owner to postgres;

create operator pg_catalog.= (procedure = range_eq, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.=(anyrange , anyrange) is 'equal';

alter operator pg_catalog.=(anyrange, anyrange) owner to postgres;

create operator pg_catalog.<> (procedure = range_ne, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<>(anyrange , anyrange) is 'not equal';

alter operator pg_catalog.<>(anyrange, anyrange) owner to postgres;

create operator pg_catalog.< (procedure = range_lt, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<(anyrange , anyrange) is 'less than';

alter operator pg_catalog.<(anyrange, anyrange) owner to postgres;

create operator pg_catalog.<= (procedure = range_le, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<=(anyrange , anyrange) is 'less than or equal';

alter operator pg_catalog.<=(anyrange, anyrange) owner to postgres;

create operator pg_catalog.>= (procedure = range_ge, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>=(anyrange , anyrange) is 'greater than or equal';

alter operator pg_catalog.>=(anyrange, anyrange) owner to postgres;

create operator pg_catalog.> (procedure = range_gt, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>(anyrange , anyrange) is 'greater than';

alter operator pg_catalog.>(anyrange, anyrange) owner to postgres;

create operator pg_catalog.&& (procedure = range_overlaps, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&&(anyrange , anyrange) is 'overlaps';

alter operator pg_catalog.&&(anyrange, anyrange) owner to postgres;

create operator pg_catalog.@> (procedure = range_contains_elem, leftarg = anyrange, rightarg = anyelement);

comment on operator pg_catalog.@>(anyrange , anyelement) is 'contains';

alter operator pg_catalog.@>(anyrange, anyelement) owner to postgres;

create operator pg_catalog.@> (procedure = range_contains, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.@>(anyrange , anyrange) is 'contains';

alter operator pg_catalog.@>(anyrange, anyrange) owner to postgres;

create operator pg_catalog.<@ (procedure = elem_contained_by_range, leftarg = anyelement, rightarg = anyrange);

comment on operator pg_catalog.<@(anyelement , anyrange) is 'is contained by';

alter operator pg_catalog.<@(anyelement, anyrange) owner to postgres;

create operator pg_catalog.<@ (procedure = range_contained_by, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<@(anyrange , anyrange) is 'is contained by';

alter operator pg_catalog.<@(anyrange, anyrange) owner to postgres;

create operator pg_catalog.<< (procedure = range_before, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.<<(anyrange , anyrange) is 'is left of';

alter operator pg_catalog.<<(anyrange, anyrange) owner to postgres;

create operator pg_catalog.>> (procedure = range_after, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.>>(anyrange , anyrange) is 'is right of';

alter operator pg_catalog.>>(anyrange, anyrange) owner to postgres;

create operator pg_catalog.&< (procedure = range_overleft, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&<(anyrange , anyrange) is 'overlaps or is left of';

alter operator pg_catalog.&<(anyrange, anyrange) owner to postgres;

create operator pg_catalog.&> (procedure = range_overright, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.&>(anyrange , anyrange) is 'overlaps or is right of';

alter operator pg_catalog.&>(anyrange, anyrange) owner to postgres;

create operator pg_catalog.-|- (procedure = range_adjacent, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-|-(anyrange , anyrange) is 'is adjacent to';

alter operator pg_catalog.-|-(anyrange, anyrange) owner to postgres;

create operator pg_catalog.+ (procedure = range_union, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.+(anyrange , anyrange) is 'range union';

alter operator pg_catalog.+(anyrange, anyrange) owner to postgres;

create operator pg_catalog.- (procedure = range_minus, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-(anyrange , anyrange) is 'range difference';

alter operator pg_catalog.-(anyrange, anyrange) owner to postgres;

create operator pg_catalog.* (procedure = range_intersect, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.*(anyrange , anyrange) is 'range intersection';

alter operator pg_catalog.*(anyrange, anyrange) owner to postgres;

create operator pg_catalog.-> (procedure = json_object_field, leftarg = json, rightarg = text);

comment on operator pg_catalog.->(json , text) is 'get json object field';

alter operator pg_catalog.->(json, text) owner to postgres;

create operator pg_catalog.->> (procedure = json_object_field_text, leftarg = json, rightarg = text);

comment on operator pg_catalog.->>(json , text) is 'get json object field as text';

alter operator pg_catalog.->>(json, text) owner to postgres;

create operator pg_catalog.-> (procedure = json_array_element, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->(json , integer) is 'get json array element';

alter operator pg_catalog.->(json, integer) owner to postgres;

create operator pg_catalog.->> (procedure = json_array_element_text, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->>(json , integer) is 'get json array element as text';

alter operator pg_catalog.->>(json, integer) owner to postgres;

create operator pg_catalog.#> (procedure = json_extract_path, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>(json , text[]) is 'get value from json with path elements';

alter operator pg_catalog.#>(json, text[]) owner to postgres;

create operator pg_catalog.#>> (procedure = json_extract_path_text, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>>(json , text[]) is 'get value from json as text with path elements';

alter operator pg_catalog.#>>(json, text[]) owner to postgres;

create operator pg_catalog.<-> (procedure = "pg_catalog.tsquery_phrase", leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<->(tsquery , tsquery) is 'phrase-concatenate';

alter operator pg_catalog.<->(tsquery, tsquery) owner to postgres;

comment on collation pg_catalog."default" is 'database''s default collation';

alter collation pg_catalog."default" owner to postgres;

create collation pg_catalog."C" (
    locale = 'C'
    );

comment on collation pg_catalog."C" is 'standard C collation';

alter collation pg_catalog."C" owner to postgres;

create collation pg_catalog."POSIX" (
    locale = 'POSIX'
    );

comment on collation pg_catalog."POSIX" is 'standard POSIX collation';

alter collation pg_catalog."POSIX" owner to postgres;

create collation pg_catalog."aa_DJ" (
    locale = 'aa_DJ.utf8'
    );

alter collation pg_catalog."aa_DJ" owner to postgres;

create collation pg_catalog."aa_DJ" (
    locale = 'aa_DJ'
    );

alter collation pg_catalog."aa_DJ" owner to postgres;

create collation pg_catalog."aa_DJ.iso88591" (
    locale = 'aa_DJ.iso88591'
    );

alter collation pg_catalog."aa_DJ.iso88591" owner to postgres;

create collation pg_catalog."aa_DJ.utf8" (
    locale = 'aa_DJ.utf8'
    );

alter collation pg_catalog."aa_DJ.utf8" owner to postgres;

create collation pg_catalog."aa_ER" (
    locale = 'aa_ER'
    );

alter collation pg_catalog."aa_ER" owner to postgres;

create collation pg_catalog."aa_ER.utf8" (
    locale = 'aa_ER.utf8'
    );

alter collation pg_catalog."aa_ER.utf8" owner to postgres;

create collation pg_catalog."aa_ER.utf8@saaho" (
    locale = 'aa_ER.utf8@saaho'
    );

alter collation pg_catalog."aa_ER.utf8@saaho" owner to postgres;

create collation pg_catalog."aa_ER@saaho" (
    locale = 'aa_ER@saaho'
    );

alter collation pg_catalog."aa_ER@saaho" owner to postgres;

create collation pg_catalog."aa_ET" (
    locale = 'aa_ET'
    );

alter collation pg_catalog."aa_ET" owner to postgres;

create collation pg_catalog."aa_ET.utf8" (
    locale = 'aa_ET.utf8'
    );

alter collation pg_catalog."aa_ET.utf8" owner to postgres;

create collation pg_catalog."af_ZA" (
    locale = 'af_ZA.utf8'
    );

alter collation pg_catalog."af_ZA" owner to postgres;

create collation pg_catalog."af_ZA" (
    locale = 'af_ZA'
    );

alter collation pg_catalog."af_ZA" owner to postgres;

create collation pg_catalog."af_ZA.iso88591" (
    locale = 'af_ZA.iso88591'
    );

alter collation pg_catalog."af_ZA.iso88591" owner to postgres;

create collation pg_catalog."af_ZA.utf8" (
    locale = 'af_ZA.utf8'
    );

alter collation pg_catalog."af_ZA.utf8" owner to postgres;

create collation pg_catalog."am_ET" (
    locale = 'am_ET'
    );

alter collation pg_catalog."am_ET" owner to postgres;

create collation pg_catalog."am_ET.utf8" (
    locale = 'am_ET.utf8'
    );

alter collation pg_catalog."am_ET.utf8" owner to postgres;

create collation pg_catalog."an_ES" (
    locale = 'an_ES.utf8'
    );

alter collation pg_catalog."an_ES" owner to postgres;

create collation pg_catalog."an_ES" (
    locale = 'an_ES'
    );

alter collation pg_catalog."an_ES" owner to postgres;

create collation pg_catalog."an_ES.iso885915" (
    locale = 'an_ES.iso885915'
    );

alter collation pg_catalog."an_ES.iso885915" owner to postgres;

create collation pg_catalog."an_ES.utf8" (
    locale = 'an_ES.utf8'
    );

alter collation pg_catalog."an_ES.utf8" owner to postgres;

create collation pg_catalog."ar_AE" (
    locale = 'ar_AE.utf8'
    );

alter collation pg_catalog."ar_AE" owner to postgres;

create collation pg_catalog."ar_AE" (
    locale = 'ar_AE'
    );

alter collation pg_catalog."ar_AE" owner to postgres;

create collation pg_catalog."ar_AE.iso88596" (
    locale = 'ar_AE.iso88596'
    );

alter collation pg_catalog."ar_AE.iso88596" owner to postgres;

create collation pg_catalog."ar_AE.utf8" (
    locale = 'ar_AE.utf8'
    );

alter collation pg_catalog."ar_AE.utf8" owner to postgres;

create collation pg_catalog."ar_BH" (
    locale = 'ar_BH.utf8'
    );

alter collation pg_catalog."ar_BH" owner to postgres;

create collation pg_catalog."ar_BH" (
    locale = 'ar_BH'
    );

alter collation pg_catalog."ar_BH" owner to postgres;

create collation pg_catalog."ar_BH.iso88596" (
    locale = 'ar_BH.iso88596'
    );

alter collation pg_catalog."ar_BH.iso88596" owner to postgres;

create collation pg_catalog."ar_BH.utf8" (
    locale = 'ar_BH.utf8'
    );

alter collation pg_catalog."ar_BH.utf8" owner to postgres;

create collation pg_catalog."ar_DZ" (
    locale = 'ar_DZ.utf8'
    );

alter collation pg_catalog."ar_DZ" owner to postgres;

create collation pg_catalog."ar_DZ" (
    locale = 'ar_DZ'
    );

alter collation pg_catalog."ar_DZ" owner to postgres;

create collation pg_catalog."ar_DZ.iso88596" (
    locale = 'ar_DZ.iso88596'
    );

alter collation pg_catalog."ar_DZ.iso88596" owner to postgres;

create collation pg_catalog."ar_DZ.utf8" (
    locale = 'ar_DZ.utf8'
    );

alter collation pg_catalog."ar_DZ.utf8" owner to postgres;

create collation pg_catalog."ar_EG" (
    locale = 'ar_EG.utf8'
    );

alter collation pg_catalog."ar_EG" owner to postgres;

create collation pg_catalog."ar_EG" (
    locale = 'ar_EG'
    );

alter collation pg_catalog."ar_EG" owner to postgres;

create collation pg_catalog."ar_EG.iso88596" (
    locale = 'ar_EG.iso88596'
    );

alter collation pg_catalog."ar_EG.iso88596" owner to postgres;

create collation pg_catalog."ar_EG.utf8" (
    locale = 'ar_EG.utf8'
    );

alter collation pg_catalog."ar_EG.utf8" owner to postgres;

create collation pg_catalog."ar_IN" (
    locale = 'ar_IN'
    );

alter collation pg_catalog."ar_IN" owner to postgres;

create collation pg_catalog."ar_IN.utf8" (
    locale = 'ar_IN.utf8'
    );

alter collation pg_catalog."ar_IN.utf8" owner to postgres;

create collation pg_catalog."ar_IQ" (
    locale = 'ar_IQ.utf8'
    );

alter collation pg_catalog."ar_IQ" owner to postgres;

create collation pg_catalog."ar_IQ" (
    locale = 'ar_IQ'
    );

alter collation pg_catalog."ar_IQ" owner to postgres;

create collation pg_catalog."ar_IQ.iso88596" (
    locale = 'ar_IQ.iso88596'
    );

alter collation pg_catalog."ar_IQ.iso88596" owner to postgres;

create collation pg_catalog."ar_IQ.utf8" (
    locale = 'ar_IQ.utf8'
    );

alter collation pg_catalog."ar_IQ.utf8" owner to postgres;

create collation pg_catalog."ar_JO" (
    locale = 'ar_JO.utf8'
    );

alter collation pg_catalog."ar_JO" owner to postgres;

create collation pg_catalog."ar_JO" (
    locale = 'ar_JO'
    );

alter collation pg_catalog."ar_JO" owner to postgres;

create collation pg_catalog."ar_JO.iso88596" (
    locale = 'ar_JO.iso88596'
    );

alter collation pg_catalog."ar_JO.iso88596" owner to postgres;

create collation pg_catalog."ar_JO.utf8" (
    locale = 'ar_JO.utf8'
    );

alter collation pg_catalog."ar_JO.utf8" owner to postgres;

create collation pg_catalog."ar_KW" (
    locale = 'ar_KW.utf8'
    );

alter collation pg_catalog."ar_KW" owner to postgres;

create collation pg_catalog."ar_KW" (
    locale = 'ar_KW'
    );

alter collation pg_catalog."ar_KW" owner to postgres;

create collation pg_catalog."ar_KW.iso88596" (
    locale = 'ar_KW.iso88596'
    );

alter collation pg_catalog."ar_KW.iso88596" owner to postgres;

create collation pg_catalog."ar_KW.utf8" (
    locale = 'ar_KW.utf8'
    );

alter collation pg_catalog."ar_KW.utf8" owner to postgres;

create collation pg_catalog."ar_LB" (
    locale = 'ar_LB.utf8'
    );

alter collation pg_catalog."ar_LB" owner to postgres;

create collation pg_catalog."ar_LB" (
    locale = 'ar_LB'
    );

alter collation pg_catalog."ar_LB" owner to postgres;

create collation pg_catalog."ar_LB.iso88596" (
    locale = 'ar_LB.iso88596'
    );

alter collation pg_catalog."ar_LB.iso88596" owner to postgres;

create collation pg_catalog."ar_LB.utf8" (
    locale = 'ar_LB.utf8'
    );

alter collation pg_catalog."ar_LB.utf8" owner to postgres;

create collation pg_catalog."ar_LY" (
    locale = 'ar_LY.utf8'
    );

alter collation pg_catalog."ar_LY" owner to postgres;

create collation pg_catalog."ar_LY" (
    locale = 'ar_LY'
    );

alter collation pg_catalog."ar_LY" owner to postgres;

create collation pg_catalog."ar_LY.iso88596" (
    locale = 'ar_LY.iso88596'
    );

alter collation pg_catalog."ar_LY.iso88596" owner to postgres;

create collation pg_catalog."ar_LY.utf8" (
    locale = 'ar_LY.utf8'
    );

alter collation pg_catalog."ar_LY.utf8" owner to postgres;

create collation pg_catalog."ar_MA" (
    locale = 'ar_MA.utf8'
    );

alter collation pg_catalog."ar_MA" owner to postgres;

create collation pg_catalog."ar_MA" (
    locale = 'ar_MA'
    );

alter collation pg_catalog."ar_MA" owner to postgres;

create collation pg_catalog."ar_MA.iso88596" (
    locale = 'ar_MA.iso88596'
    );

alter collation pg_catalog."ar_MA.iso88596" owner to postgres;

create collation pg_catalog."ar_MA.utf8" (
    locale = 'ar_MA.utf8'
    );

alter collation pg_catalog."ar_MA.utf8" owner to postgres;

create collation pg_catalog."ar_OM" (
    locale = 'ar_OM.utf8'
    );

alter collation pg_catalog."ar_OM" owner to postgres;

create collation pg_catalog."ar_OM" (
    locale = 'ar_OM'
    );

alter collation pg_catalog."ar_OM" owner to postgres;

create collation pg_catalog."ar_OM.iso88596" (
    locale = 'ar_OM.iso88596'
    );

alter collation pg_catalog."ar_OM.iso88596" owner to postgres;

create collation pg_catalog."ar_OM.utf8" (
    locale = 'ar_OM.utf8'
    );

alter collation pg_catalog."ar_OM.utf8" owner to postgres;

create collation pg_catalog."ar_QA" (
    locale = 'ar_QA.utf8'
    );

alter collation pg_catalog."ar_QA" owner to postgres;

create collation pg_catalog."ar_QA" (
    locale = 'ar_QA'
    );

alter collation pg_catalog."ar_QA" owner to postgres;

create collation pg_catalog."ar_QA.iso88596" (
    locale = 'ar_QA.iso88596'
    );

alter collation pg_catalog."ar_QA.iso88596" owner to postgres;

create collation pg_catalog."ar_QA.utf8" (
    locale = 'ar_QA.utf8'
    );

alter collation pg_catalog."ar_QA.utf8" owner to postgres;

create collation pg_catalog."ar_SA" (
    locale = 'ar_SA.utf8'
    );

alter collation pg_catalog."ar_SA" owner to postgres;

create collation pg_catalog."ar_SA" (
    locale = 'ar_SA'
    );

alter collation pg_catalog."ar_SA" owner to postgres;

create collation pg_catalog."ar_SA.iso88596" (
    locale = 'ar_SA.iso88596'
    );

alter collation pg_catalog."ar_SA.iso88596" owner to postgres;

create collation pg_catalog."ar_SA.utf8" (
    locale = 'ar_SA.utf8'
    );

alter collation pg_catalog."ar_SA.utf8" owner to postgres;

create collation pg_catalog."ar_SD" (
    locale = 'ar_SD.utf8'
    );

alter collation pg_catalog."ar_SD" owner to postgres;

create collation pg_catalog."ar_SD" (
    locale = 'ar_SD'
    );

alter collation pg_catalog."ar_SD" owner to postgres;

create collation pg_catalog."ar_SD.iso88596" (
    locale = 'ar_SD.iso88596'
    );

alter collation pg_catalog."ar_SD.iso88596" owner to postgres;

create collation pg_catalog."ar_SD.utf8" (
    locale = 'ar_SD.utf8'
    );

alter collation pg_catalog."ar_SD.utf8" owner to postgres;

create collation pg_catalog."ar_SY" (
    locale = 'ar_SY.utf8'
    );

alter collation pg_catalog."ar_SY" owner to postgres;

create collation pg_catalog."ar_SY" (
    locale = 'ar_SY'
    );

alter collation pg_catalog."ar_SY" owner to postgres;

create collation pg_catalog."ar_SY.iso88596" (
    locale = 'ar_SY.iso88596'
    );

alter collation pg_catalog."ar_SY.iso88596" owner to postgres;

create collation pg_catalog."ar_SY.utf8" (
    locale = 'ar_SY.utf8'
    );

alter collation pg_catalog."ar_SY.utf8" owner to postgres;

create collation pg_catalog."ar_TN" (
    locale = 'ar_TN.utf8'
    );

alter collation pg_catalog."ar_TN" owner to postgres;

create collation pg_catalog."ar_TN" (
    locale = 'ar_TN'
    );

alter collation pg_catalog."ar_TN" owner to postgres;

create collation pg_catalog."ar_TN.iso88596" (
    locale = 'ar_TN.iso88596'
    );

alter collation pg_catalog."ar_TN.iso88596" owner to postgres;

create collation pg_catalog."ar_TN.utf8" (
    locale = 'ar_TN.utf8'
    );

alter collation pg_catalog."ar_TN.utf8" owner to postgres;

create collation pg_catalog."ar_YE" (
    locale = 'ar_YE.utf8'
    );

alter collation pg_catalog."ar_YE" owner to postgres;

create collation pg_catalog."ar_YE" (
    locale = 'ar_YE'
    );

alter collation pg_catalog."ar_YE" owner to postgres;

create collation pg_catalog."ar_YE.iso88596" (
    locale = 'ar_YE.iso88596'
    );

alter collation pg_catalog."ar_YE.iso88596" owner to postgres;

create collation pg_catalog."ar_YE.utf8" (
    locale = 'ar_YE.utf8'
    );

alter collation pg_catalog."ar_YE.utf8" owner to postgres;

create collation pg_catalog."as_IN" (
    locale = 'as_IN'
    );

alter collation pg_catalog."as_IN" owner to postgres;

create collation pg_catalog."as_IN.utf8" (
    locale = 'as_IN.utf8'
    );

alter collation pg_catalog."as_IN.utf8" owner to postgres;

create collation pg_catalog."ast_ES" (
    locale = 'ast_ES.utf8'
    );

alter collation pg_catalog."ast_ES" owner to postgres;

create collation pg_catalog."ast_ES" (
    locale = 'ast_ES'
    );

alter collation pg_catalog."ast_ES" owner to postgres;

create collation pg_catalog."ast_ES.iso885915" (
    locale = 'ast_ES.iso885915'
    );

alter collation pg_catalog."ast_ES.iso885915" owner to postgres;

create collation pg_catalog."ast_ES.utf8" (
    locale = 'ast_ES.utf8'
    );

alter collation pg_catalog."ast_ES.utf8" owner to postgres;

create collation pg_catalog."ayc_PE" (
    locale = 'ayc_PE'
    );

alter collation pg_catalog."ayc_PE" owner to postgres;

create collation pg_catalog."ayc_PE.utf8" (
    locale = 'ayc_PE.utf8'
    );

alter collation pg_catalog."ayc_PE.utf8" owner to postgres;

create collation pg_catalog."az_AZ" (
    locale = 'az_AZ'
    );

alter collation pg_catalog."az_AZ" owner to postgres;

create collation pg_catalog."az_AZ.utf8" (
    locale = 'az_AZ.utf8'
    );

alter collation pg_catalog."az_AZ.utf8" owner to postgres;

create collation pg_catalog."be_BY" (
    locale = 'be_BY.utf8'
    );

alter collation pg_catalog."be_BY" owner to postgres;

create collation pg_catalog."be_BY" (
    locale = 'be_BY'
    );

alter collation pg_catalog."be_BY" owner to postgres;

create collation pg_catalog."be_BY.cp1251" (
    locale = 'be_BY.cp1251'
    );

alter collation pg_catalog."be_BY.cp1251" owner to postgres;

create collation pg_catalog."be_BY.utf8" (
    locale = 'be_BY.utf8'
    );

alter collation pg_catalog."be_BY.utf8" owner to postgres;

create collation pg_catalog."be_BY.utf8@latin" (
    locale = 'be_BY.utf8@latin'
    );

alter collation pg_catalog."be_BY.utf8@latin" owner to postgres;

create collation pg_catalog."be_BY@latin" (
    locale = 'be_BY@latin'
    );

alter collation pg_catalog."be_BY@latin" owner to postgres;

create collation pg_catalog."bem_ZM" (
    locale = 'bem_ZM'
    );

alter collation pg_catalog."bem_ZM" owner to postgres;

create collation pg_catalog."bem_ZM.utf8" (
    locale = 'bem_ZM.utf8'
    );

alter collation pg_catalog."bem_ZM.utf8" owner to postgres;

create collation pg_catalog."ber_DZ" (
    locale = 'ber_DZ'
    );

alter collation pg_catalog."ber_DZ" owner to postgres;

create collation pg_catalog."ber_DZ.utf8" (
    locale = 'ber_DZ.utf8'
    );

alter collation pg_catalog."ber_DZ.utf8" owner to postgres;

create collation pg_catalog."ber_MA" (
    locale = 'ber_MA'
    );

alter collation pg_catalog."ber_MA" owner to postgres;

create collation pg_catalog."ber_MA.utf8" (
    locale = 'ber_MA.utf8'
    );

alter collation pg_catalog."ber_MA.utf8" owner to postgres;

create collation pg_catalog."bg_BG" (
    locale = 'bg_BG.utf8'
    );

alter collation pg_catalog."bg_BG" owner to postgres;

create collation pg_catalog."bg_BG" (
    locale = 'bg_BG'
    );

alter collation pg_catalog."bg_BG" owner to postgres;

create collation pg_catalog."bg_BG.cp1251" (
    locale = 'bg_BG.cp1251'
    );

alter collation pg_catalog."bg_BG.cp1251" owner to postgres;

create collation pg_catalog."bg_BG.utf8" (
    locale = 'bg_BG.utf8'
    );

alter collation pg_catalog."bg_BG.utf8" owner to postgres;

create collation pg_catalog."bho_IN" (
    locale = 'bho_IN'
    );

alter collation pg_catalog."bho_IN" owner to postgres;

create collation pg_catalog."bho_IN.utf8" (
    locale = 'bho_IN.utf8'
    );

alter collation pg_catalog."bho_IN.utf8" owner to postgres;

create collation pg_catalog."bn_BD" (
    locale = 'bn_BD'
    );

alter collation pg_catalog."bn_BD" owner to postgres;

create collation pg_catalog."bn_BD.utf8" (
    locale = 'bn_BD.utf8'
    );

alter collation pg_catalog."bn_BD.utf8" owner to postgres;

create collation pg_catalog."bn_IN" (
    locale = 'bn_IN'
    );

alter collation pg_catalog."bn_IN" owner to postgres;

create collation pg_catalog."bn_IN.utf8" (
    locale = 'bn_IN.utf8'
    );

alter collation pg_catalog."bn_IN.utf8" owner to postgres;

create collation pg_catalog."bo_CN" (
    locale = 'bo_CN'
    );

alter collation pg_catalog."bo_CN" owner to postgres;

create collation pg_catalog."bo_CN.utf8" (
    locale = 'bo_CN.utf8'
    );

alter collation pg_catalog."bo_CN.utf8" owner to postgres;

create collation pg_catalog."bo_IN" (
    locale = 'bo_IN'
    );

alter collation pg_catalog."bo_IN" owner to postgres;

create collation pg_catalog."bo_IN.utf8" (
    locale = 'bo_IN.utf8'
    );

alter collation pg_catalog."bo_IN.utf8" owner to postgres;

create collation pg_catalog.bokmal (
    locale = 'bokmal'
    );

alter collation pg_catalog.bokmal owner to postgres;

create collation pg_catalog."br_FR" (
    locale = 'br_FR.utf8'
    );

alter collation pg_catalog."br_FR" owner to postgres;

create collation pg_catalog."br_FR" (
    locale = 'br_FR'
    );

alter collation pg_catalog."br_FR" owner to postgres;

create collation pg_catalog."br_FR.iso88591" (
    locale = 'br_FR.iso88591'
    );

alter collation pg_catalog."br_FR.iso88591" owner to postgres;

create collation pg_catalog."br_FR.iso885915@euro" (
    locale = 'br_FR.iso885915@euro'
    );

alter collation pg_catalog."br_FR.iso885915@euro" owner to postgres;

create collation pg_catalog."br_FR.utf8" (
    locale = 'br_FR.utf8'
    );

alter collation pg_catalog."br_FR.utf8" owner to postgres;

create collation pg_catalog."br_FR@euro" (
    locale = 'br_FR@euro'
    );

alter collation pg_catalog."br_FR@euro" owner to postgres;

create collation pg_catalog."brx_IN" (
    locale = 'brx_IN'
    );

alter collation pg_catalog."brx_IN" owner to postgres;

create collation pg_catalog."brx_IN.utf8" (
    locale = 'brx_IN.utf8'
    );

alter collation pg_catalog."brx_IN.utf8" owner to postgres;

create collation pg_catalog."bs_BA" (
    locale = 'bs_BA.utf8'
    );

alter collation pg_catalog."bs_BA" owner to postgres;

create collation pg_catalog."bs_BA" (
    locale = 'bs_BA'
    );

alter collation pg_catalog."bs_BA" owner to postgres;

create collation pg_catalog."bs_BA.iso88592" (
    locale = 'bs_BA.iso88592'
    );

alter collation pg_catalog."bs_BA.iso88592" owner to postgres;

create collation pg_catalog."bs_BA.utf8" (
    locale = 'bs_BA.utf8'
    );

alter collation pg_catalog."bs_BA.utf8" owner to postgres;

create collation pg_catalog."byn_ER" (
    locale = 'byn_ER'
    );

alter collation pg_catalog."byn_ER" owner to postgres;

create collation pg_catalog."byn_ER.utf8" (
    locale = 'byn_ER.utf8'
    );

alter collation pg_catalog."byn_ER.utf8" owner to postgres;

create collation pg_catalog."ca_AD" (
    locale = 'ca_AD.utf8'
    );

alter collation pg_catalog."ca_AD" owner to postgres;

create collation pg_catalog."ca_AD" (
    locale = 'ca_AD'
    );

alter collation pg_catalog."ca_AD" owner to postgres;

create collation pg_catalog."ca_AD.iso885915" (
    locale = 'ca_AD.iso885915'
    );

alter collation pg_catalog."ca_AD.iso885915" owner to postgres;

create collation pg_catalog."ca_AD.utf8" (
    locale = 'ca_AD.utf8'
    );

alter collation pg_catalog."ca_AD.utf8" owner to postgres;

create collation pg_catalog."ca_ES" (
    locale = 'ca_ES.utf8'
    );

alter collation pg_catalog."ca_ES" owner to postgres;

create collation pg_catalog."ca_ES" (
    locale = 'ca_ES'
    );

alter collation pg_catalog."ca_ES" owner to postgres;

create collation pg_catalog."ca_ES.iso88591" (
    locale = 'ca_ES.iso88591'
    );

alter collation pg_catalog."ca_ES.iso88591" owner to postgres;

create collation pg_catalog."ca_ES.iso885915@euro" (
    locale = 'ca_ES.iso885915@euro'
    );

alter collation pg_catalog."ca_ES.iso885915@euro" owner to postgres;

create collation pg_catalog."ca_ES.utf8" (
    locale = 'ca_ES.utf8'
    );

alter collation pg_catalog."ca_ES.utf8" owner to postgres;

create collation pg_catalog."ca_ES@euro" (
    locale = 'ca_ES@euro'
    );

alter collation pg_catalog."ca_ES@euro" owner to postgres;

create collation pg_catalog."ca_FR" (
    locale = 'ca_FR.utf8'
    );

alter collation pg_catalog."ca_FR" owner to postgres;

create collation pg_catalog."ca_FR" (
    locale = 'ca_FR'
    );

alter collation pg_catalog."ca_FR" owner to postgres;

create collation pg_catalog."ca_FR.iso885915" (
    locale = 'ca_FR.iso885915'
    );

alter collation pg_catalog."ca_FR.iso885915" owner to postgres;

create collation pg_catalog."ca_FR.utf8" (
    locale = 'ca_FR.utf8'
    );

alter collation pg_catalog."ca_FR.utf8" owner to postgres;

create collation pg_catalog."ca_IT" (
    locale = 'ca_IT.utf8'
    );

alter collation pg_catalog."ca_IT" owner to postgres;

create collation pg_catalog."ca_IT" (
    locale = 'ca_IT'
    );

alter collation pg_catalog."ca_IT" owner to postgres;

create collation pg_catalog."ca_IT.iso885915" (
    locale = 'ca_IT.iso885915'
    );

alter collation pg_catalog."ca_IT.iso885915" owner to postgres;

create collation pg_catalog."ca_IT.utf8" (
    locale = 'ca_IT.utf8'
    );

alter collation pg_catalog."ca_IT.utf8" owner to postgres;

create collation pg_catalog.catalan (
    locale = 'catalan'
    );

alter collation pg_catalog.catalan owner to postgres;

create collation pg_catalog."crh_UA" (
    locale = 'crh_UA'
    );

alter collation pg_catalog."crh_UA" owner to postgres;

create collation pg_catalog."crh_UA.utf8" (
    locale = 'crh_UA.utf8'
    );

alter collation pg_catalog."crh_UA.utf8" owner to postgres;

create collation pg_catalog.croatian (
    locale = 'croatian'
    );

alter collation pg_catalog.croatian owner to postgres;

create collation pg_catalog."cs_CZ" (
    locale = 'cs_CZ.utf8'
    );

alter collation pg_catalog."cs_CZ" owner to postgres;

create collation pg_catalog."cs_CZ" (
    locale = 'cs_CZ'
    );

alter collation pg_catalog."cs_CZ" owner to postgres;

create collation pg_catalog."cs_CZ.iso88592" (
    locale = 'cs_CZ.iso88592'
    );

alter collation pg_catalog."cs_CZ.iso88592" owner to postgres;

create collation pg_catalog."cs_CZ.utf8" (
    locale = 'cs_CZ.utf8'
    );

alter collation pg_catalog."cs_CZ.utf8" owner to postgres;

create collation pg_catalog."csb_PL" (
    locale = 'csb_PL'
    );

alter collation pg_catalog."csb_PL" owner to postgres;

create collation pg_catalog."csb_PL.utf8" (
    locale = 'csb_PL.utf8'
    );

alter collation pg_catalog."csb_PL.utf8" owner to postgres;

create collation pg_catalog."cv_RU" (
    locale = 'cv_RU'
    );

alter collation pg_catalog."cv_RU" owner to postgres;

create collation pg_catalog."cv_RU.utf8" (
    locale = 'cv_RU.utf8'
    );

alter collation pg_catalog."cv_RU.utf8" owner to postgres;

create collation pg_catalog."cy_GB" (
    locale = 'cy_GB.utf8'
    );

alter collation pg_catalog."cy_GB" owner to postgres;

create collation pg_catalog."cy_GB" (
    locale = 'cy_GB'
    );

alter collation pg_catalog."cy_GB" owner to postgres;

create collation pg_catalog."cy_GB.iso885914" (
    locale = 'cy_GB.iso885914'
    );

alter collation pg_catalog."cy_GB.iso885914" owner to postgres;

create collation pg_catalog."cy_GB.utf8" (
    locale = 'cy_GB.utf8'
    );

alter collation pg_catalog."cy_GB.utf8" owner to postgres;

create collation pg_catalog.czech (
    locale = 'czech'
    );

alter collation pg_catalog.czech owner to postgres;

create collation pg_catalog."da_DK" (
    locale = 'da_DK.utf8'
    );

alter collation pg_catalog."da_DK" owner to postgres;

create collation pg_catalog."da_DK" (
    locale = 'da_DK'
    );

alter collation pg_catalog."da_DK" owner to postgres;

create collation pg_catalog."da_DK" (
    locale = 'da_DK.iso885915'
    );

alter collation pg_catalog."da_DK" owner to postgres;

create collation pg_catalog."da_DK.iso88591" (
    locale = 'da_DK.iso88591'
    );

alter collation pg_catalog."da_DK.iso88591" owner to postgres;

create collation pg_catalog."da_DK.iso885915" (
    locale = 'da_DK.iso885915'
    );

alter collation pg_catalog."da_DK.iso885915" owner to postgres;

create collation pg_catalog."da_DK.utf8" (
    locale = 'da_DK.utf8'
    );

alter collation pg_catalog."da_DK.utf8" owner to postgres;

create collation pg_catalog.danish (
    locale = 'danish'
    );

alter collation pg_catalog.danish owner to postgres;

create collation pg_catalog.dansk (
    locale = 'dansk'
    );

alter collation pg_catalog.dansk owner to postgres;

create collation pg_catalog."de_AT" (
    locale = 'de_AT.utf8'
    );

alter collation pg_catalog."de_AT" owner to postgres;

create collation pg_catalog."de_AT" (
    locale = 'de_AT'
    );

alter collation pg_catalog."de_AT" owner to postgres;

create collation pg_catalog."de_AT.iso88591" (
    locale = 'de_AT.iso88591'
    );

alter collation pg_catalog."de_AT.iso88591" owner to postgres;

create collation pg_catalog."de_AT.iso885915@euro" (
    locale = 'de_AT.iso885915@euro'
    );

alter collation pg_catalog."de_AT.iso885915@euro" owner to postgres;

create collation pg_catalog."de_AT.utf8" (
    locale = 'de_AT.utf8'
    );

alter collation pg_catalog."de_AT.utf8" owner to postgres;

create collation pg_catalog."de_AT@euro" (
    locale = 'de_AT@euro'
    );

alter collation pg_catalog."de_AT@euro" owner to postgres;

create collation pg_catalog."de_BE" (
    locale = 'de_BE.utf8'
    );

alter collation pg_catalog."de_BE" owner to postgres;

create collation pg_catalog."de_BE" (
    locale = 'de_BE'
    );

alter collation pg_catalog."de_BE" owner to postgres;

create collation pg_catalog."de_BE.iso88591" (
    locale = 'de_BE.iso88591'
    );

alter collation pg_catalog."de_BE.iso88591" owner to postgres;

create collation pg_catalog."de_BE.iso885915@euro" (
    locale = 'de_BE.iso885915@euro'
    );

alter collation pg_catalog."de_BE.iso885915@euro" owner to postgres;

create collation pg_catalog."de_BE.utf8" (
    locale = 'de_BE.utf8'
    );

alter collation pg_catalog."de_BE.utf8" owner to postgres;

create collation pg_catalog."de_BE@euro" (
    locale = 'de_BE@euro'
    );

alter collation pg_catalog."de_BE@euro" owner to postgres;

create collation pg_catalog."de_CH" (
    locale = 'de_CH.utf8'
    );

alter collation pg_catalog."de_CH" owner to postgres;

create collation pg_catalog."de_CH" (
    locale = 'de_CH'
    );

alter collation pg_catalog."de_CH" owner to postgres;

create collation pg_catalog."de_CH.iso88591" (
    locale = 'de_CH.iso88591'
    );

alter collation pg_catalog."de_CH.iso88591" owner to postgres;

create collation pg_catalog."de_CH.utf8" (
    locale = 'de_CH.utf8'
    );

alter collation pg_catalog."de_CH.utf8" owner to postgres;

create collation pg_catalog."de_DE" (
    locale = 'de_DE.utf8'
    );

alter collation pg_catalog."de_DE" owner to postgres;

create collation pg_catalog."de_DE" (
    locale = 'de_DE'
    );

alter collation pg_catalog."de_DE" owner to postgres;

create collation pg_catalog."de_DE.iso88591" (
    locale = 'de_DE.iso88591'
    );

alter collation pg_catalog."de_DE.iso88591" owner to postgres;

create collation pg_catalog."de_DE.iso885915@euro" (
    locale = 'de_DE.iso885915@euro'
    );

alter collation pg_catalog."de_DE.iso885915@euro" owner to postgres;

create collation pg_catalog."de_DE.utf8" (
    locale = 'de_DE.utf8'
    );

alter collation pg_catalog."de_DE.utf8" owner to postgres;

create collation pg_catalog."de_DE@euro" (
    locale = 'de_DE@euro'
    );

alter collation pg_catalog."de_DE@euro" owner to postgres;

create collation pg_catalog."de_LU" (
    locale = 'de_LU.utf8'
    );

alter collation pg_catalog."de_LU" owner to postgres;

create collation pg_catalog."de_LU" (
    locale = 'de_LU'
    );

alter collation pg_catalog."de_LU" owner to postgres;

create collation pg_catalog."de_LU.iso88591" (
    locale = 'de_LU.iso88591'
    );

alter collation pg_catalog."de_LU.iso88591" owner to postgres;

create collation pg_catalog."de_LU.iso885915@euro" (
    locale = 'de_LU.iso885915@euro'
    );

alter collation pg_catalog."de_LU.iso885915@euro" owner to postgres;

create collation pg_catalog."de_LU.utf8" (
    locale = 'de_LU.utf8'
    );

alter collation pg_catalog."de_LU.utf8" owner to postgres;

create collation pg_catalog."de_LU@euro" (
    locale = 'de_LU@euro'
    );

alter collation pg_catalog."de_LU@euro" owner to postgres;

create collation pg_catalog.deutsch (
    locale = 'deutsch'
    );

alter collation pg_catalog.deutsch owner to postgres;

create collation pg_catalog."doi_IN" (
    locale = 'doi_IN'
    );

alter collation pg_catalog."doi_IN" owner to postgres;

create collation pg_catalog."doi_IN.utf8" (
    locale = 'doi_IN.utf8'
    );

alter collation pg_catalog."doi_IN.utf8" owner to postgres;

create collation pg_catalog.dutch (
    locale = 'dutch'
    );

alter collation pg_catalog.dutch owner to postgres;

create collation pg_catalog."dv_MV" (
    locale = 'dv_MV'
    );

alter collation pg_catalog."dv_MV" owner to postgres;

create collation pg_catalog."dv_MV.utf8" (
    locale = 'dv_MV.utf8'
    );

alter collation pg_catalog."dv_MV.utf8" owner to postgres;

create collation pg_catalog."dz_BT" (
    locale = 'dz_BT'
    );

alter collation pg_catalog."dz_BT" owner to postgres;

create collation pg_catalog."dz_BT.utf8" (
    locale = 'dz_BT.utf8'
    );

alter collation pg_catalog."dz_BT.utf8" owner to postgres;

create collation pg_catalog.eesti (
    locale = 'eesti'
    );

alter collation pg_catalog.eesti owner to postgres;

create collation pg_catalog."el_CY" (
    locale = 'el_CY.utf8'
    );

alter collation pg_catalog."el_CY" owner to postgres;

create collation pg_catalog."el_CY" (
    locale = 'el_CY'
    );

alter collation pg_catalog."el_CY" owner to postgres;

create collation pg_catalog."el_CY.iso88597" (
    locale = 'el_CY.iso88597'
    );

alter collation pg_catalog."el_CY.iso88597" owner to postgres;

create collation pg_catalog."el_CY.utf8" (
    locale = 'el_CY.utf8'
    );

alter collation pg_catalog."el_CY.utf8" owner to postgres;

create collation pg_catalog."el_GR" (
    locale = 'el_GR.utf8'
    );

alter collation pg_catalog."el_GR" owner to postgres;

create collation pg_catalog."el_GR" (
    locale = 'el_GR'
    );

alter collation pg_catalog."el_GR" owner to postgres;

create collation pg_catalog."el_GR.iso88597" (
    locale = 'el_GR.iso88597'
    );

alter collation pg_catalog."el_GR.iso88597" owner to postgres;

create collation pg_catalog."el_GR.iso88597@euro" (
    locale = 'el_GR.iso88597@euro'
    );

alter collation pg_catalog."el_GR.iso88597@euro" owner to postgres;

create collation pg_catalog."el_GR.utf8" (
    locale = 'el_GR.utf8'
    );

alter collation pg_catalog."el_GR.utf8" owner to postgres;

create collation pg_catalog."el_GR@euro" (
    locale = 'el_GR@euro'
    );

alter collation pg_catalog."el_GR@euro" owner to postgres;

create collation pg_catalog."en_AG" (
    locale = 'en_AG'
    );

alter collation pg_catalog."en_AG" owner to postgres;

create collation pg_catalog."en_AG.utf8" (
    locale = 'en_AG.utf8'
    );

alter collation pg_catalog."en_AG.utf8" owner to postgres;

create collation pg_catalog."en_AU" (
    locale = 'en_AU.utf8'
    );

alter collation pg_catalog."en_AU" owner to postgres;

create collation pg_catalog."en_AU" (
    locale = 'en_AU'
    );

alter collation pg_catalog."en_AU" owner to postgres;

create collation pg_catalog."en_AU.iso88591" (
    locale = 'en_AU.iso88591'
    );

alter collation pg_catalog."en_AU.iso88591" owner to postgres;

create collation pg_catalog."en_AU.utf8" (
    locale = 'en_AU.utf8'
    );

alter collation pg_catalog."en_AU.utf8" owner to postgres;

create collation pg_catalog."en_BW" (
    locale = 'en_BW.utf8'
    );

alter collation pg_catalog."en_BW" owner to postgres;

create collation pg_catalog."en_BW" (
    locale = 'en_BW'
    );

alter collation pg_catalog."en_BW" owner to postgres;

create collation pg_catalog."en_BW.iso88591" (
    locale = 'en_BW.iso88591'
    );

alter collation pg_catalog."en_BW.iso88591" owner to postgres;

create collation pg_catalog."en_BW.utf8" (
    locale = 'en_BW.utf8'
    );

alter collation pg_catalog."en_BW.utf8" owner to postgres;

create collation pg_catalog."en_CA" (
    locale = 'en_CA.utf8'
    );

alter collation pg_catalog."en_CA" owner to postgres;

create collation pg_catalog."en_CA" (
    locale = 'en_CA'
    );

alter collation pg_catalog."en_CA" owner to postgres;

create collation pg_catalog."en_CA.iso88591" (
    locale = 'en_CA.iso88591'
    );

alter collation pg_catalog."en_CA.iso88591" owner to postgres;

create collation pg_catalog."en_CA.utf8" (
    locale = 'en_CA.utf8'
    );

alter collation pg_catalog."en_CA.utf8" owner to postgres;

create collation pg_catalog."en_DK" (
    locale = 'en_DK.utf8'
    );

alter collation pg_catalog."en_DK" owner to postgres;

create collation pg_catalog."en_DK" (
    locale = 'en_DK'
    );

alter collation pg_catalog."en_DK" owner to postgres;

create collation pg_catalog."en_DK.iso88591" (
    locale = 'en_DK.iso88591'
    );

alter collation pg_catalog."en_DK.iso88591" owner to postgres;

create collation pg_catalog."en_DK.utf8" (
    locale = 'en_DK.utf8'
    );

alter collation pg_catalog."en_DK.utf8" owner to postgres;

create collation pg_catalog."en_GB" (
    locale = 'en_GB.utf8'
    );

alter collation pg_catalog."en_GB" owner to postgres;

create collation pg_catalog."en_GB" (
    locale = 'en_GB'
    );

alter collation pg_catalog."en_GB" owner to postgres;

create collation pg_catalog."en_GB" (
    locale = 'en_GB.iso885915'
    );

alter collation pg_catalog."en_GB" owner to postgres;

create collation pg_catalog."en_GB.iso88591" (
    locale = 'en_GB.iso88591'
    );

alter collation pg_catalog."en_GB.iso88591" owner to postgres;

create collation pg_catalog."en_GB.iso885915" (
    locale = 'en_GB.iso885915'
    );

alter collation pg_catalog."en_GB.iso885915" owner to postgres;

create collation pg_catalog."en_GB.utf8" (
    locale = 'en_GB.utf8'
    );

alter collation pg_catalog."en_GB.utf8" owner to postgres;

create collation pg_catalog."en_HK" (
    locale = 'en_HK.utf8'
    );

alter collation pg_catalog."en_HK" owner to postgres;

create collation pg_catalog."en_HK" (
    locale = 'en_HK'
    );

alter collation pg_catalog."en_HK" owner to postgres;

create collation pg_catalog."en_HK.iso88591" (
    locale = 'en_HK.iso88591'
    );

alter collation pg_catalog."en_HK.iso88591" owner to postgres;

create collation pg_catalog."en_HK.utf8" (
    locale = 'en_HK.utf8'
    );

alter collation pg_catalog."en_HK.utf8" owner to postgres;

create collation pg_catalog."en_IE" (
    locale = 'en_IE.utf8'
    );

alter collation pg_catalog."en_IE" owner to postgres;

create collation pg_catalog."en_IE" (
    locale = 'en_IE'
    );

alter collation pg_catalog."en_IE" owner to postgres;

create collation pg_catalog."en_IE.iso88591" (
    locale = 'en_IE.iso88591'
    );

alter collation pg_catalog."en_IE.iso88591" owner to postgres;

create collation pg_catalog."en_IE.iso885915@euro" (
    locale = 'en_IE.iso885915@euro'
    );

alter collation pg_catalog."en_IE.iso885915@euro" owner to postgres;

create collation pg_catalog."en_IE.utf8" (
    locale = 'en_IE.utf8'
    );

alter collation pg_catalog."en_IE.utf8" owner to postgres;

create collation pg_catalog."en_IE@euro" (
    locale = 'en_IE@euro'
    );

alter collation pg_catalog."en_IE@euro" owner to postgres;

create collation pg_catalog."en_IN" (
    locale = 'en_IN'
    );

alter collation pg_catalog."en_IN" owner to postgres;

create collation pg_catalog."en_IN.utf8" (
    locale = 'en_IN.utf8'
    );

alter collation pg_catalog."en_IN.utf8" owner to postgres;

create collation pg_catalog."en_NG" (
    locale = 'en_NG'
    );

alter collation pg_catalog."en_NG" owner to postgres;

create collation pg_catalog."en_NG.utf8" (
    locale = 'en_NG.utf8'
    );

alter collation pg_catalog."en_NG.utf8" owner to postgres;

create collation pg_catalog."en_NZ" (
    locale = 'en_NZ.utf8'
    );

alter collation pg_catalog."en_NZ" owner to postgres;

create collation pg_catalog."en_NZ" (
    locale = 'en_NZ'
    );

alter collation pg_catalog."en_NZ" owner to postgres;

create collation pg_catalog."en_NZ.iso88591" (
    locale = 'en_NZ.iso88591'
    );

alter collation pg_catalog."en_NZ.iso88591" owner to postgres;

create collation pg_catalog."en_NZ.utf8" (
    locale = 'en_NZ.utf8'
    );

alter collation pg_catalog."en_NZ.utf8" owner to postgres;

create collation pg_catalog."en_PH" (
    locale = 'en_PH.utf8'
    );

alter collation pg_catalog."en_PH" owner to postgres;

create collation pg_catalog."en_PH" (
    locale = 'en_PH'
    );

alter collation pg_catalog."en_PH" owner to postgres;

create collation pg_catalog."en_PH.iso88591" (
    locale = 'en_PH.iso88591'
    );

alter collation pg_catalog."en_PH.iso88591" owner to postgres;

create collation pg_catalog."en_PH.utf8" (
    locale = 'en_PH.utf8'
    );

alter collation pg_catalog."en_PH.utf8" owner to postgres;

create collation pg_catalog."en_SG" (
    locale = 'en_SG.utf8'
    );

alter collation pg_catalog."en_SG" owner to postgres;

create collation pg_catalog."en_SG" (
    locale = 'en_SG'
    );

alter collation pg_catalog."en_SG" owner to postgres;

create collation pg_catalog."en_SG.iso88591" (
    locale = 'en_SG.iso88591'
    );

alter collation pg_catalog."en_SG.iso88591" owner to postgres;

create collation pg_catalog."en_SG.utf8" (
    locale = 'en_SG.utf8'
    );

alter collation pg_catalog."en_SG.utf8" owner to postgres;

create collation pg_catalog."en_US" (
    locale = 'en_US.utf8'
    );

alter collation pg_catalog."en_US" owner to postgres;

create collation pg_catalog."en_US" (
    locale = 'en_US'
    );

alter collation pg_catalog."en_US" owner to postgres;

create collation pg_catalog."en_US" (
    locale = 'en_US.iso885915'
    );

alter collation pg_catalog."en_US" owner to postgres;

create collation pg_catalog."en_US.iso88591" (
    locale = 'en_US.iso88591'
    );

alter collation pg_catalog."en_US.iso88591" owner to postgres;

create collation pg_catalog."en_US.iso885915" (
    locale = 'en_US.iso885915'
    );

alter collation pg_catalog."en_US.iso885915" owner to postgres;

create collation pg_catalog."en_US.utf8" (
    locale = 'en_US.utf8'
    );

alter collation pg_catalog."en_US.utf8" owner to postgres;

create collation pg_catalog."en_ZA" (
    locale = 'en_ZA.utf8'
    );

alter collation pg_catalog."en_ZA" owner to postgres;

create collation pg_catalog."en_ZA" (
    locale = 'en_ZA'
    );

alter collation pg_catalog."en_ZA" owner to postgres;

create collation pg_catalog."en_ZA.iso88591" (
    locale = 'en_ZA.iso88591'
    );

alter collation pg_catalog."en_ZA.iso88591" owner to postgres;

create collation pg_catalog."en_ZA.utf8" (
    locale = 'en_ZA.utf8'
    );

alter collation pg_catalog."en_ZA.utf8" owner to postgres;

create collation pg_catalog."en_ZM" (
    locale = 'en_ZM'
    );

alter collation pg_catalog."en_ZM" owner to postgres;

create collation pg_catalog."en_ZM.utf8" (
    locale = 'en_ZM.utf8'
    );

alter collation pg_catalog."en_ZM.utf8" owner to postgres;

create collation pg_catalog."en_ZW" (
    locale = 'en_ZW.utf8'
    );

alter collation pg_catalog."en_ZW" owner to postgres;

create collation pg_catalog."en_ZW" (
    locale = 'en_ZW'
    );

alter collation pg_catalog."en_ZW" owner to postgres;

create collation pg_catalog."en_ZW.iso88591" (
    locale = 'en_ZW.iso88591'
    );

alter collation pg_catalog."en_ZW.iso88591" owner to postgres;

create collation pg_catalog."en_ZW.utf8" (
    locale = 'en_ZW.utf8'
    );

alter collation pg_catalog."en_ZW.utf8" owner to postgres;

create collation pg_catalog."es_AR" (
    locale = 'es_AR.utf8'
    );

alter collation pg_catalog."es_AR" owner to postgres;

create collation pg_catalog."es_AR" (
    locale = 'es_AR'
    );

alter collation pg_catalog."es_AR" owner to postgres;

create collation pg_catalog."es_AR.iso88591" (
    locale = 'es_AR.iso88591'
    );

alter collation pg_catalog."es_AR.iso88591" owner to postgres;

create collation pg_catalog."es_AR.utf8" (
    locale = 'es_AR.utf8'
    );

alter collation pg_catalog."es_AR.utf8" owner to postgres;

create collation pg_catalog."es_BO" (
    locale = 'es_BO.utf8'
    );

alter collation pg_catalog."es_BO" owner to postgres;

create collation pg_catalog."es_BO" (
    locale = 'es_BO'
    );

alter collation pg_catalog."es_BO" owner to postgres;

create collation pg_catalog."es_BO.iso88591" (
    locale = 'es_BO.iso88591'
    );

alter collation pg_catalog."es_BO.iso88591" owner to postgres;

create collation pg_catalog."es_BO.utf8" (
    locale = 'es_BO.utf8'
    );

alter collation pg_catalog."es_BO.utf8" owner to postgres;

create collation pg_catalog."es_CL" (
    locale = 'es_CL.utf8'
    );

alter collation pg_catalog."es_CL" owner to postgres;

create collation pg_catalog."es_CL" (
    locale = 'es_CL'
    );

alter collation pg_catalog."es_CL" owner to postgres;

create collation pg_catalog."es_CL.iso88591" (
    locale = 'es_CL.iso88591'
    );

alter collation pg_catalog."es_CL.iso88591" owner to postgres;

create collation pg_catalog."es_CL.utf8" (
    locale = 'es_CL.utf8'
    );

alter collation pg_catalog."es_CL.utf8" owner to postgres;

create collation pg_catalog."es_CO" (
    locale = 'es_CO.utf8'
    );

alter collation pg_catalog."es_CO" owner to postgres;

create collation pg_catalog."es_CO" (
    locale = 'es_CO'
    );

alter collation pg_catalog."es_CO" owner to postgres;

create collation pg_catalog."es_CO.iso88591" (
    locale = 'es_CO.iso88591'
    );

alter collation pg_catalog."es_CO.iso88591" owner to postgres;

create collation pg_catalog."es_CO.utf8" (
    locale = 'es_CO.utf8'
    );

alter collation pg_catalog."es_CO.utf8" owner to postgres;

create collation pg_catalog."es_CR" (
    locale = 'es_CR.utf8'
    );

alter collation pg_catalog."es_CR" owner to postgres;

create collation pg_catalog."es_CR" (
    locale = 'es_CR'
    );

alter collation pg_catalog."es_CR" owner to postgres;

create collation pg_catalog."es_CR.iso88591" (
    locale = 'es_CR.iso88591'
    );

alter collation pg_catalog."es_CR.iso88591" owner to postgres;

create collation pg_catalog."es_CR.utf8" (
    locale = 'es_CR.utf8'
    );

alter collation pg_catalog."es_CR.utf8" owner to postgres;

create collation pg_catalog."es_CU" (
    locale = 'es_CU'
    );

alter collation pg_catalog."es_CU" owner to postgres;

create collation pg_catalog."es_CU.utf8" (
    locale = 'es_CU.utf8'
    );

alter collation pg_catalog."es_CU.utf8" owner to postgres;

create collation pg_catalog."es_DO" (
    locale = 'es_DO.utf8'
    );

alter collation pg_catalog."es_DO" owner to postgres;

create collation pg_catalog."es_DO" (
    locale = 'es_DO'
    );

alter collation pg_catalog."es_DO" owner to postgres;

create collation pg_catalog."es_DO.iso88591" (
    locale = 'es_DO.iso88591'
    );

alter collation pg_catalog."es_DO.iso88591" owner to postgres;

create collation pg_catalog."es_DO.utf8" (
    locale = 'es_DO.utf8'
    );

alter collation pg_catalog."es_DO.utf8" owner to postgres;

create collation pg_catalog."es_EC" (
    locale = 'es_EC.utf8'
    );

alter collation pg_catalog."es_EC" owner to postgres;

create collation pg_catalog."es_EC" (
    locale = 'es_EC'
    );

alter collation pg_catalog."es_EC" owner to postgres;

create collation pg_catalog."es_EC.iso88591" (
    locale = 'es_EC.iso88591'
    );

alter collation pg_catalog."es_EC.iso88591" owner to postgres;

create collation pg_catalog."es_EC.utf8" (
    locale = 'es_EC.utf8'
    );

alter collation pg_catalog."es_EC.utf8" owner to postgres;

create collation pg_catalog."es_ES" (
    locale = 'es_ES.utf8'
    );

alter collation pg_catalog."es_ES" owner to postgres;

create collation pg_catalog."es_ES" (
    locale = 'es_ES'
    );

alter collation pg_catalog."es_ES" owner to postgres;

create collation pg_catalog."es_ES.iso88591" (
    locale = 'es_ES.iso88591'
    );

alter collation pg_catalog."es_ES.iso88591" owner to postgres;

create collation pg_catalog."es_ES.iso885915@euro" (
    locale = 'es_ES.iso885915@euro'
    );

alter collation pg_catalog."es_ES.iso885915@euro" owner to postgres;

create collation pg_catalog."es_ES.utf8" (
    locale = 'es_ES.utf8'
    );

alter collation pg_catalog."es_ES.utf8" owner to postgres;

create collation pg_catalog."es_ES@euro" (
    locale = 'es_ES@euro'
    );

alter collation pg_catalog."es_ES@euro" owner to postgres;

create collation pg_catalog."es_GT" (
    locale = 'es_GT.utf8'
    );

alter collation pg_catalog."es_GT" owner to postgres;

create collation pg_catalog."es_GT" (
    locale = 'es_GT'
    );

alter collation pg_catalog."es_GT" owner to postgres;

create collation pg_catalog."es_GT.iso88591" (
    locale = 'es_GT.iso88591'
    );

alter collation pg_catalog."es_GT.iso88591" owner to postgres;

create collation pg_catalog."es_GT.utf8" (
    locale = 'es_GT.utf8'
    );

alter collation pg_catalog."es_GT.utf8" owner to postgres;

create collation pg_catalog."es_HN" (
    locale = 'es_HN.utf8'
    );

alter collation pg_catalog."es_HN" owner to postgres;

create collation pg_catalog."es_HN" (
    locale = 'es_HN'
    );

alter collation pg_catalog."es_HN" owner to postgres;

create collation pg_catalog."es_HN.iso88591" (
    locale = 'es_HN.iso88591'
    );

alter collation pg_catalog."es_HN.iso88591" owner to postgres;

create collation pg_catalog."es_HN.utf8" (
    locale = 'es_HN.utf8'
    );

alter collation pg_catalog."es_HN.utf8" owner to postgres;

create collation pg_catalog."es_MX" (
    locale = 'es_MX.utf8'
    );

alter collation pg_catalog."es_MX" owner to postgres;

create collation pg_catalog."es_MX" (
    locale = 'es_MX'
    );

alter collation pg_catalog."es_MX" owner to postgres;

create collation pg_catalog."es_MX.iso88591" (
    locale = 'es_MX.iso88591'
    );

alter collation pg_catalog."es_MX.iso88591" owner to postgres;

create collation pg_catalog."es_MX.utf8" (
    locale = 'es_MX.utf8'
    );

alter collation pg_catalog."es_MX.utf8" owner to postgres;

create collation pg_catalog."es_NI" (
    locale = 'es_NI.utf8'
    );

alter collation pg_catalog."es_NI" owner to postgres;

create collation pg_catalog."es_NI" (
    locale = 'es_NI'
    );

alter collation pg_catalog."es_NI" owner to postgres;

create collation pg_catalog."es_NI.iso88591" (
    locale = 'es_NI.iso88591'
    );

alter collation pg_catalog."es_NI.iso88591" owner to postgres;

create collation pg_catalog."es_NI.utf8" (
    locale = 'es_NI.utf8'
    );

alter collation pg_catalog."es_NI.utf8" owner to postgres;

create collation pg_catalog."es_PA" (
    locale = 'es_PA.utf8'
    );

alter collation pg_catalog."es_PA" owner to postgres;

create collation pg_catalog."es_PA" (
    locale = 'es_PA'
    );

alter collation pg_catalog."es_PA" owner to postgres;

create collation pg_catalog."es_PA.iso88591" (
    locale = 'es_PA.iso88591'
    );

alter collation pg_catalog."es_PA.iso88591" owner to postgres;

create collation pg_catalog."es_PA.utf8" (
    locale = 'es_PA.utf8'
    );

alter collation pg_catalog."es_PA.utf8" owner to postgres;

create collation pg_catalog."es_PE" (
    locale = 'es_PE.utf8'
    );

alter collation pg_catalog."es_PE" owner to postgres;

create collation pg_catalog."es_PE" (
    locale = 'es_PE'
    );

alter collation pg_catalog."es_PE" owner to postgres;

create collation pg_catalog."es_PE.iso88591" (
    locale = 'es_PE.iso88591'
    );

alter collation pg_catalog."es_PE.iso88591" owner to postgres;

create collation pg_catalog."es_PE.utf8" (
    locale = 'es_PE.utf8'
    );

alter collation pg_catalog."es_PE.utf8" owner to postgres;

create collation pg_catalog."es_PR" (
    locale = 'es_PR.utf8'
    );

alter collation pg_catalog."es_PR" owner to postgres;

create collation pg_catalog."es_PR" (
    locale = 'es_PR'
    );

alter collation pg_catalog."es_PR" owner to postgres;

create collation pg_catalog."es_PR.iso88591" (
    locale = 'es_PR.iso88591'
    );

alter collation pg_catalog."es_PR.iso88591" owner to postgres;

create collation pg_catalog."es_PR.utf8" (
    locale = 'es_PR.utf8'
    );

alter collation pg_catalog."es_PR.utf8" owner to postgres;

create collation pg_catalog."es_PY" (
    locale = 'es_PY.utf8'
    );

alter collation pg_catalog."es_PY" owner to postgres;

create collation pg_catalog."es_PY" (
    locale = 'es_PY'
    );

alter collation pg_catalog."es_PY" owner to postgres;

create collation pg_catalog."es_PY.iso88591" (
    locale = 'es_PY.iso88591'
    );

alter collation pg_catalog."es_PY.iso88591" owner to postgres;

create collation pg_catalog."es_PY.utf8" (
    locale = 'es_PY.utf8'
    );

alter collation pg_catalog."es_PY.utf8" owner to postgres;

create collation pg_catalog."es_SV" (
    locale = 'es_SV.utf8'
    );

alter collation pg_catalog."es_SV" owner to postgres;

create collation pg_catalog."es_SV" (
    locale = 'es_SV'
    );

alter collation pg_catalog."es_SV" owner to postgres;

create collation pg_catalog."es_SV.iso88591" (
    locale = 'es_SV.iso88591'
    );

alter collation pg_catalog."es_SV.iso88591" owner to postgres;

create collation pg_catalog."es_SV.utf8" (
    locale = 'es_SV.utf8'
    );

alter collation pg_catalog."es_SV.utf8" owner to postgres;

create collation pg_catalog."es_US" (
    locale = 'es_US.utf8'
    );

alter collation pg_catalog."es_US" owner to postgres;

create collation pg_catalog."es_US" (
    locale = 'es_US'
    );

alter collation pg_catalog."es_US" owner to postgres;

create collation pg_catalog."es_US.iso88591" (
    locale = 'es_US.iso88591'
    );

alter collation pg_catalog."es_US.iso88591" owner to postgres;

create collation pg_catalog."es_US.utf8" (
    locale = 'es_US.utf8'
    );

alter collation pg_catalog."es_US.utf8" owner to postgres;

create collation pg_catalog."es_UY" (
    locale = 'es_UY.utf8'
    );

alter collation pg_catalog."es_UY" owner to postgres;

create collation pg_catalog."es_UY" (
    locale = 'es_UY'
    );

alter collation pg_catalog."es_UY" owner to postgres;

create collation pg_catalog."es_UY.iso88591" (
    locale = 'es_UY.iso88591'
    );

alter collation pg_catalog."es_UY.iso88591" owner to postgres;

create collation pg_catalog."es_UY.utf8" (
    locale = 'es_UY.utf8'
    );

alter collation pg_catalog."es_UY.utf8" owner to postgres;

create collation pg_catalog."es_VE" (
    locale = 'es_VE.utf8'
    );

alter collation pg_catalog."es_VE" owner to postgres;

create collation pg_catalog."es_VE" (
    locale = 'es_VE'
    );

alter collation pg_catalog."es_VE" owner to postgres;

create collation pg_catalog."es_VE.iso88591" (
    locale = 'es_VE.iso88591'
    );

alter collation pg_catalog."es_VE.iso88591" owner to postgres;

create collation pg_catalog."es_VE.utf8" (
    locale = 'es_VE.utf8'
    );

alter collation pg_catalog."es_VE.utf8" owner to postgres;

create collation pg_catalog.estonian (
    locale = 'estonian'
    );

alter collation pg_catalog.estonian owner to postgres;

create collation pg_catalog."et_EE" (
    locale = 'et_EE.utf8'
    );

alter collation pg_catalog."et_EE" owner to postgres;

create collation pg_catalog."et_EE" (
    locale = 'et_EE'
    );

alter collation pg_catalog."et_EE" owner to postgres;

create collation pg_catalog."et_EE" (
    locale = 'et_EE.iso885915'
    );

alter collation pg_catalog."et_EE" owner to postgres;

create collation pg_catalog."et_EE.iso88591" (
    locale = 'et_EE.iso88591'
    );

alter collation pg_catalog."et_EE.iso88591" owner to postgres;

create collation pg_catalog."et_EE.iso885915" (
    locale = 'et_EE.iso885915'
    );

alter collation pg_catalog."et_EE.iso885915" owner to postgres;

create collation pg_catalog."et_EE.utf8" (
    locale = 'et_EE.utf8'
    );

alter collation pg_catalog."et_EE.utf8" owner to postgres;

create collation pg_catalog."eu_ES" (
    locale = 'eu_ES.utf8'
    );

alter collation pg_catalog."eu_ES" owner to postgres;

create collation pg_catalog."eu_ES" (
    locale = 'eu_ES'
    );

alter collation pg_catalog."eu_ES" owner to postgres;

create collation pg_catalog."eu_ES.iso88591" (
    locale = 'eu_ES.iso88591'
    );

alter collation pg_catalog."eu_ES.iso88591" owner to postgres;

create collation pg_catalog."eu_ES.iso885915@euro" (
    locale = 'eu_ES.iso885915@euro'
    );

alter collation pg_catalog."eu_ES.iso885915@euro" owner to postgres;

create collation pg_catalog."eu_ES.utf8" (
    locale = 'eu_ES.utf8'
    );

alter collation pg_catalog."eu_ES.utf8" owner to postgres;

create collation pg_catalog."eu_ES@euro" (
    locale = 'eu_ES@euro'
    );

alter collation pg_catalog."eu_ES@euro" owner to postgres;

create collation pg_catalog."fa_IR" (
    locale = 'fa_IR'
    );

alter collation pg_catalog."fa_IR" owner to postgres;

create collation pg_catalog."fa_IR.utf8" (
    locale = 'fa_IR.utf8'
    );

alter collation pg_catalog."fa_IR.utf8" owner to postgres;

create collation pg_catalog."ff_SN" (
    locale = 'ff_SN'
    );

alter collation pg_catalog."ff_SN" owner to postgres;

create collation pg_catalog."ff_SN.utf8" (
    locale = 'ff_SN.utf8'
    );

alter collation pg_catalog."ff_SN.utf8" owner to postgres;

create collation pg_catalog."fi_FI" (
    locale = 'fi_FI.utf8'
    );

alter collation pg_catalog."fi_FI" owner to postgres;

create collation pg_catalog."fi_FI" (
    locale = 'fi_FI'
    );

alter collation pg_catalog."fi_FI" owner to postgres;

create collation pg_catalog."fi_FI.iso88591" (
    locale = 'fi_FI.iso88591'
    );

alter collation pg_catalog."fi_FI.iso88591" owner to postgres;

create collation pg_catalog."fi_FI.iso885915@euro" (
    locale = 'fi_FI.iso885915@euro'
    );

alter collation pg_catalog."fi_FI.iso885915@euro" owner to postgres;

create collation pg_catalog."fi_FI.utf8" (
    locale = 'fi_FI.utf8'
    );

alter collation pg_catalog."fi_FI.utf8" owner to postgres;

create collation pg_catalog."fi_FI@euro" (
    locale = 'fi_FI@euro'
    );

alter collation pg_catalog."fi_FI@euro" owner to postgres;

create collation pg_catalog."fil_PH" (
    locale = 'fil_PH'
    );

alter collation pg_catalog."fil_PH" owner to postgres;

create collation pg_catalog."fil_PH.utf8" (
    locale = 'fil_PH.utf8'
    );

alter collation pg_catalog."fil_PH.utf8" owner to postgres;

create collation pg_catalog.finnish (
    locale = 'finnish'
    );

alter collation pg_catalog.finnish owner to postgres;

create collation pg_catalog."fo_FO" (
    locale = 'fo_FO.utf8'
    );

alter collation pg_catalog."fo_FO" owner to postgres;

create collation pg_catalog."fo_FO" (
    locale = 'fo_FO'
    );

alter collation pg_catalog."fo_FO" owner to postgres;

create collation pg_catalog."fo_FO.iso88591" (
    locale = 'fo_FO.iso88591'
    );

alter collation pg_catalog."fo_FO.iso88591" owner to postgres;

create collation pg_catalog."fo_FO.utf8" (
    locale = 'fo_FO.utf8'
    );

alter collation pg_catalog."fo_FO.utf8" owner to postgres;

create collation pg_catalog."fr_BE" (
    locale = 'fr_BE.utf8'
    );

alter collation pg_catalog."fr_BE" owner to postgres;

create collation pg_catalog."fr_BE" (
    locale = 'fr_BE'
    );

alter collation pg_catalog."fr_BE" owner to postgres;

create collation pg_catalog."fr_BE.iso88591" (
    locale = 'fr_BE.iso88591'
    );

alter collation pg_catalog."fr_BE.iso88591" owner to postgres;

create collation pg_catalog."fr_BE.iso885915@euro" (
    locale = 'fr_BE.iso885915@euro'
    );

alter collation pg_catalog."fr_BE.iso885915@euro" owner to postgres;

create collation pg_catalog."fr_BE.utf8" (
    locale = 'fr_BE.utf8'
    );

alter collation pg_catalog."fr_BE.utf8" owner to postgres;

create collation pg_catalog."fr_BE@euro" (
    locale = 'fr_BE@euro'
    );

alter collation pg_catalog."fr_BE@euro" owner to postgres;

create collation pg_catalog."fr_CA" (
    locale = 'fr_CA.utf8'
    );

alter collation pg_catalog."fr_CA" owner to postgres;

create collation pg_catalog."fr_CA" (
    locale = 'fr_CA'
    );

alter collation pg_catalog."fr_CA" owner to postgres;

create collation pg_catalog."fr_CA.iso88591" (
    locale = 'fr_CA.iso88591'
    );

alter collation pg_catalog."fr_CA.iso88591" owner to postgres;

create collation pg_catalog."fr_CA.utf8" (
    locale = 'fr_CA.utf8'
    );

alter collation pg_catalog."fr_CA.utf8" owner to postgres;

create collation pg_catalog."fr_CH" (
    locale = 'fr_CH.utf8'
    );

alter collation pg_catalog."fr_CH" owner to postgres;

create collation pg_catalog."fr_CH" (
    locale = 'fr_CH'
    );

alter collation pg_catalog."fr_CH" owner to postgres;

create collation pg_catalog."fr_CH.iso88591" (
    locale = 'fr_CH.iso88591'
    );

alter collation pg_catalog."fr_CH.iso88591" owner to postgres;

create collation pg_catalog."fr_CH.utf8" (
    locale = 'fr_CH.utf8'
    );

alter collation pg_catalog."fr_CH.utf8" owner to postgres;

create collation pg_catalog."fr_FR" (
    locale = 'fr_FR.utf8'
    );

alter collation pg_catalog."fr_FR" owner to postgres;

create collation pg_catalog."fr_FR" (
    locale = 'fr_FR'
    );

alter collation pg_catalog."fr_FR" owner to postgres;

create collation pg_catalog."fr_FR.iso88591" (
    locale = 'fr_FR.iso88591'
    );

alter collation pg_catalog."fr_FR.iso88591" owner to postgres;

create collation pg_catalog."fr_FR.iso885915@euro" (
    locale = 'fr_FR.iso885915@euro'
    );

alter collation pg_catalog."fr_FR.iso885915@euro" owner to postgres;

create collation pg_catalog."fr_FR.utf8" (
    locale = 'fr_FR.utf8'
    );

alter collation pg_catalog."fr_FR.utf8" owner to postgres;

create collation pg_catalog."fr_FR@euro" (
    locale = 'fr_FR@euro'
    );

alter collation pg_catalog."fr_FR@euro" owner to postgres;

create collation pg_catalog."fr_LU" (
    locale = 'fr_LU.utf8'
    );

alter collation pg_catalog."fr_LU" owner to postgres;

create collation pg_catalog."fr_LU" (
    locale = 'fr_LU'
    );

alter collation pg_catalog."fr_LU" owner to postgres;

create collation pg_catalog."fr_LU.iso88591" (
    locale = 'fr_LU.iso88591'
    );

alter collation pg_catalog."fr_LU.iso88591" owner to postgres;

create collation pg_catalog."fr_LU.iso885915@euro" (
    locale = 'fr_LU.iso885915@euro'
    );

alter collation pg_catalog."fr_LU.iso885915@euro" owner to postgres;

create collation pg_catalog."fr_LU.utf8" (
    locale = 'fr_LU.utf8'
    );

alter collation pg_catalog."fr_LU.utf8" owner to postgres;

create collation pg_catalog."fr_LU@euro" (
    locale = 'fr_LU@euro'
    );

alter collation pg_catalog."fr_LU@euro" owner to postgres;

create collation pg_catalog.french (
    locale = 'french'
    );

alter collation pg_catalog.french owner to postgres;

create collation pg_catalog."fur_IT" (
    locale = 'fur_IT'
    );

alter collation pg_catalog."fur_IT" owner to postgres;

create collation pg_catalog."fur_IT.utf8" (
    locale = 'fur_IT.utf8'
    );

alter collation pg_catalog."fur_IT.utf8" owner to postgres;

create collation pg_catalog."fy_DE" (
    locale = 'fy_DE'
    );

alter collation pg_catalog."fy_DE" owner to postgres;

create collation pg_catalog."fy_DE.utf8" (
    locale = 'fy_DE.utf8'
    );

alter collation pg_catalog."fy_DE.utf8" owner to postgres;

create collation pg_catalog."fy_NL" (
    locale = 'fy_NL'
    );

alter collation pg_catalog."fy_NL" owner to postgres;

create collation pg_catalog."fy_NL.utf8" (
    locale = 'fy_NL.utf8'
    );

alter collation pg_catalog."fy_NL.utf8" owner to postgres;

create collation pg_catalog."ga_IE" (
    locale = 'ga_IE.utf8'
    );

alter collation pg_catalog."ga_IE" owner to postgres;

create collation pg_catalog."ga_IE" (
    locale = 'ga_IE'
    );

alter collation pg_catalog."ga_IE" owner to postgres;

create collation pg_catalog."ga_IE.iso88591" (
    locale = 'ga_IE.iso88591'
    );

alter collation pg_catalog."ga_IE.iso88591" owner to postgres;

create collation pg_catalog."ga_IE.iso885915@euro" (
    locale = 'ga_IE.iso885915@euro'
    );

alter collation pg_catalog."ga_IE.iso885915@euro" owner to postgres;

create collation pg_catalog."ga_IE.utf8" (
    locale = 'ga_IE.utf8'
    );

alter collation pg_catalog."ga_IE.utf8" owner to postgres;

create collation pg_catalog."ga_IE@euro" (
    locale = 'ga_IE@euro'
    );

alter collation pg_catalog."ga_IE@euro" owner to postgres;

create collation pg_catalog.galego (
    locale = 'galego'
    );

alter collation pg_catalog.galego owner to postgres;

create collation pg_catalog.galician (
    locale = 'galician'
    );

alter collation pg_catalog.galician owner to postgres;

create collation pg_catalog."gd_GB" (
    locale = 'gd_GB.utf8'
    );

alter collation pg_catalog."gd_GB" owner to postgres;

create collation pg_catalog."gd_GB" (
    locale = 'gd_GB'
    );

alter collation pg_catalog."gd_GB" owner to postgres;

create collation pg_catalog."gd_GB.iso885915" (
    locale = 'gd_GB.iso885915'
    );

alter collation pg_catalog."gd_GB.iso885915" owner to postgres;

create collation pg_catalog."gd_GB.utf8" (
    locale = 'gd_GB.utf8'
    );

alter collation pg_catalog."gd_GB.utf8" owner to postgres;

create collation pg_catalog.german (
    locale = 'german'
    );

alter collation pg_catalog.german owner to postgres;

create collation pg_catalog."gez_ER" (
    locale = 'gez_ER'
    );

alter collation pg_catalog."gez_ER" owner to postgres;

create collation pg_catalog."gez_ER.utf8" (
    locale = 'gez_ER.utf8'
    );

alter collation pg_catalog."gez_ER.utf8" owner to postgres;

create collation pg_catalog."gez_ER.utf8@abegede" (
    locale = 'gez_ER.utf8@abegede'
    );

alter collation pg_catalog."gez_ER.utf8@abegede" owner to postgres;

create collation pg_catalog."gez_ER@abegede" (
    locale = 'gez_ER@abegede'
    );

alter collation pg_catalog."gez_ER@abegede" owner to postgres;

create collation pg_catalog."gez_ET" (
    locale = 'gez_ET'
    );

alter collation pg_catalog."gez_ET" owner to postgres;

create collation pg_catalog."gez_ET.utf8" (
    locale = 'gez_ET.utf8'
    );

alter collation pg_catalog."gez_ET.utf8" owner to postgres;

create collation pg_catalog."gez_ET.utf8@abegede" (
    locale = 'gez_ET.utf8@abegede'
    );

alter collation pg_catalog."gez_ET.utf8@abegede" owner to postgres;

create collation pg_catalog."gez_ET@abegede" (
    locale = 'gez_ET@abegede'
    );

alter collation pg_catalog."gez_ET@abegede" owner to postgres;

create collation pg_catalog."gl_ES" (
    locale = 'gl_ES.utf8'
    );

alter collation pg_catalog."gl_ES" owner to postgres;

create collation pg_catalog."gl_ES" (
    locale = 'gl_ES'
    );

alter collation pg_catalog."gl_ES" owner to postgres;

create collation pg_catalog."gl_ES.iso88591" (
    locale = 'gl_ES.iso88591'
    );

alter collation pg_catalog."gl_ES.iso88591" owner to postgres;

create collation pg_catalog."gl_ES.iso885915@euro" (
    locale = 'gl_ES.iso885915@euro'
    );

alter collation pg_catalog."gl_ES.iso885915@euro" owner to postgres;

create collation pg_catalog."gl_ES.utf8" (
    locale = 'gl_ES.utf8'
    );

alter collation pg_catalog."gl_ES.utf8" owner to postgres;

create collation pg_catalog."gl_ES@euro" (
    locale = 'gl_ES@euro'
    );

alter collation pg_catalog."gl_ES@euro" owner to postgres;

create collation pg_catalog.greek (
    locale = 'greek'
    );

alter collation pg_catalog.greek owner to postgres;

create collation pg_catalog."gu_IN" (
    locale = 'gu_IN'
    );

alter collation pg_catalog."gu_IN" owner to postgres;

create collation pg_catalog."gu_IN.utf8" (
    locale = 'gu_IN.utf8'
    );

alter collation pg_catalog."gu_IN.utf8" owner to postgres;

create collation pg_catalog."gv_GB" (
    locale = 'gv_GB.utf8'
    );

alter collation pg_catalog."gv_GB" owner to postgres;

create collation pg_catalog."gv_GB" (
    locale = 'gv_GB'
    );

alter collation pg_catalog."gv_GB" owner to postgres;

create collation pg_catalog."gv_GB.iso88591" (
    locale = 'gv_GB.iso88591'
    );

alter collation pg_catalog."gv_GB.iso88591" owner to postgres;

create collation pg_catalog."gv_GB.utf8" (
    locale = 'gv_GB.utf8'
    );

alter collation pg_catalog."gv_GB.utf8" owner to postgres;

create collation pg_catalog."ha_NG" (
    locale = 'ha_NG'
    );

alter collation pg_catalog."ha_NG" owner to postgres;

create collation pg_catalog."ha_NG.utf8" (
    locale = 'ha_NG.utf8'
    );

alter collation pg_catalog."ha_NG.utf8" owner to postgres;

create collation pg_catalog."he_IL" (
    locale = 'he_IL.utf8'
    );

alter collation pg_catalog."he_IL" owner to postgres;

create collation pg_catalog."he_IL" (
    locale = 'he_IL'
    );

alter collation pg_catalog."he_IL" owner to postgres;

create collation pg_catalog."he_IL.iso88598" (
    locale = 'he_IL.iso88598'
    );

alter collation pg_catalog."he_IL.iso88598" owner to postgres;

create collation pg_catalog."he_IL.utf8" (
    locale = 'he_IL.utf8'
    );

alter collation pg_catalog."he_IL.utf8" owner to postgres;

create collation pg_catalog.hebrew (
    locale = 'hebrew'
    );

alter collation pg_catalog.hebrew owner to postgres;

create collation pg_catalog."hi_IN" (
    locale = 'hi_IN'
    );

alter collation pg_catalog."hi_IN" owner to postgres;

create collation pg_catalog."hi_IN.utf8" (
    locale = 'hi_IN.utf8'
    );

alter collation pg_catalog."hi_IN.utf8" owner to postgres;

create collation pg_catalog."hne_IN" (
    locale = 'hne_IN'
    );

alter collation pg_catalog."hne_IN" owner to postgres;

create collation pg_catalog."hne_IN.utf8" (
    locale = 'hne_IN.utf8'
    );

alter collation pg_catalog."hne_IN.utf8" owner to postgres;

create collation pg_catalog."hr_HR" (
    locale = 'hr_HR.utf8'
    );

alter collation pg_catalog."hr_HR" owner to postgres;

create collation pg_catalog."hr_HR" (
    locale = 'hr_HR'
    );

alter collation pg_catalog."hr_HR" owner to postgres;

create collation pg_catalog."hr_HR.iso88592" (
    locale = 'hr_HR.iso88592'
    );

alter collation pg_catalog."hr_HR.iso88592" owner to postgres;

create collation pg_catalog."hr_HR.utf8" (
    locale = 'hr_HR.utf8'
    );

alter collation pg_catalog."hr_HR.utf8" owner to postgres;

create collation pg_catalog.hrvatski (
    locale = 'hrvatski'
    );

alter collation pg_catalog.hrvatski owner to postgres;

create collation pg_catalog."hsb_DE" (
    locale = 'hsb_DE.utf8'
    );

alter collation pg_catalog."hsb_DE" owner to postgres;

create collation pg_catalog."hsb_DE" (
    locale = 'hsb_DE'
    );

alter collation pg_catalog."hsb_DE" owner to postgres;

create collation pg_catalog."hsb_DE.iso88592" (
    locale = 'hsb_DE.iso88592'
    );

alter collation pg_catalog."hsb_DE.iso88592" owner to postgres;

create collation pg_catalog."hsb_DE.utf8" (
    locale = 'hsb_DE.utf8'
    );

alter collation pg_catalog."hsb_DE.utf8" owner to postgres;

create collation pg_catalog."ht_HT" (
    locale = 'ht_HT'
    );

alter collation pg_catalog."ht_HT" owner to postgres;

create collation pg_catalog."ht_HT.utf8" (
    locale = 'ht_HT.utf8'
    );

alter collation pg_catalog."ht_HT.utf8" owner to postgres;

create collation pg_catalog."hu_HU" (
    locale = 'hu_HU.utf8'
    );

alter collation pg_catalog."hu_HU" owner to postgres;

create collation pg_catalog."hu_HU" (
    locale = 'hu_HU'
    );

alter collation pg_catalog."hu_HU" owner to postgres;

create collation pg_catalog."hu_HU.iso88592" (
    locale = 'hu_HU.iso88592'
    );

alter collation pg_catalog."hu_HU.iso88592" owner to postgres;

create collation pg_catalog."hu_HU.utf8" (
    locale = 'hu_HU.utf8'
    );

alter collation pg_catalog."hu_HU.utf8" owner to postgres;

create collation pg_catalog.hungarian (
    locale = 'hungarian'
    );

alter collation pg_catalog.hungarian owner to postgres;

create collation pg_catalog."hy_AM" (
    locale = 'hy_AM'
    );

alter collation pg_catalog."hy_AM" owner to postgres;

create collation pg_catalog."hy_AM.utf8" (
    locale = 'hy_AM.utf8'
    );

alter collation pg_catalog."hy_AM.utf8" owner to postgres;

create collation pg_catalog."ia_FR" (
    locale = 'ia_FR'
    );

alter collation pg_catalog."ia_FR" owner to postgres;

create collation pg_catalog."ia_FR.utf8" (
    locale = 'ia_FR.utf8'
    );

alter collation pg_catalog."ia_FR.utf8" owner to postgres;

create collation pg_catalog.icelandic (
    locale = 'icelandic'
    );

alter collation pg_catalog.icelandic owner to postgres;

create collation pg_catalog."id_ID" (
    locale = 'id_ID.utf8'
    );

alter collation pg_catalog."id_ID" owner to postgres;

create collation pg_catalog."id_ID" (
    locale = 'id_ID'
    );

alter collation pg_catalog."id_ID" owner to postgres;

create collation pg_catalog."id_ID.iso88591" (
    locale = 'id_ID.iso88591'
    );

alter collation pg_catalog."id_ID.iso88591" owner to postgres;

create collation pg_catalog."id_ID.utf8" (
    locale = 'id_ID.utf8'
    );

alter collation pg_catalog."id_ID.utf8" owner to postgres;

create collation pg_catalog."ig_NG" (
    locale = 'ig_NG'
    );

alter collation pg_catalog."ig_NG" owner to postgres;

create collation pg_catalog."ig_NG.utf8" (
    locale = 'ig_NG.utf8'
    );

alter collation pg_catalog."ig_NG.utf8" owner to postgres;

create collation pg_catalog."ik_CA" (
    locale = 'ik_CA'
    );

alter collation pg_catalog."ik_CA" owner to postgres;

create collation pg_catalog."ik_CA.utf8" (
    locale = 'ik_CA.utf8'
    );

alter collation pg_catalog."ik_CA.utf8" owner to postgres;

create collation pg_catalog."is_IS" (
    locale = 'is_IS.utf8'
    );

alter collation pg_catalog."is_IS" owner to postgres;

create collation pg_catalog."is_IS" (
    locale = 'is_IS'
    );

alter collation pg_catalog."is_IS" owner to postgres;

create collation pg_catalog."is_IS.iso88591" (
    locale = 'is_IS.iso88591'
    );

alter collation pg_catalog."is_IS.iso88591" owner to postgres;

create collation pg_catalog."is_IS.utf8" (
    locale = 'is_IS.utf8'
    );

alter collation pg_catalog."is_IS.utf8" owner to postgres;

create collation pg_catalog."it_CH" (
    locale = 'it_CH.utf8'
    );

alter collation pg_catalog."it_CH" owner to postgres;

create collation pg_catalog."it_CH" (
    locale = 'it_CH'
    );

alter collation pg_catalog."it_CH" owner to postgres;

create collation pg_catalog."it_CH.iso88591" (
    locale = 'it_CH.iso88591'
    );

alter collation pg_catalog."it_CH.iso88591" owner to postgres;

create collation pg_catalog."it_CH.utf8" (
    locale = 'it_CH.utf8'
    );

alter collation pg_catalog."it_CH.utf8" owner to postgres;

create collation pg_catalog."it_IT" (
    locale = 'it_IT.utf8'
    );

alter collation pg_catalog."it_IT" owner to postgres;

create collation pg_catalog."it_IT" (
    locale = 'it_IT'
    );

alter collation pg_catalog."it_IT" owner to postgres;

create collation pg_catalog."it_IT.iso88591" (
    locale = 'it_IT.iso88591'
    );

alter collation pg_catalog."it_IT.iso88591" owner to postgres;

create collation pg_catalog."it_IT.iso885915@euro" (
    locale = 'it_IT.iso885915@euro'
    );

alter collation pg_catalog."it_IT.iso885915@euro" owner to postgres;

create collation pg_catalog."it_IT.utf8" (
    locale = 'it_IT.utf8'
    );

alter collation pg_catalog."it_IT.utf8" owner to postgres;

create collation pg_catalog."it_IT@euro" (
    locale = 'it_IT@euro'
    );

alter collation pg_catalog."it_IT@euro" owner to postgres;

create collation pg_catalog.italian (
    locale = 'italian'
    );

alter collation pg_catalog.italian owner to postgres;

create collation pg_catalog."iu_CA" (
    locale = 'iu_CA'
    );

alter collation pg_catalog."iu_CA" owner to postgres;

create collation pg_catalog."iu_CA.utf8" (
    locale = 'iu_CA.utf8'
    );

alter collation pg_catalog."iu_CA.utf8" owner to postgres;

create collation pg_catalog."iw_IL" (
    locale = 'iw_IL.utf8'
    );

alter collation pg_catalog."iw_IL" owner to postgres;

create collation pg_catalog."iw_IL" (
    locale = 'iw_IL'
    );

alter collation pg_catalog."iw_IL" owner to postgres;

create collation pg_catalog."iw_IL.iso88598" (
    locale = 'iw_IL.iso88598'
    );

alter collation pg_catalog."iw_IL.iso88598" owner to postgres;

create collation pg_catalog."iw_IL.utf8" (
    locale = 'iw_IL.utf8'
    );

alter collation pg_catalog."iw_IL.utf8" owner to postgres;

create collation pg_catalog."ja_JP" (
    locale = 'ja_JP'
    );

alter collation pg_catalog."ja_JP" owner to postgres;

create collation pg_catalog."ja_JP" (
    locale = 'ja_JP.utf8'
    );

alter collation pg_catalog."ja_JP" owner to postgres;

create collation pg_catalog."ja_JP.eucjp" (
    locale = 'ja_JP.eucjp'
    );

alter collation pg_catalog."ja_JP.eucjp" owner to postgres;

create collation pg_catalog."ja_JP.ujis" (
    locale = 'ja_JP.ujis'
    );

alter collation pg_catalog."ja_JP.ujis" owner to postgres;

create collation pg_catalog."ja_JP.utf8" (
    locale = 'ja_JP.utf8'
    );

alter collation pg_catalog."ja_JP.utf8" owner to postgres;

create collation pg_catalog.japanese (
    locale = 'japanese'
    );

alter collation pg_catalog.japanese owner to postgres;

create collation pg_catalog."japanese.euc" (
    locale = 'japanese.euc'
    );

alter collation pg_catalog."japanese.euc" owner to postgres;

create collation pg_catalog."ka_GE" (
    locale = 'ka_GE.utf8'
    );

alter collation pg_catalog."ka_GE" owner to postgres;

create collation pg_catalog."ka_GE.utf8" (
    locale = 'ka_GE.utf8'
    );

alter collation pg_catalog."ka_GE.utf8" owner to postgres;

create collation pg_catalog."kk_KZ" (
    locale = 'kk_KZ.utf8'
    );

alter collation pg_catalog."kk_KZ" owner to postgres;

create collation pg_catalog."kk_KZ.utf8" (
    locale = 'kk_KZ.utf8'
    );

alter collation pg_catalog."kk_KZ.utf8" owner to postgres;

create collation pg_catalog."kl_GL" (
    locale = 'kl_GL.utf8'
    );

alter collation pg_catalog."kl_GL" owner to postgres;

create collation pg_catalog."kl_GL" (
    locale = 'kl_GL'
    );

alter collation pg_catalog."kl_GL" owner to postgres;

create collation pg_catalog."kl_GL.iso88591" (
    locale = 'kl_GL.iso88591'
    );

alter collation pg_catalog."kl_GL.iso88591" owner to postgres;

create collation pg_catalog."kl_GL.utf8" (
    locale = 'kl_GL.utf8'
    );

alter collation pg_catalog."kl_GL.utf8" owner to postgres;

create collation pg_catalog."km_KH" (
    locale = 'km_KH'
    );

alter collation pg_catalog."km_KH" owner to postgres;

create collation pg_catalog."km_KH.utf8" (
    locale = 'km_KH.utf8'
    );

alter collation pg_catalog."km_KH.utf8" owner to postgres;

create collation pg_catalog."kn_IN" (
    locale = 'kn_IN'
    );

alter collation pg_catalog."kn_IN" owner to postgres;

create collation pg_catalog."kn_IN.utf8" (
    locale = 'kn_IN.utf8'
    );

alter collation pg_catalog."kn_IN.utf8" owner to postgres;

create collation pg_catalog."ko_KR" (
    locale = 'ko_KR'
    );

alter collation pg_catalog."ko_KR" owner to postgres;

create collation pg_catalog."ko_KR" (
    locale = 'ko_KR.utf8'
    );

alter collation pg_catalog."ko_KR" owner to postgres;

create collation pg_catalog."ko_KR.euckr" (
    locale = 'ko_KR.euckr'
    );

alter collation pg_catalog."ko_KR.euckr" owner to postgres;

create collation pg_catalog."ko_KR.utf8" (
    locale = 'ko_KR.utf8'
    );

alter collation pg_catalog."ko_KR.utf8" owner to postgres;

create collation pg_catalog."kok_IN" (
    locale = 'kok_IN'
    );

alter collation pg_catalog."kok_IN" owner to postgres;

create collation pg_catalog."kok_IN.utf8" (
    locale = 'kok_IN.utf8'
    );

alter collation pg_catalog."kok_IN.utf8" owner to postgres;

create collation pg_catalog.korean (
    locale = 'korean'
    );

alter collation pg_catalog.korean owner to postgres;

create collation pg_catalog."korean.euc" (
    locale = 'korean.euc'
    );

alter collation pg_catalog."korean.euc" owner to postgres;

create collation pg_catalog."ks_IN" (
    locale = 'ks_IN'
    );

alter collation pg_catalog."ks_IN" owner to postgres;

create collation pg_catalog."ks_IN.utf8" (
    locale = 'ks_IN.utf8'
    );

alter collation pg_catalog."ks_IN.utf8" owner to postgres;

create collation pg_catalog."ks_IN.utf8@devanagari" (
    locale = 'ks_IN.utf8@devanagari'
    );

alter collation pg_catalog."ks_IN.utf8@devanagari" owner to postgres;

create collation pg_catalog."ks_IN@devanagari" (
    locale = 'ks_IN@devanagari'
    );

alter collation pg_catalog."ks_IN@devanagari" owner to postgres;

create collation pg_catalog."ku_TR" (
    locale = 'ku_TR.utf8'
    );

alter collation pg_catalog."ku_TR" owner to postgres;

create collation pg_catalog."ku_TR" (
    locale = 'ku_TR'
    );

alter collation pg_catalog."ku_TR" owner to postgres;

create collation pg_catalog."ku_TR.iso88599" (
    locale = 'ku_TR.iso88599'
    );

alter collation pg_catalog."ku_TR.iso88599" owner to postgres;

create collation pg_catalog."ku_TR.utf8" (
    locale = 'ku_TR.utf8'
    );

alter collation pg_catalog."ku_TR.utf8" owner to postgres;

create collation pg_catalog."kw_GB" (
    locale = 'kw_GB.utf8'
    );

alter collation pg_catalog."kw_GB" owner to postgres;

create collation pg_catalog."kw_GB" (
    locale = 'kw_GB'
    );

alter collation pg_catalog."kw_GB" owner to postgres;

create collation pg_catalog."kw_GB.iso88591" (
    locale = 'kw_GB.iso88591'
    );

alter collation pg_catalog."kw_GB.iso88591" owner to postgres;

create collation pg_catalog."kw_GB.utf8" (
    locale = 'kw_GB.utf8'
    );

alter collation pg_catalog."kw_GB.utf8" owner to postgres;

create collation pg_catalog."ky_KG" (
    locale = 'ky_KG'
    );

alter collation pg_catalog."ky_KG" owner to postgres;

create collation pg_catalog."ky_KG.utf8" (
    locale = 'ky_KG.utf8'
    );

alter collation pg_catalog."ky_KG.utf8" owner to postgres;

create collation pg_catalog."lb_LU" (
    locale = 'lb_LU'
    );

alter collation pg_catalog."lb_LU" owner to postgres;

create collation pg_catalog."lb_LU.utf8" (
    locale = 'lb_LU.utf8'
    );

alter collation pg_catalog."lb_LU.utf8" owner to postgres;

create collation pg_catalog."lg_UG" (
    locale = 'lg_UG.utf8'
    );

alter collation pg_catalog."lg_UG" owner to postgres;

create collation pg_catalog."lg_UG" (
    locale = 'lg_UG'
    );

alter collation pg_catalog."lg_UG" owner to postgres;

create collation pg_catalog."lg_UG.iso885910" (
    locale = 'lg_UG.iso885910'
    );

alter collation pg_catalog."lg_UG.iso885910" owner to postgres;

create collation pg_catalog."lg_UG.utf8" (
    locale = 'lg_UG.utf8'
    );

alter collation pg_catalog."lg_UG.utf8" owner to postgres;

create collation pg_catalog."li_BE" (
    locale = 'li_BE'
    );

alter collation pg_catalog."li_BE" owner to postgres;

create collation pg_catalog."li_BE.utf8" (
    locale = 'li_BE.utf8'
    );

alter collation pg_catalog."li_BE.utf8" owner to postgres;

create collation pg_catalog."li_NL" (
    locale = 'li_NL'
    );

alter collation pg_catalog."li_NL" owner to postgres;

create collation pg_catalog."li_NL.utf8" (
    locale = 'li_NL.utf8'
    );

alter collation pg_catalog."li_NL.utf8" owner to postgres;

create collation pg_catalog."lij_IT" (
    locale = 'lij_IT'
    );

alter collation pg_catalog."lij_IT" owner to postgres;

create collation pg_catalog."lij_IT.utf8" (
    locale = 'lij_IT.utf8'
    );

alter collation pg_catalog."lij_IT.utf8" owner to postgres;

create collation pg_catalog.lithuanian (
    locale = 'lithuanian'
    );

alter collation pg_catalog.lithuanian owner to postgres;

create collation pg_catalog."lo_LA" (
    locale = 'lo_LA'
    );

alter collation pg_catalog."lo_LA" owner to postgres;

create collation pg_catalog."lo_LA.utf8" (
    locale = 'lo_LA.utf8'
    );

alter collation pg_catalog."lo_LA.utf8" owner to postgres;

create collation pg_catalog."lt_LT" (
    locale = 'lt_LT.utf8'
    );

alter collation pg_catalog."lt_LT" owner to postgres;

create collation pg_catalog."lt_LT" (
    locale = 'lt_LT'
    );

alter collation pg_catalog."lt_LT" owner to postgres;

create collation pg_catalog."lt_LT.iso885913" (
    locale = 'lt_LT.iso885913'
    );

alter collation pg_catalog."lt_LT.iso885913" owner to postgres;

create collation pg_catalog."lt_LT.utf8" (
    locale = 'lt_LT.utf8'
    );

alter collation pg_catalog."lt_LT.utf8" owner to postgres;

create collation pg_catalog."lv_LV" (
    locale = 'lv_LV.utf8'
    );

alter collation pg_catalog."lv_LV" owner to postgres;

create collation pg_catalog."lv_LV" (
    locale = 'lv_LV'
    );

alter collation pg_catalog."lv_LV" owner to postgres;

create collation pg_catalog."lv_LV.iso885913" (
    locale = 'lv_LV.iso885913'
    );

alter collation pg_catalog."lv_LV.iso885913" owner to postgres;

create collation pg_catalog."lv_LV.utf8" (
    locale = 'lv_LV.utf8'
    );

alter collation pg_catalog."lv_LV.utf8" owner to postgres;

create collation pg_catalog."mag_IN" (
    locale = 'mag_IN'
    );

alter collation pg_catalog."mag_IN" owner to postgres;

create collation pg_catalog."mag_IN.utf8" (
    locale = 'mag_IN.utf8'
    );

alter collation pg_catalog."mag_IN.utf8" owner to postgres;

create collation pg_catalog."mai_IN" (
    locale = 'mai_IN'
    );

alter collation pg_catalog."mai_IN" owner to postgres;

create collation pg_catalog."mai_IN.utf8" (
    locale = 'mai_IN.utf8'
    );

alter collation pg_catalog."mai_IN.utf8" owner to postgres;

create collation pg_catalog."mg_MG" (
    locale = 'mg_MG.utf8'
    );

alter collation pg_catalog."mg_MG" owner to postgres;

create collation pg_catalog."mg_MG" (
    locale = 'mg_MG'
    );

alter collation pg_catalog."mg_MG" owner to postgres;

create collation pg_catalog."mg_MG.iso885915" (
    locale = 'mg_MG.iso885915'
    );

alter collation pg_catalog."mg_MG.iso885915" owner to postgres;

create collation pg_catalog."mg_MG.utf8" (
    locale = 'mg_MG.utf8'
    );

alter collation pg_catalog."mg_MG.utf8" owner to postgres;

create collation pg_catalog."mhr_RU" (
    locale = 'mhr_RU'
    );

alter collation pg_catalog."mhr_RU" owner to postgres;

create collation pg_catalog."mhr_RU.utf8" (
    locale = 'mhr_RU.utf8'
    );

alter collation pg_catalog."mhr_RU.utf8" owner to postgres;

create collation pg_catalog."mi_NZ" (
    locale = 'mi_NZ.utf8'
    );

alter collation pg_catalog."mi_NZ" owner to postgres;

create collation pg_catalog."mi_NZ" (
    locale = 'mi_NZ'
    );

alter collation pg_catalog."mi_NZ" owner to postgres;

create collation pg_catalog."mi_NZ.iso885913" (
    locale = 'mi_NZ.iso885913'
    );

alter collation pg_catalog."mi_NZ.iso885913" owner to postgres;

create collation pg_catalog."mi_NZ.utf8" (
    locale = 'mi_NZ.utf8'
    );

alter collation pg_catalog."mi_NZ.utf8" owner to postgres;

create collation pg_catalog."mk_MK" (
    locale = 'mk_MK.utf8'
    );

alter collation pg_catalog."mk_MK" owner to postgres;

create collation pg_catalog."mk_MK" (
    locale = 'mk_MK'
    );

alter collation pg_catalog."mk_MK" owner to postgres;

create collation pg_catalog."mk_MK.iso88595" (
    locale = 'mk_MK.iso88595'
    );

alter collation pg_catalog."mk_MK.iso88595" owner to postgres;

create collation pg_catalog."mk_MK.utf8" (
    locale = 'mk_MK.utf8'
    );

alter collation pg_catalog."mk_MK.utf8" owner to postgres;

create collation pg_catalog."ml_IN" (
    locale = 'ml_IN'
    );

alter collation pg_catalog."ml_IN" owner to postgres;

create collation pg_catalog."ml_IN.utf8" (
    locale = 'ml_IN.utf8'
    );

alter collation pg_catalog."ml_IN.utf8" owner to postgres;

create collation pg_catalog."mn_MN" (
    locale = 'mn_MN'
    );

alter collation pg_catalog."mn_MN" owner to postgres;

create collation pg_catalog."mn_MN.utf8" (
    locale = 'mn_MN.utf8'
    );

alter collation pg_catalog."mn_MN.utf8" owner to postgres;

create collation pg_catalog."mni_IN" (
    locale = 'mni_IN'
    );

alter collation pg_catalog."mni_IN" owner to postgres;

create collation pg_catalog."mni_IN.utf8" (
    locale = 'mni_IN.utf8'
    );

alter collation pg_catalog."mni_IN.utf8" owner to postgres;

create collation pg_catalog."mr_IN" (
    locale = 'mr_IN'
    );

alter collation pg_catalog."mr_IN" owner to postgres;

create collation pg_catalog."mr_IN.utf8" (
    locale = 'mr_IN.utf8'
    );

alter collation pg_catalog."mr_IN.utf8" owner to postgres;

create collation pg_catalog."ms_MY" (
    locale = 'ms_MY.utf8'
    );

alter collation pg_catalog."ms_MY" owner to postgres;

create collation pg_catalog."ms_MY" (
    locale = 'ms_MY'
    );

alter collation pg_catalog."ms_MY" owner to postgres;

create collation pg_catalog."ms_MY.iso88591" (
    locale = 'ms_MY.iso88591'
    );

alter collation pg_catalog."ms_MY.iso88591" owner to postgres;

create collation pg_catalog."ms_MY.utf8" (
    locale = 'ms_MY.utf8'
    );

alter collation pg_catalog."ms_MY.utf8" owner to postgres;

create collation pg_catalog."mt_MT" (
    locale = 'mt_MT.utf8'
    );

alter collation pg_catalog."mt_MT" owner to postgres;

create collation pg_catalog."mt_MT" (
    locale = 'mt_MT'
    );

alter collation pg_catalog."mt_MT" owner to postgres;

create collation pg_catalog."mt_MT.iso88593" (
    locale = 'mt_MT.iso88593'
    );

alter collation pg_catalog."mt_MT.iso88593" owner to postgres;

create collation pg_catalog."mt_MT.utf8" (
    locale = 'mt_MT.utf8'
    );

alter collation pg_catalog."mt_MT.utf8" owner to postgres;

create collation pg_catalog."my_MM" (
    locale = 'my_MM'
    );

alter collation pg_catalog."my_MM" owner to postgres;

create collation pg_catalog."my_MM.utf8" (
    locale = 'my_MM.utf8'
    );

alter collation pg_catalog."my_MM.utf8" owner to postgres;

create collation pg_catalog."nan_TW.utf8@latin" (
    locale = 'nan_TW.utf8@latin'
    );

alter collation pg_catalog."nan_TW.utf8@latin" owner to postgres;

create collation pg_catalog."nan_TW@latin" (
    locale = 'nan_TW@latin'
    );

alter collation pg_catalog."nan_TW@latin" owner to postgres;

create collation pg_catalog."nb_NO" (
    locale = 'nb_NO.utf8'
    );

alter collation pg_catalog."nb_NO" owner to postgres;

create collation pg_catalog."nb_NO" (
    locale = 'nb_NO'
    );

alter collation pg_catalog."nb_NO" owner to postgres;

create collation pg_catalog."nb_NO.iso88591" (
    locale = 'nb_NO.iso88591'
    );

alter collation pg_catalog."nb_NO.iso88591" owner to postgres;

create collation pg_catalog."nb_NO.utf8" (
    locale = 'nb_NO.utf8'
    );

alter collation pg_catalog."nb_NO.utf8" owner to postgres;

create collation pg_catalog."nds_DE" (
    locale = 'nds_DE'
    );

alter collation pg_catalog."nds_DE" owner to postgres;

create collation pg_catalog."nds_DE.utf8" (
    locale = 'nds_DE.utf8'
    );

alter collation pg_catalog."nds_DE.utf8" owner to postgres;

create collation pg_catalog."nds_NL" (
    locale = 'nds_NL'
    );

alter collation pg_catalog."nds_NL" owner to postgres;

create collation pg_catalog."nds_NL.utf8" (
    locale = 'nds_NL.utf8'
    );

alter collation pg_catalog."nds_NL.utf8" owner to postgres;

create collation pg_catalog."ne_NP" (
    locale = 'ne_NP'
    );

alter collation pg_catalog."ne_NP" owner to postgres;

create collation pg_catalog."ne_NP.utf8" (
    locale = 'ne_NP.utf8'
    );

alter collation pg_catalog."ne_NP.utf8" owner to postgres;

create collation pg_catalog."nhn_MX" (
    locale = 'nhn_MX'
    );

alter collation pg_catalog."nhn_MX" owner to postgres;

create collation pg_catalog."nhn_MX.utf8" (
    locale = 'nhn_MX.utf8'
    );

alter collation pg_catalog."nhn_MX.utf8" owner to postgres;

create collation pg_catalog."niu_NU" (
    locale = 'niu_NU'
    );

alter collation pg_catalog."niu_NU" owner to postgres;

create collation pg_catalog."niu_NU.utf8" (
    locale = 'niu_NU.utf8'
    );

alter collation pg_catalog."niu_NU.utf8" owner to postgres;

create collation pg_catalog."niu_NZ" (
    locale = 'niu_NZ'
    );

alter collation pg_catalog."niu_NZ" owner to postgres;

create collation pg_catalog."niu_NZ.utf8" (
    locale = 'niu_NZ.utf8'
    );

alter collation pg_catalog."niu_NZ.utf8" owner to postgres;

create collation pg_catalog."nl_AW" (
    locale = 'nl_AW'
    );

alter collation pg_catalog."nl_AW" owner to postgres;

create collation pg_catalog."nl_AW.utf8" (
    locale = 'nl_AW.utf8'
    );

alter collation pg_catalog."nl_AW.utf8" owner to postgres;

create collation pg_catalog."nl_BE" (
    locale = 'nl_BE.utf8'
    );

alter collation pg_catalog."nl_BE" owner to postgres;

create collation pg_catalog."nl_BE" (
    locale = 'nl_BE'
    );

alter collation pg_catalog."nl_BE" owner to postgres;

create collation pg_catalog."nl_BE.iso88591" (
    locale = 'nl_BE.iso88591'
    );

alter collation pg_catalog."nl_BE.iso88591" owner to postgres;

create collation pg_catalog."nl_BE.iso885915@euro" (
    locale = 'nl_BE.iso885915@euro'
    );

alter collation pg_catalog."nl_BE.iso885915@euro" owner to postgres;

create collation pg_catalog."nl_BE.utf8" (
    locale = 'nl_BE.utf8'
    );

alter collation pg_catalog."nl_BE.utf8" owner to postgres;

create collation pg_catalog."nl_BE@euro" (
    locale = 'nl_BE@euro'
    );

alter collation pg_catalog."nl_BE@euro" owner to postgres;

create collation pg_catalog."nl_NL" (
    locale = 'nl_NL.utf8'
    );

alter collation pg_catalog."nl_NL" owner to postgres;

create collation pg_catalog."nl_NL" (
    locale = 'nl_NL'
    );

alter collation pg_catalog."nl_NL" owner to postgres;

create collation pg_catalog."nl_NL.iso88591" (
    locale = 'nl_NL.iso88591'
    );

alter collation pg_catalog."nl_NL.iso88591" owner to postgres;

create collation pg_catalog."nl_NL.iso885915@euro" (
    locale = 'nl_NL.iso885915@euro'
    );

alter collation pg_catalog."nl_NL.iso885915@euro" owner to postgres;

create collation pg_catalog."nl_NL.utf8" (
    locale = 'nl_NL.utf8'
    );

alter collation pg_catalog."nl_NL.utf8" owner to postgres;

create collation pg_catalog."nl_NL@euro" (
    locale = 'nl_NL@euro'
    );

alter collation pg_catalog."nl_NL@euro" owner to postgres;

create collation pg_catalog."nn_NO" (
    locale = 'nn_NO.utf8'
    );

alter collation pg_catalog."nn_NO" owner to postgres;

create collation pg_catalog."nn_NO" (
    locale = 'nn_NO'
    );

alter collation pg_catalog."nn_NO" owner to postgres;

create collation pg_catalog."nn_NO.iso88591" (
    locale = 'nn_NO.iso88591'
    );

alter collation pg_catalog."nn_NO.iso88591" owner to postgres;

create collation pg_catalog."nn_NO.utf8" (
    locale = 'nn_NO.utf8'
    );

alter collation pg_catalog."nn_NO.utf8" owner to postgres;

create collation pg_catalog."no_NO" (
    locale = 'no_NO'
    );

alter collation pg_catalog."no_NO" owner to postgres;

create collation pg_catalog."no_NO.ISO-8859-1" (
    locale = 'no_NO.ISO-8859-1'
    );

alter collation pg_catalog."no_NO.ISO-8859-1" owner to postgres;

create collation pg_catalog.norwegian (
    locale = 'norwegian'
    );

alter collation pg_catalog.norwegian owner to postgres;

create collation pg_catalog."nr_ZA" (
    locale = 'nr_ZA'
    );

alter collation pg_catalog."nr_ZA" owner to postgres;

create collation pg_catalog."nr_ZA.utf8" (
    locale = 'nr_ZA.utf8'
    );

alter collation pg_catalog."nr_ZA.utf8" owner to postgres;

create collation pg_catalog."nso_ZA" (
    locale = 'nso_ZA'
    );

alter collation pg_catalog."nso_ZA" owner to postgres;

create collation pg_catalog."nso_ZA.utf8" (
    locale = 'nso_ZA.utf8'
    );

alter collation pg_catalog."nso_ZA.utf8" owner to postgres;

create collation pg_catalog.nynorsk (
    locale = 'nynorsk'
    );

alter collation pg_catalog.nynorsk owner to postgres;

create collation pg_catalog."oc_FR" (
    locale = 'oc_FR.utf8'
    );

alter collation pg_catalog."oc_FR" owner to postgres;

create collation pg_catalog."oc_FR" (
    locale = 'oc_FR'
    );

alter collation pg_catalog."oc_FR" owner to postgres;

create collation pg_catalog."oc_FR.iso88591" (
    locale = 'oc_FR.iso88591'
    );

alter collation pg_catalog."oc_FR.iso88591" owner to postgres;

create collation pg_catalog."oc_FR.utf8" (
    locale = 'oc_FR.utf8'
    );

alter collation pg_catalog."oc_FR.utf8" owner to postgres;

create collation pg_catalog."om_ET" (
    locale = 'om_ET'
    );

alter collation pg_catalog."om_ET" owner to postgres;

create collation pg_catalog."om_ET.utf8" (
    locale = 'om_ET.utf8'
    );

alter collation pg_catalog."om_ET.utf8" owner to postgres;

create collation pg_catalog."om_KE" (
    locale = 'om_KE.utf8'
    );

alter collation pg_catalog."om_KE" owner to postgres;

create collation pg_catalog."om_KE" (
    locale = 'om_KE'
    );

alter collation pg_catalog."om_KE" owner to postgres;

create collation pg_catalog."om_KE.iso88591" (
    locale = 'om_KE.iso88591'
    );

alter collation pg_catalog."om_KE.iso88591" owner to postgres;

create collation pg_catalog."om_KE.utf8" (
    locale = 'om_KE.utf8'
    );

alter collation pg_catalog."om_KE.utf8" owner to postgres;

create collation pg_catalog."or_IN" (
    locale = 'or_IN'
    );

alter collation pg_catalog."or_IN" owner to postgres;

create collation pg_catalog."or_IN.utf8" (
    locale = 'or_IN.utf8'
    );

alter collation pg_catalog."or_IN.utf8" owner to postgres;

create collation pg_catalog."os_RU" (
    locale = 'os_RU'
    );

alter collation pg_catalog."os_RU" owner to postgres;

create collation pg_catalog."os_RU.utf8" (
    locale = 'os_RU.utf8'
    );

alter collation pg_catalog."os_RU.utf8" owner to postgres;

create collation pg_catalog."pa_IN" (
    locale = 'pa_IN'
    );

alter collation pg_catalog."pa_IN" owner to postgres;

create collation pg_catalog."pa_IN.utf8" (
    locale = 'pa_IN.utf8'
    );

alter collation pg_catalog."pa_IN.utf8" owner to postgres;

create collation pg_catalog."pa_PK" (
    locale = 'pa_PK'
    );

alter collation pg_catalog."pa_PK" owner to postgres;

create collation pg_catalog."pa_PK.utf8" (
    locale = 'pa_PK.utf8'
    );

alter collation pg_catalog."pa_PK.utf8" owner to postgres;

create collation pg_catalog."pap_AN" (
    locale = 'pap_AN'
    );

alter collation pg_catalog."pap_AN" owner to postgres;

create collation pg_catalog."pap_AN.utf8" (
    locale = 'pap_AN.utf8'
    );

alter collation pg_catalog."pap_AN.utf8" owner to postgres;

create collation pg_catalog."pl_PL" (
    locale = 'pl_PL.utf8'
    );

alter collation pg_catalog."pl_PL" owner to postgres;

create collation pg_catalog."pl_PL" (
    locale = 'pl_PL'
    );

alter collation pg_catalog."pl_PL" owner to postgres;

create collation pg_catalog."pl_PL.iso88592" (
    locale = 'pl_PL.iso88592'
    );

alter collation pg_catalog."pl_PL.iso88592" owner to postgres;

create collation pg_catalog."pl_PL.utf8" (
    locale = 'pl_PL.utf8'
    );

alter collation pg_catalog."pl_PL.utf8" owner to postgres;

create collation pg_catalog.polish (
    locale = 'polish'
    );

alter collation pg_catalog.polish owner to postgres;

create collation pg_catalog.portuguese (
    locale = 'portuguese'
    );

alter collation pg_catalog.portuguese owner to postgres;

create collation pg_catalog."ps_AF" (
    locale = 'ps_AF'
    );

alter collation pg_catalog."ps_AF" owner to postgres;

create collation pg_catalog."ps_AF.utf8" (
    locale = 'ps_AF.utf8'
    );

alter collation pg_catalog."ps_AF.utf8" owner to postgres;

create collation pg_catalog."pt_BR" (
    locale = 'pt_BR.utf8'
    );

alter collation pg_catalog."pt_BR" owner to postgres;

create collation pg_catalog."pt_BR" (
    locale = 'pt_BR'
    );

alter collation pg_catalog."pt_BR" owner to postgres;

create collation pg_catalog."pt_BR.iso88591" (
    locale = 'pt_BR.iso88591'
    );

alter collation pg_catalog."pt_BR.iso88591" owner to postgres;

create collation pg_catalog."pt_BR.utf8" (
    locale = 'pt_BR.utf8'
    );

alter collation pg_catalog."pt_BR.utf8" owner to postgres;

create collation pg_catalog."pt_PT" (
    locale = 'pt_PT.utf8'
    );

alter collation pg_catalog."pt_PT" owner to postgres;

create collation pg_catalog."pt_PT" (
    locale = 'pt_PT'
    );

alter collation pg_catalog."pt_PT" owner to postgres;

create collation pg_catalog."pt_PT.iso88591" (
    locale = 'pt_PT.iso88591'
    );

alter collation pg_catalog."pt_PT.iso88591" owner to postgres;

create collation pg_catalog."pt_PT.iso885915@euro" (
    locale = 'pt_PT.iso885915@euro'
    );

alter collation pg_catalog."pt_PT.iso885915@euro" owner to postgres;

create collation pg_catalog."pt_PT.utf8" (
    locale = 'pt_PT.utf8'
    );

alter collation pg_catalog."pt_PT.utf8" owner to postgres;

create collation pg_catalog."pt_PT@euro" (
    locale = 'pt_PT@euro'
    );

alter collation pg_catalog."pt_PT@euro" owner to postgres;

create collation pg_catalog."ro_RO" (
    locale = 'ro_RO.utf8'
    );

alter collation pg_catalog."ro_RO" owner to postgres;

create collation pg_catalog."ro_RO" (
    locale = 'ro_RO'
    );

alter collation pg_catalog."ro_RO" owner to postgres;

create collation pg_catalog."ro_RO.iso88592" (
    locale = 'ro_RO.iso88592'
    );

alter collation pg_catalog."ro_RO.iso88592" owner to postgres;

create collation pg_catalog."ro_RO.utf8" (
    locale = 'ro_RO.utf8'
    );

alter collation pg_catalog."ro_RO.utf8" owner to postgres;

create collation pg_catalog.romanian (
    locale = 'romanian'
    );

alter collation pg_catalog.romanian owner to postgres;

create collation pg_catalog."ru_RU" (
    locale = 'ru_RU.utf8'
    );

alter collation pg_catalog."ru_RU" owner to postgres;

create collation pg_catalog."ru_RU" (
    locale = 'ru_RU.koi8r'
    );

alter collation pg_catalog."ru_RU" owner to postgres;

create collation pg_catalog."ru_RU" (
    locale = 'ru_RU'
    );

alter collation pg_catalog."ru_RU" owner to postgres;

create collation pg_catalog."ru_RU.iso88595" (
    locale = 'ru_RU.iso88595'
    );

alter collation pg_catalog."ru_RU.iso88595" owner to postgres;

create collation pg_catalog."ru_RU.koi8r" (
    locale = 'ru_RU.koi8r'
    );

alter collation pg_catalog."ru_RU.koi8r" owner to postgres;

create collation pg_catalog."ru_RU.utf8" (
    locale = 'ru_RU.utf8'
    );

alter collation pg_catalog."ru_RU.utf8" owner to postgres;

create collation pg_catalog."ru_UA" (
    locale = 'ru_UA.utf8'
    );

alter collation pg_catalog."ru_UA" owner to postgres;

create collation pg_catalog."ru_UA" (
    locale = 'ru_UA'
    );

alter collation pg_catalog."ru_UA" owner to postgres;

create collation pg_catalog."ru_UA.koi8u" (
    locale = 'ru_UA.koi8u'
    );

alter collation pg_catalog."ru_UA.koi8u" owner to postgres;

create collation pg_catalog."ru_UA.utf8" (
    locale = 'ru_UA.utf8'
    );

alter collation pg_catalog."ru_UA.utf8" owner to postgres;

create collation pg_catalog.russian (
    locale = 'russian'
    );

alter collation pg_catalog.russian owner to postgres;

create collation pg_catalog."rw_RW" (
    locale = 'rw_RW'
    );

alter collation pg_catalog."rw_RW" owner to postgres;

create collation pg_catalog."rw_RW.utf8" (
    locale = 'rw_RW.utf8'
    );

alter collation pg_catalog."rw_RW.utf8" owner to postgres;

create collation pg_catalog."sa_IN" (
    locale = 'sa_IN'
    );

alter collation pg_catalog."sa_IN" owner to postgres;

create collation pg_catalog."sa_IN.utf8" (
    locale = 'sa_IN.utf8'
    );

alter collation pg_catalog."sa_IN.utf8" owner to postgres;

create collation pg_catalog."sat_IN" (
    locale = 'sat_IN'
    );

alter collation pg_catalog."sat_IN" owner to postgres;

create collation pg_catalog."sat_IN.utf8" (
    locale = 'sat_IN.utf8'
    );

alter collation pg_catalog."sat_IN.utf8" owner to postgres;

create collation pg_catalog."sc_IT" (
    locale = 'sc_IT'
    );

alter collation pg_catalog."sc_IT" owner to postgres;

create collation pg_catalog."sc_IT.utf8" (
    locale = 'sc_IT.utf8'
    );

alter collation pg_catalog."sc_IT.utf8" owner to postgres;

create collation pg_catalog."sd_IN" (
    locale = 'sd_IN'
    );

alter collation pg_catalog."sd_IN" owner to postgres;

create collation pg_catalog."sd_IN.utf8" (
    locale = 'sd_IN.utf8'
    );

alter collation pg_catalog."sd_IN.utf8" owner to postgres;

create collation pg_catalog."sd_IN.utf8@devanagari" (
    locale = 'sd_IN.utf8@devanagari'
    );

alter collation pg_catalog."sd_IN.utf8@devanagari" owner to postgres;

create collation pg_catalog."sd_IN@devanagari" (
    locale = 'sd_IN@devanagari'
    );

alter collation pg_catalog."sd_IN@devanagari" owner to postgres;

create collation pg_catalog."se_NO" (
    locale = 'se_NO'
    );

alter collation pg_catalog."se_NO" owner to postgres;

create collation pg_catalog."se_NO.utf8" (
    locale = 'se_NO.utf8'
    );

alter collation pg_catalog."se_NO.utf8" owner to postgres;

create collation pg_catalog."shs_CA" (
    locale = 'shs_CA'
    );

alter collation pg_catalog."shs_CA" owner to postgres;

create collation pg_catalog."shs_CA.utf8" (
    locale = 'shs_CA.utf8'
    );

alter collation pg_catalog."shs_CA.utf8" owner to postgres;

create collation pg_catalog."si_LK" (
    locale = 'si_LK'
    );

alter collation pg_catalog."si_LK" owner to postgres;

create collation pg_catalog."si_LK.utf8" (
    locale = 'si_LK.utf8'
    );

alter collation pg_catalog."si_LK.utf8" owner to postgres;

create collation pg_catalog."sid_ET" (
    locale = 'sid_ET'
    );

alter collation pg_catalog."sid_ET" owner to postgres;

create collation pg_catalog."sid_ET.utf8" (
    locale = 'sid_ET.utf8'
    );

alter collation pg_catalog."sid_ET.utf8" owner to postgres;

create collation pg_catalog."sk_SK" (
    locale = 'sk_SK.utf8'
    );

alter collation pg_catalog."sk_SK" owner to postgres;

create collation pg_catalog."sk_SK" (
    locale = 'sk_SK'
    );

alter collation pg_catalog."sk_SK" owner to postgres;

create collation pg_catalog."sk_SK.iso88592" (
    locale = 'sk_SK.iso88592'
    );

alter collation pg_catalog."sk_SK.iso88592" owner to postgres;

create collation pg_catalog."sk_SK.utf8" (
    locale = 'sk_SK.utf8'
    );

alter collation pg_catalog."sk_SK.utf8" owner to postgres;

create collation pg_catalog."sl_SI" (
    locale = 'sl_SI.utf8'
    );

alter collation pg_catalog."sl_SI" owner to postgres;

create collation pg_catalog."sl_SI" (
    locale = 'sl_SI'
    );

alter collation pg_catalog."sl_SI" owner to postgres;

create collation pg_catalog."sl_SI.iso88592" (
    locale = 'sl_SI.iso88592'
    );

alter collation pg_catalog."sl_SI.iso88592" owner to postgres;

create collation pg_catalog."sl_SI.utf8" (
    locale = 'sl_SI.utf8'
    );

alter collation pg_catalog."sl_SI.utf8" owner to postgres;

create collation pg_catalog.slovak (
    locale = 'slovak'
    );

alter collation pg_catalog.slovak owner to postgres;

create collation pg_catalog.slovene (
    locale = 'slovene'
    );

alter collation pg_catalog.slovene owner to postgres;

create collation pg_catalog.slovenian (
    locale = 'slovenian'
    );

alter collation pg_catalog.slovenian owner to postgres;

create collation pg_catalog."so_DJ" (
    locale = 'so_DJ.utf8'
    );

alter collation pg_catalog."so_DJ" owner to postgres;

create collation pg_catalog."so_DJ" (
    locale = 'so_DJ'
    );

alter collation pg_catalog."so_DJ" owner to postgres;

create collation pg_catalog."so_DJ.iso88591" (
    locale = 'so_DJ.iso88591'
    );

alter collation pg_catalog."so_DJ.iso88591" owner to postgres;

create collation pg_catalog."so_DJ.utf8" (
    locale = 'so_DJ.utf8'
    );

alter collation pg_catalog."so_DJ.utf8" owner to postgres;

create collation pg_catalog."so_ET" (
    locale = 'so_ET'
    );

alter collation pg_catalog."so_ET" owner to postgres;

create collation pg_catalog."so_ET.utf8" (
    locale = 'so_ET.utf8'
    );

alter collation pg_catalog."so_ET.utf8" owner to postgres;

create collation pg_catalog."so_KE" (
    locale = 'so_KE.utf8'
    );

alter collation pg_catalog."so_KE" owner to postgres;

create collation pg_catalog."so_KE" (
    locale = 'so_KE'
    );

alter collation pg_catalog."so_KE" owner to postgres;

create collation pg_catalog."so_KE.iso88591" (
    locale = 'so_KE.iso88591'
    );

alter collation pg_catalog."so_KE.iso88591" owner to postgres;

create collation pg_catalog."so_KE.utf8" (
    locale = 'so_KE.utf8'
    );

alter collation pg_catalog."so_KE.utf8" owner to postgres;

create collation pg_catalog."so_SO" (
    locale = 'so_SO.utf8'
    );

alter collation pg_catalog."so_SO" owner to postgres;

create collation pg_catalog."so_SO" (
    locale = 'so_SO'
    );

alter collation pg_catalog."so_SO" owner to postgres;

create collation pg_catalog."so_SO.iso88591" (
    locale = 'so_SO.iso88591'
    );

alter collation pg_catalog."so_SO.iso88591" owner to postgres;

create collation pg_catalog."so_SO.utf8" (
    locale = 'so_SO.utf8'
    );

alter collation pg_catalog."so_SO.utf8" owner to postgres;

create collation pg_catalog.spanish (
    locale = 'spanish'
    );

alter collation pg_catalog.spanish owner to postgres;

create collation pg_catalog."sq_AL" (
    locale = 'sq_AL.utf8'
    );

alter collation pg_catalog."sq_AL" owner to postgres;

create collation pg_catalog."sq_AL" (
    locale = 'sq_AL'
    );

alter collation pg_catalog."sq_AL" owner to postgres;

create collation pg_catalog."sq_AL.iso88591" (
    locale = 'sq_AL.iso88591'
    );

alter collation pg_catalog."sq_AL.iso88591" owner to postgres;

create collation pg_catalog."sq_AL.utf8" (
    locale = 'sq_AL.utf8'
    );

alter collation pg_catalog."sq_AL.utf8" owner to postgres;

create collation pg_catalog."sq_MK" (
    locale = 'sq_MK'
    );

alter collation pg_catalog."sq_MK" owner to postgres;

create collation pg_catalog."sq_MK.utf8" (
    locale = 'sq_MK.utf8'
    );

alter collation pg_catalog."sq_MK.utf8" owner to postgres;

create collation pg_catalog."sr_ME" (
    locale = 'sr_ME'
    );

alter collation pg_catalog."sr_ME" owner to postgres;

create collation pg_catalog."sr_ME.utf8" (
    locale = 'sr_ME.utf8'
    );

alter collation pg_catalog."sr_ME.utf8" owner to postgres;

create collation pg_catalog."sr_RS" (
    locale = 'sr_RS'
    );

alter collation pg_catalog."sr_RS" owner to postgres;

create collation pg_catalog."sr_RS.utf8" (
    locale = 'sr_RS.utf8'
    );

alter collation pg_catalog."sr_RS.utf8" owner to postgres;

create collation pg_catalog."sr_RS.utf8@latin" (
    locale = 'sr_RS.utf8@latin'
    );

alter collation pg_catalog."sr_RS.utf8@latin" owner to postgres;

create collation pg_catalog."sr_RS@latin" (
    locale = 'sr_RS@latin'
    );

alter collation pg_catalog."sr_RS@latin" owner to postgres;

create collation pg_catalog."ss_ZA" (
    locale = 'ss_ZA'
    );

alter collation pg_catalog."ss_ZA" owner to postgres;

create collation pg_catalog."ss_ZA.utf8" (
    locale = 'ss_ZA.utf8'
    );

alter collation pg_catalog."ss_ZA.utf8" owner to postgres;

create collation pg_catalog."st_ZA" (
    locale = 'st_ZA.utf8'
    );

alter collation pg_catalog."st_ZA" owner to postgres;

create collation pg_catalog."st_ZA" (
    locale = 'st_ZA'
    );

alter collation pg_catalog."st_ZA" owner to postgres;

create collation pg_catalog."st_ZA.iso88591" (
    locale = 'st_ZA.iso88591'
    );

alter collation pg_catalog."st_ZA.iso88591" owner to postgres;

create collation pg_catalog."st_ZA.utf8" (
    locale = 'st_ZA.utf8'
    );

alter collation pg_catalog."st_ZA.utf8" owner to postgres;

create collation pg_catalog."sv_FI" (
    locale = 'sv_FI.utf8'
    );

alter collation pg_catalog."sv_FI" owner to postgres;

create collation pg_catalog."sv_FI" (
    locale = 'sv_FI'
    );

alter collation pg_catalog."sv_FI" owner to postgres;

create collation pg_catalog."sv_FI.iso88591" (
    locale = 'sv_FI.iso88591'
    );

alter collation pg_catalog."sv_FI.iso88591" owner to postgres;

create collation pg_catalog."sv_FI.iso885915@euro" (
    locale = 'sv_FI.iso885915@euro'
    );

alter collation pg_catalog."sv_FI.iso885915@euro" owner to postgres;

create collation pg_catalog."sv_FI.utf8" (
    locale = 'sv_FI.utf8'
    );

alter collation pg_catalog."sv_FI.utf8" owner to postgres;

create collation pg_catalog."sv_FI@euro" (
    locale = 'sv_FI@euro'
    );

alter collation pg_catalog."sv_FI@euro" owner to postgres;

create collation pg_catalog."sv_SE" (
    locale = 'sv_SE.utf8'
    );

alter collation pg_catalog."sv_SE" owner to postgres;

create collation pg_catalog."sv_SE" (
    locale = 'sv_SE'
    );

alter collation pg_catalog."sv_SE" owner to postgres;

create collation pg_catalog."sv_SE" (
    locale = 'sv_SE.iso885915'
    );

alter collation pg_catalog."sv_SE" owner to postgres;

create collation pg_catalog."sv_SE.iso88591" (
    locale = 'sv_SE.iso88591'
    );

alter collation pg_catalog."sv_SE.iso88591" owner to postgres;

create collation pg_catalog."sv_SE.iso885915" (
    locale = 'sv_SE.iso885915'
    );

alter collation pg_catalog."sv_SE.iso885915" owner to postgres;

create collation pg_catalog."sv_SE.utf8" (
    locale = 'sv_SE.utf8'
    );

alter collation pg_catalog."sv_SE.utf8" owner to postgres;

create collation pg_catalog."sw_KE" (
    locale = 'sw_KE'
    );

alter collation pg_catalog."sw_KE" owner to postgres;

create collation pg_catalog."sw_KE.utf8" (
    locale = 'sw_KE.utf8'
    );

alter collation pg_catalog."sw_KE.utf8" owner to postgres;

create collation pg_catalog."sw_TZ" (
    locale = 'sw_TZ'
    );

alter collation pg_catalog."sw_TZ" owner to postgres;

create collation pg_catalog."sw_TZ.utf8" (
    locale = 'sw_TZ.utf8'
    );

alter collation pg_catalog."sw_TZ.utf8" owner to postgres;

create collation pg_catalog.swedish (
    locale = 'swedish'
    );

alter collation pg_catalog.swedish owner to postgres;

create collation pg_catalog."szl_PL" (
    locale = 'szl_PL'
    );

alter collation pg_catalog."szl_PL" owner to postgres;

create collation pg_catalog."szl_PL.utf8" (
    locale = 'szl_PL.utf8'
    );

alter collation pg_catalog."szl_PL.utf8" owner to postgres;

create collation pg_catalog."ta_IN" (
    locale = 'ta_IN'
    );

alter collation pg_catalog."ta_IN" owner to postgres;

create collation pg_catalog."ta_IN.utf8" (
    locale = 'ta_IN.utf8'
    );

alter collation pg_catalog."ta_IN.utf8" owner to postgres;

create collation pg_catalog."ta_LK" (
    locale = 'ta_LK'
    );

alter collation pg_catalog."ta_LK" owner to postgres;

create collation pg_catalog."ta_LK.utf8" (
    locale = 'ta_LK.utf8'
    );

alter collation pg_catalog."ta_LK.utf8" owner to postgres;

create collation pg_catalog."te_IN" (
    locale = 'te_IN'
    );

alter collation pg_catalog."te_IN" owner to postgres;

create collation pg_catalog."te_IN.utf8" (
    locale = 'te_IN.utf8'
    );

alter collation pg_catalog."te_IN.utf8" owner to postgres;

create collation pg_catalog."tg_TJ" (
    locale = 'tg_TJ.utf8'
    );

alter collation pg_catalog."tg_TJ" owner to postgres;

create collation pg_catalog."tg_TJ.utf8" (
    locale = 'tg_TJ.utf8'
    );

alter collation pg_catalog."tg_TJ.utf8" owner to postgres;

create collation pg_catalog."th_TH" (
    locale = 'th_TH.utf8'
    );

alter collation pg_catalog."th_TH" owner to postgres;

create collation pg_catalog."th_TH.utf8" (
    locale = 'th_TH.utf8'
    );

alter collation pg_catalog."th_TH.utf8" owner to postgres;

create collation pg_catalog."ti_ER" (
    locale = 'ti_ER'
    );

alter collation pg_catalog."ti_ER" owner to postgres;

create collation pg_catalog."ti_ER.utf8" (
    locale = 'ti_ER.utf8'
    );

alter collation pg_catalog."ti_ER.utf8" owner to postgres;

create collation pg_catalog."ti_ET" (
    locale = 'ti_ET'
    );

alter collation pg_catalog."ti_ET" owner to postgres;

create collation pg_catalog."ti_ET.utf8" (
    locale = 'ti_ET.utf8'
    );

alter collation pg_catalog."ti_ET.utf8" owner to postgres;

create collation pg_catalog."tig_ER" (
    locale = 'tig_ER'
    );

alter collation pg_catalog."tig_ER" owner to postgres;

create collation pg_catalog."tig_ER.utf8" (
    locale = 'tig_ER.utf8'
    );

alter collation pg_catalog."tig_ER.utf8" owner to postgres;

create collation pg_catalog."tk_TM" (
    locale = 'tk_TM'
    );

alter collation pg_catalog."tk_TM" owner to postgres;

create collation pg_catalog."tk_TM.utf8" (
    locale = 'tk_TM.utf8'
    );

alter collation pg_catalog."tk_TM.utf8" owner to postgres;

create collation pg_catalog."tl_PH" (
    locale = 'tl_PH.utf8'
    );

alter collation pg_catalog."tl_PH" owner to postgres;

create collation pg_catalog."tl_PH" (
    locale = 'tl_PH'
    );

alter collation pg_catalog."tl_PH" owner to postgres;

create collation pg_catalog."tl_PH.iso88591" (
    locale = 'tl_PH.iso88591'
    );

alter collation pg_catalog."tl_PH.iso88591" owner to postgres;

create collation pg_catalog."tl_PH.utf8" (
    locale = 'tl_PH.utf8'
    );

alter collation pg_catalog."tl_PH.utf8" owner to postgres;

create collation pg_catalog."tn_ZA" (
    locale = 'tn_ZA'
    );

alter collation pg_catalog."tn_ZA" owner to postgres;

create collation pg_catalog."tn_ZA.utf8" (
    locale = 'tn_ZA.utf8'
    );

alter collation pg_catalog."tn_ZA.utf8" owner to postgres;

create collation pg_catalog."tr_CY" (
    locale = 'tr_CY.utf8'
    );

alter collation pg_catalog."tr_CY" owner to postgres;

create collation pg_catalog."tr_CY" (
    locale = 'tr_CY'
    );

alter collation pg_catalog."tr_CY" owner to postgres;

create collation pg_catalog."tr_CY.iso88599" (
    locale = 'tr_CY.iso88599'
    );

alter collation pg_catalog."tr_CY.iso88599" owner to postgres;

create collation pg_catalog."tr_CY.utf8" (
    locale = 'tr_CY.utf8'
    );

alter collation pg_catalog."tr_CY.utf8" owner to postgres;

create collation pg_catalog."tr_TR" (
    locale = 'tr_TR.utf8'
    );

alter collation pg_catalog."tr_TR" owner to postgres;

create collation pg_catalog."tr_TR" (
    locale = 'tr_TR'
    );

alter collation pg_catalog."tr_TR" owner to postgres;

create collation pg_catalog."tr_TR.iso88599" (
    locale = 'tr_TR.iso88599'
    );

alter collation pg_catalog."tr_TR.iso88599" owner to postgres;

create collation pg_catalog."tr_TR.utf8" (
    locale = 'tr_TR.utf8'
    );

alter collation pg_catalog."tr_TR.utf8" owner to postgres;

create collation pg_catalog."ts_ZA" (
    locale = 'ts_ZA'
    );

alter collation pg_catalog."ts_ZA" owner to postgres;

create collation pg_catalog."ts_ZA.utf8" (
    locale = 'ts_ZA.utf8'
    );

alter collation pg_catalog."ts_ZA.utf8" owner to postgres;

create collation pg_catalog."tt_RU" (
    locale = 'tt_RU'
    );

alter collation pg_catalog."tt_RU" owner to postgres;

create collation pg_catalog."tt_RU.utf8" (
    locale = 'tt_RU.utf8'
    );

alter collation pg_catalog."tt_RU.utf8" owner to postgres;

create collation pg_catalog."tt_RU.utf8@iqtelif" (
    locale = 'tt_RU.utf8@iqtelif'
    );

alter collation pg_catalog."tt_RU.utf8@iqtelif" owner to postgres;

create collation pg_catalog."tt_RU@iqtelif" (
    locale = 'tt_RU@iqtelif'
    );

alter collation pg_catalog."tt_RU@iqtelif" owner to postgres;

create collation pg_catalog.turkish (
    locale = 'turkish'
    );

alter collation pg_catalog.turkish owner to postgres;

create collation pg_catalog.ucs_basic (
    locale = 'C'
    );

alter collation pg_catalog.ucs_basic owner to postgres;

create collation pg_catalog."ug_CN" (
    locale = 'ug_CN'
    );

alter collation pg_catalog."ug_CN" owner to postgres;

create collation pg_catalog."ug_CN.utf8" (
    locale = 'ug_CN.utf8'
    );

alter collation pg_catalog."ug_CN.utf8" owner to postgres;

create collation pg_catalog."uk_UA" (
    locale = 'uk_UA.utf8'
    );

alter collation pg_catalog."uk_UA" owner to postgres;

create collation pg_catalog."uk_UA" (
    locale = 'uk_UA'
    );

alter collation pg_catalog."uk_UA" owner to postgres;

create collation pg_catalog."uk_UA.koi8u" (
    locale = 'uk_UA.koi8u'
    );

alter collation pg_catalog."uk_UA.koi8u" owner to postgres;

create collation pg_catalog."uk_UA.utf8" (
    locale = 'uk_UA.utf8'
    );

alter collation pg_catalog."uk_UA.utf8" owner to postgres;

create collation pg_catalog."unm_US" (
    locale = 'unm_US'
    );

alter collation pg_catalog."unm_US" owner to postgres;

create collation pg_catalog."unm_US.utf8" (
    locale = 'unm_US.utf8'
    );

alter collation pg_catalog."unm_US.utf8" owner to postgres;

create collation pg_catalog."ur_IN" (
    locale = 'ur_IN'
    );

alter collation pg_catalog."ur_IN" owner to postgres;

create collation pg_catalog."ur_IN.utf8" (
    locale = 'ur_IN.utf8'
    );

alter collation pg_catalog."ur_IN.utf8" owner to postgres;

create collation pg_catalog."ur_PK" (
    locale = 'ur_PK'
    );

alter collation pg_catalog."ur_PK" owner to postgres;

create collation pg_catalog."ur_PK.utf8" (
    locale = 'ur_PK.utf8'
    );

alter collation pg_catalog."ur_PK.utf8" owner to postgres;

create collation pg_catalog."uz_UZ" (
    locale = 'uz_UZ'
    );

alter collation pg_catalog."uz_UZ" owner to postgres;

create collation pg_catalog."uz_UZ.iso88591" (
    locale = 'uz_UZ.iso88591'
    );

alter collation pg_catalog."uz_UZ.iso88591" owner to postgres;

create collation pg_catalog."uz_UZ.utf8@cyrillic" (
    locale = 'uz_UZ.utf8@cyrillic'
    );

alter collation pg_catalog."uz_UZ.utf8@cyrillic" owner to postgres;

create collation pg_catalog."uz_UZ@cyrillic" (
    locale = 'uz_UZ@cyrillic'
    );

alter collation pg_catalog."uz_UZ@cyrillic" owner to postgres;

create collation pg_catalog."ve_ZA" (
    locale = 've_ZA'
    );

alter collation pg_catalog."ve_ZA" owner to postgres;

create collation pg_catalog."ve_ZA.utf8" (
    locale = 've_ZA.utf8'
    );

alter collation pg_catalog."ve_ZA.utf8" owner to postgres;

create collation pg_catalog."vi_VN" (
    locale = 'vi_VN'
    );

alter collation pg_catalog."vi_VN" owner to postgres;

create collation pg_catalog."vi_VN.utf8" (
    locale = 'vi_VN.utf8'
    );

alter collation pg_catalog."vi_VN.utf8" owner to postgres;

create collation pg_catalog."wa_BE" (
    locale = 'wa_BE.utf8'
    );

alter collation pg_catalog."wa_BE" owner to postgres;

create collation pg_catalog."wa_BE" (
    locale = 'wa_BE'
    );

alter collation pg_catalog."wa_BE" owner to postgres;

create collation pg_catalog."wa_BE.iso88591" (
    locale = 'wa_BE.iso88591'
    );

alter collation pg_catalog."wa_BE.iso88591" owner to postgres;

create collation pg_catalog."wa_BE.iso885915@euro" (
    locale = 'wa_BE.iso885915@euro'
    );

alter collation pg_catalog."wa_BE.iso885915@euro" owner to postgres;

create collation pg_catalog."wa_BE.utf8" (
    locale = 'wa_BE.utf8'
    );

alter collation pg_catalog."wa_BE.utf8" owner to postgres;

create collation pg_catalog."wa_BE@euro" (
    locale = 'wa_BE@euro'
    );

alter collation pg_catalog."wa_BE@euro" owner to postgres;

create collation pg_catalog."wae_CH" (
    locale = 'wae_CH'
    );

alter collation pg_catalog."wae_CH" owner to postgres;

create collation pg_catalog."wae_CH.utf8" (
    locale = 'wae_CH.utf8'
    );

alter collation pg_catalog."wae_CH.utf8" owner to postgres;

create collation pg_catalog."wal_ET" (
    locale = 'wal_ET'
    );

alter collation pg_catalog."wal_ET" owner to postgres;

create collation pg_catalog."wal_ET.utf8" (
    locale = 'wal_ET.utf8'
    );

alter collation pg_catalog."wal_ET.utf8" owner to postgres;

create collation pg_catalog."wo_SN" (
    locale = 'wo_SN'
    );

alter collation pg_catalog."wo_SN" owner to postgres;

create collation pg_catalog."wo_SN.utf8" (
    locale = 'wo_SN.utf8'
    );

alter collation pg_catalog."wo_SN.utf8" owner to postgres;

create collation pg_catalog."xh_ZA" (
    locale = 'xh_ZA.utf8'
    );

alter collation pg_catalog."xh_ZA" owner to postgres;

create collation pg_catalog."xh_ZA" (
    locale = 'xh_ZA'
    );

alter collation pg_catalog."xh_ZA" owner to postgres;

create collation pg_catalog."xh_ZA.iso88591" (
    locale = 'xh_ZA.iso88591'
    );

alter collation pg_catalog."xh_ZA.iso88591" owner to postgres;

create collation pg_catalog."xh_ZA.utf8" (
    locale = 'xh_ZA.utf8'
    );

alter collation pg_catalog."xh_ZA.utf8" owner to postgres;

create collation pg_catalog."yi_US" (
    locale = 'yi_US.utf8'
    );

alter collation pg_catalog."yi_US" owner to postgres;

create collation pg_catalog."yi_US" (
    locale = 'yi_US'
    );

alter collation pg_catalog."yi_US" owner to postgres;

create collation pg_catalog."yi_US.cp1255" (
    locale = 'yi_US.cp1255'
    );

alter collation pg_catalog."yi_US.cp1255" owner to postgres;

create collation pg_catalog."yi_US.utf8" (
    locale = 'yi_US.utf8'
    );

alter collation pg_catalog."yi_US.utf8" owner to postgres;

create collation pg_catalog."yo_NG" (
    locale = 'yo_NG'
    );

alter collation pg_catalog."yo_NG" owner to postgres;

create collation pg_catalog."yo_NG.utf8" (
    locale = 'yo_NG.utf8'
    );

alter collation pg_catalog."yo_NG.utf8" owner to postgres;

create collation pg_catalog."yue_HK" (
    locale = 'yue_HK'
    );

alter collation pg_catalog."yue_HK" owner to postgres;

create collation pg_catalog."yue_HK.utf8" (
    locale = 'yue_HK.utf8'
    );

alter collation pg_catalog."yue_HK.utf8" owner to postgres;

create collation pg_catalog."zh_CN" (
    locale = 'zh_CN'
    );

alter collation pg_catalog."zh_CN" owner to postgres;

create collation pg_catalog."zh_CN" (
    locale = 'zh_CN.utf8'
    );

alter collation pg_catalog."zh_CN" owner to postgres;

create collation pg_catalog."zh_CN.gb2312" (
    locale = 'zh_CN.gb2312'
    );

alter collation pg_catalog."zh_CN.gb2312" owner to postgres;

create collation pg_catalog."zh_CN.utf8" (
    locale = 'zh_CN.utf8'
    );

alter collation pg_catalog."zh_CN.utf8" owner to postgres;

create collation pg_catalog."zh_HK" (
    locale = 'zh_HK.utf8'
    );

alter collation pg_catalog."zh_HK" owner to postgres;

create collation pg_catalog."zh_HK.utf8" (
    locale = 'zh_HK.utf8'
    );

alter collation pg_catalog."zh_HK.utf8" owner to postgres;

create collation pg_catalog."zh_SG" (
    locale = 'zh_SG'
    );

alter collation pg_catalog."zh_SG" owner to postgres;

create collation pg_catalog."zh_SG" (
    locale = 'zh_SG.utf8'
    );

alter collation pg_catalog."zh_SG" owner to postgres;

create collation pg_catalog."zh_SG.gb2312" (
    locale = 'zh_SG.gb2312'
    );

alter collation pg_catalog."zh_SG.gb2312" owner to postgres;

create collation pg_catalog."zh_SG.utf8" (
    locale = 'zh_SG.utf8'
    );

alter collation pg_catalog."zh_SG.utf8" owner to postgres;

create collation pg_catalog."zh_TW" (
    locale = 'zh_TW.euctw'
    );

alter collation pg_catalog."zh_TW" owner to postgres;

create collation pg_catalog."zh_TW" (
    locale = 'zh_TW.utf8'
    );

alter collation pg_catalog."zh_TW" owner to postgres;

create collation pg_catalog."zh_TW.euctw" (
    locale = 'zh_TW.euctw'
    );

alter collation pg_catalog."zh_TW.euctw" owner to postgres;

create collation pg_catalog."zh_TW.utf8" (
    locale = 'zh_TW.utf8'
    );

alter collation pg_catalog."zh_TW.utf8" owner to postgres;

create collation pg_catalog."zu_ZA" (
    locale = 'zu_ZA.utf8'
    );

alter collation pg_catalog."zu_ZA" owner to postgres;

create collation pg_catalog."zu_ZA" (
    locale = 'zu_ZA'
    );

alter collation pg_catalog."zu_ZA" owner to postgres;

create collation pg_catalog."zu_ZA.iso88591" (
    locale = 'zu_ZA.iso88591'
    );

alter collation pg_catalog."zu_ZA.iso88591" owner to postgres;

create collation pg_catalog."zu_ZA.utf8" (
    locale = 'zu_ZA.utf8'
    );

alter collation pg_catalog."zu_ZA.utf8" owner to postgres;

create aggregate pg_catalog.max(anyarray) (
    sfunc = pg_catalog.array_larger,
    stype = anyarray,
    combinefunc = pg_catalog.array_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(anyarray) is 'maximum value of all anyarray input values';

alter aggregate pg_catalog.max(anyarray) owner to postgres;

create aggregate pg_catalog.min(anyarray) (
    sfunc = pg_catalog.array_smaller,
    stype = anyarray,
    combinefunc = pg_catalog.array_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(anyarray) is 'minimum value of all anyarray input values';

alter aggregate pg_catalog.min(anyarray) owner to postgres;

create aggregate pg_catalog.avg(bigint) (
    sfunc = pg_catalog.int8_avg_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_avg,
    combinefunc = pg_catalog.int8_avg_combine,
    serialfunc = pg_catalog.int8_avg_serialize,
    deserialfunc = pg_catalog.int8_avg_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int8_avg_accum,
    minvfunc = pg_catalog.int8_avg_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_avg
    );

comment on aggregate pg_catalog.avg(bigint) is 'the average (arithmetic mean) as numeric of all bigint values';

alter aggregate pg_catalog.avg(bigint) owner to postgres;

create aggregate pg_catalog.avg(integer) (
    sfunc = pg_catalog.int4_avg_accum,
    stype = bigint[],
    finalfunc = pg_catalog.int8_avg,
    combinefunc = pg_catalog.int4_avg_combine,
    initcond = '{0,0}',
    parallel = safe,
    msfunc = pg_catalog.int4_avg_accum,
    minvfunc = pg_catalog.int4_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = pg_catalog.int8_avg,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.avg(integer) is 'the average (arithmetic mean) as numeric of all integer values';

alter aggregate pg_catalog.avg(integer) owner to postgres;

create aggregate pg_catalog.avg(smallint) (
    sfunc = pg_catalog.int2_avg_accum,
    stype = bigint[],
    finalfunc = pg_catalog.int8_avg,
    combinefunc = pg_catalog.int4_avg_combine,
    initcond = '{0,0}',
    parallel = safe,
    msfunc = pg_catalog.int2_avg_accum,
    minvfunc = pg_catalog.int2_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = pg_catalog.int8_avg,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.avg(smallint) is 'the average (arithmetic mean) as numeric of all smallint values';

alter aggregate pg_catalog.avg(smallint) owner to postgres;

create aggregate pg_catalog.avg(numeric) (
    sfunc = pg_catalog.numeric_avg_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_avg,
    combinefunc = pg_catalog.numeric_avg_combine,
    serialfunc = pg_catalog.numeric_avg_serialize,
    deserialfunc = pg_catalog.numeric_avg_deserialize,
    parallel = safe,
    msfunc = pg_catalog.numeric_avg_accum,
    minvfunc = pg_catalog.numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_avg
    );

comment on aggregate pg_catalog.avg(numeric) is 'the average (arithmetic mean) as numeric of all numeric values';

alter aggregate pg_catalog.avg(numeric) owner to postgres;

create aggregate pg_catalog.avg(real) (
    sfunc = pg_catalog.float4_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_avg,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.avg(real) is 'the average (arithmetic mean) as float8 of all float4 values';

alter aggregate pg_catalog.avg(real) owner to postgres;

create aggregate pg_catalog.avg(double precision) (
    sfunc = pg_catalog.float8_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_avg,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.avg(double precision) is 'the average (arithmetic mean) as float8 of all float8 values';

alter aggregate pg_catalog.avg(double precision) owner to postgres;

create aggregate pg_catalog.avg(interval) (
    sfunc = pg_catalog.interval_accum,
    stype = interval[],
    finalfunc = pg_catalog.interval_avg,
    combinefunc = pg_catalog.interval_combine,
    initcond = '{0 second,0 second}',
    parallel = safe,
    msfunc = pg_catalog.interval_accum,
    minvfunc = pg_catalog.interval_accum_inv,
    mstype = interval[],
    mfinalfunc = pg_catalog.interval_avg,
    minitcond = '{0 second,0 second}'
    );

comment on aggregate pg_catalog.avg(interval) is 'the average (arithmetic mean) as interval of all interval values';

alter aggregate pg_catalog.avg(interval) owner to postgres;

create aggregate pg_catalog.sum(bigint) (
    sfunc = pg_catalog.int8_avg_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_sum,
    combinefunc = pg_catalog.int8_avg_combine,
    serialfunc = pg_catalog.int8_avg_serialize,
    deserialfunc = pg_catalog.int8_avg_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int8_avg_accum,
    minvfunc = pg_catalog.int8_avg_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_sum
    );

comment on aggregate pg_catalog.sum(bigint) is 'sum as numeric across all bigint input values';

alter aggregate pg_catalog.sum(bigint) owner to postgres;

create aggregate pg_catalog.sum(integer) (
    sfunc = pg_catalog.int4_sum,
    stype = bigint,
    combinefunc = pg_catalog.int8pl,
    parallel = safe,
    msfunc = pg_catalog.int4_avg_accum,
    minvfunc = pg_catalog.int4_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = pg_catalog.int2int4_sum,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.sum(integer) is 'sum as bigint across all integer input values';

alter aggregate pg_catalog.sum(integer) owner to postgres;

create aggregate pg_catalog.sum(smallint) (
    sfunc = pg_catalog.int2_sum,
    stype = bigint,
    combinefunc = pg_catalog.int8pl,
    parallel = safe,
    msfunc = pg_catalog.int2_avg_accum,
    minvfunc = pg_catalog.int2_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = pg_catalog.int2int4_sum,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.sum(smallint) is 'sum as bigint across all smallint input values';

alter aggregate pg_catalog.sum(smallint) owner to postgres;

create aggregate pg_catalog.sum(real) (
    sfunc = pg_catalog.float4pl,
    stype = real,
    combinefunc = pg_catalog.float4pl,
    parallel = safe
    );

comment on aggregate pg_catalog.sum(real) is 'sum as float4 across all float4 input values';

alter aggregate pg_catalog.sum(real) owner to postgres;

create aggregate pg_catalog.sum(double precision) (
    sfunc = pg_catalog.float8pl,
    stype = double precision,
    combinefunc = pg_catalog.float8pl,
    parallel = safe
    );

comment on aggregate pg_catalog.sum(double precision) is 'sum as float8 across all float8 input values';

alter aggregate pg_catalog.sum(double precision) owner to postgres;

create aggregate pg_catalog.sum(money) (
    sfunc = pg_catalog.cash_pl,
    stype = money,
    combinefunc = pg_catalog.cash_pl,
    parallel = safe,
    msfunc = pg_catalog.cash_pl,
    minvfunc = pg_catalog.cash_mi,
    mstype = money
    );

comment on aggregate pg_catalog.sum(money) is 'sum as money across all money input values';

alter aggregate pg_catalog.sum(money) owner to postgres;

create aggregate pg_catalog.sum(interval) (
    sfunc = pg_catalog.interval_pl,
    stype = interval,
    combinefunc = pg_catalog.interval_pl,
    parallel = safe,
    msfunc = pg_catalog.interval_pl,
    minvfunc = pg_catalog.interval_mi,
    mstype = interval
    );

comment on aggregate pg_catalog.sum(interval) is 'sum as interval across all interval input values';

alter aggregate pg_catalog.sum(interval) owner to postgres;

create aggregate pg_catalog.sum(numeric) (
    sfunc = pg_catalog.numeric_avg_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_sum,
    combinefunc = pg_catalog.numeric_avg_combine,
    serialfunc = pg_catalog.numeric_avg_serialize,
    deserialfunc = pg_catalog.numeric_avg_deserialize,
    parallel = safe,
    msfunc = pg_catalog.numeric_avg_accum,
    minvfunc = pg_catalog.numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_sum
    );

comment on aggregate pg_catalog.sum(numeric) is 'sum as numeric across all numeric input values';

alter aggregate pg_catalog.sum(numeric) owner to postgres;

create aggregate pg_catalog.max(bigint) (
    sfunc = pg_catalog.int8larger,
    stype = bigint,
    combinefunc = pg_catalog.int8larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(bigint) is 'maximum value of all bigint input values';

alter aggregate pg_catalog.max(bigint) owner to postgres;

create aggregate pg_catalog.max(integer) (
    sfunc = pg_catalog.int4larger,
    stype = integer,
    combinefunc = pg_catalog.int4larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(integer) is 'maximum value of all integer input values';

alter aggregate pg_catalog.max(integer) owner to postgres;

create aggregate pg_catalog.max(smallint) (
    sfunc = pg_catalog.int2larger,
    stype = smallint,
    combinefunc = pg_catalog.int2larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(smallint) is 'maximum value of all smallint input values';

alter aggregate pg_catalog.max(smallint) owner to postgres;

create aggregate pg_catalog.max(oid) (
    sfunc = pg_catalog.oidlarger,
    stype = oid,
    combinefunc = pg_catalog.oidlarger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(oid) is 'maximum value of all oid input values';

alter aggregate pg_catalog.max(oid) owner to postgres;

create aggregate pg_catalog.max(real) (
    sfunc = pg_catalog.float4larger,
    stype = real,
    combinefunc = pg_catalog.float4larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(real) is 'maximum value of all float4 input values';

alter aggregate pg_catalog.max(real) owner to postgres;

create aggregate pg_catalog.max(double precision) (
    sfunc = pg_catalog.float8larger,
    stype = double precision,
    combinefunc = pg_catalog.float8larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(double precision) is 'maximum value of all float8 input values';

alter aggregate pg_catalog.max(double precision) owner to postgres;

create aggregate pg_catalog.max(abstime) (
    sfunc = pg_catalog.int4larger,
    stype = abstime,
    combinefunc = pg_catalog.int4larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(abstime) is 'maximum value of all abstime input values';

alter aggregate pg_catalog.max(abstime) owner to postgres;

create aggregate pg_catalog.max(date) (
    sfunc = pg_catalog.date_larger,
    stype = date,
    combinefunc = pg_catalog.date_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(date) is 'maximum value of all date input values';

alter aggregate pg_catalog.max(date) owner to postgres;

create aggregate pg_catalog.max(time) (
    sfunc = pg_catalog.time_larger,
    stype = time,
    combinefunc = pg_catalog.time_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(time) is 'maximum value of all time input values';

alter aggregate pg_catalog.max(time) owner to postgres;

create aggregate pg_catalog.max(time with time zone) (
    sfunc = pg_catalog.timetz_larger,
    stype = time with time zone,
    combinefunc = pg_catalog.timetz_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(time with time zone) is 'maximum value of all time with time zone input values';

alter aggregate pg_catalog.max(time with time zone) owner to postgres;

create aggregate pg_catalog.max(money) (
    sfunc = pg_catalog.cashlarger,
    stype = money,
    combinefunc = pg_catalog.cashlarger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(money) is 'maximum value of all money input values';

alter aggregate pg_catalog.max(money) owner to postgres;

create aggregate pg_catalog.max(timestamp) (
    sfunc = pg_catalog.timestamp_larger,
    stype = timestamp,
    combinefunc = pg_catalog.timestamp_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(timestamp) is 'maximum value of all timestamp input values';

alter aggregate pg_catalog.max(timestamp) owner to postgres;

create aggregate pg_catalog.max(timestamp with time zone) (
    sfunc = pg_catalog.timestamptz_larger,
    stype = timestamp with time zone,
    combinefunc = pg_catalog.timestamptz_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(timestamp with time zone) is 'maximum value of all timestamp with time zone input values';

alter aggregate pg_catalog.max(timestamp with time zone) owner to postgres;

create aggregate pg_catalog.max(interval) (
    sfunc = pg_catalog.interval_larger,
    stype = interval,
    combinefunc = pg_catalog.interval_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(interval) is 'maximum value of all interval input values';

alter aggregate pg_catalog.max(interval) owner to postgres;

create aggregate pg_catalog.max(text) (
    sfunc = pg_catalog.text_larger,
    stype = text,
    combinefunc = pg_catalog.text_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(text) is 'maximum value of all text input values';

alter aggregate pg_catalog.max(text) owner to postgres;

create aggregate pg_catalog.max(numeric) (
    sfunc = pg_catalog.numeric_larger,
    stype = numeric,
    combinefunc = pg_catalog.numeric_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(numeric) is 'maximum value of all numeric input values';

alter aggregate pg_catalog.max(numeric) owner to postgres;

create aggregate pg_catalog.min(bigint) (
    sfunc = pg_catalog.int8smaller,
    stype = bigint,
    combinefunc = pg_catalog.int8smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(bigint) is 'minimum value of all bigint input values';

alter aggregate pg_catalog.min(bigint) owner to postgres;

create aggregate pg_catalog.min(integer) (
    sfunc = pg_catalog.int4smaller,
    stype = integer,
    combinefunc = pg_catalog.int4smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(integer) is 'minimum value of all integer input values';

alter aggregate pg_catalog.min(integer) owner to postgres;

create aggregate pg_catalog.min(smallint) (
    sfunc = pg_catalog.int2smaller,
    stype = smallint,
    combinefunc = pg_catalog.int2smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(smallint) is 'minimum value of all smallint input values';

alter aggregate pg_catalog.min(smallint) owner to postgres;

create aggregate pg_catalog.min(oid) (
    sfunc = pg_catalog.oidsmaller,
    stype = oid,
    combinefunc = pg_catalog.oidsmaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(oid) is 'minimum value of all oid input values';

alter aggregate pg_catalog.min(oid) owner to postgres;

create aggregate pg_catalog.min(real) (
    sfunc = pg_catalog.float4smaller,
    stype = real,
    combinefunc = pg_catalog.float4smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(real) is 'minimum value of all float4 input values';

alter aggregate pg_catalog.min(real) owner to postgres;

create aggregate pg_catalog.min(double precision) (
    sfunc = pg_catalog.float8smaller,
    stype = double precision,
    combinefunc = pg_catalog.float8smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(double precision) is 'minimum value of all float8 input values';

alter aggregate pg_catalog.min(double precision) owner to postgres;

create aggregate pg_catalog.min(abstime) (
    sfunc = pg_catalog.int4smaller,
    stype = abstime,
    combinefunc = pg_catalog.int4smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(abstime) is 'minimum value of all abstime input values';

alter aggregate pg_catalog.min(abstime) owner to postgres;

create aggregate pg_catalog.min(date) (
    sfunc = pg_catalog.date_smaller,
    stype = date,
    combinefunc = pg_catalog.date_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(date) is 'minimum value of all date input values';

alter aggregate pg_catalog.min(date) owner to postgres;

create aggregate pg_catalog.min(time) (
    sfunc = pg_catalog.time_smaller,
    stype = time,
    combinefunc = pg_catalog.time_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(time) is 'minimum value of all time input values';

alter aggregate pg_catalog.min(time) owner to postgres;

create aggregate pg_catalog.min(time with time zone) (
    sfunc = pg_catalog.timetz_smaller,
    stype = time with time zone,
    combinefunc = pg_catalog.timetz_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(time with time zone) is 'minimum value of all time with time zone input values';

alter aggregate pg_catalog.min(time with time zone) owner to postgres;

create aggregate pg_catalog.min(money) (
    sfunc = pg_catalog.cashsmaller,
    stype = money,
    combinefunc = pg_catalog.cashsmaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(money) is 'minimum value of all money input values';

alter aggregate pg_catalog.min(money) owner to postgres;

create aggregate pg_catalog.min(timestamp) (
    sfunc = pg_catalog.timestamp_smaller,
    stype = timestamp,
    combinefunc = pg_catalog.timestamp_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(timestamp) is 'minimum value of all timestamp input values';

alter aggregate pg_catalog.min(timestamp) owner to postgres;

create aggregate pg_catalog.min(timestamp with time zone) (
    sfunc = pg_catalog.timestamptz_smaller,
    stype = timestamp with time zone,
    combinefunc = pg_catalog.timestamptz_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(timestamp with time zone) is 'minimum value of all timestamp with time zone input values';

alter aggregate pg_catalog.min(timestamp with time zone) owner to postgres;

create aggregate pg_catalog.min(interval) (
    sfunc = pg_catalog.interval_smaller,
    stype = interval,
    combinefunc = pg_catalog.interval_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(interval) is 'minimum value of all interval input values';

alter aggregate pg_catalog.min(interval) owner to postgres;

create aggregate pg_catalog.min(text) (
    sfunc = pg_catalog.text_smaller,
    stype = text,
    combinefunc = pg_catalog.text_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(text) is 'minimum value of all text values';

alter aggregate pg_catalog.min(text) owner to postgres;

create aggregate pg_catalog.min(numeric) (
    sfunc = pg_catalog.numeric_smaller,
    stype = numeric,
    combinefunc = pg_catalog.numeric_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(numeric) is 'minimum value of all numeric input values';

alter aggregate pg_catalog.min(numeric) owner to postgres;

create aggregate pg_catalog.count("any") (
    sfunc = pg_catalog.int8inc_any,
    stype = bigint,
    combinefunc = pg_catalog.int8pl,
    initcond = '0',
    parallel = safe,
    msfunc = pg_catalog.int8inc_any,
    minvfunc = pg_catalog.int8dec_any,
    mstype = bigint,
    minitcond = '0'
    );

comment on aggregate pg_catalog.count("any") is 'number of input rows for which the input expression is not null';

alter aggregate pg_catalog.count("any") owner to postgres;

create aggregate pg_catalog.variance(bigint) (
    sfunc = pg_catalog.int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_var_samp,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int8_accum,
    minvfunc = pg_catalog.int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_var_samp
    );

comment on aggregate pg_catalog.variance(bigint) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(bigint) owner to postgres;

create aggregate pg_catalog.variance(integer) (
    sfunc = pg_catalog.int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_var_samp,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int4_accum,
    minvfunc = pg_catalog.int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_var_samp
    );

comment on aggregate pg_catalog.variance(integer) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(integer) owner to postgres;

create aggregate pg_catalog.variance(smallint) (
    sfunc = pg_catalog.int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_var_samp,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int2_accum,
    minvfunc = pg_catalog.int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_var_samp
    );

comment on aggregate pg_catalog.variance(smallint) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(smallint) owner to postgres;

create aggregate pg_catalog.variance(real) (
    sfunc = pg_catalog.float4_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_var_samp,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.variance(real) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(real) owner to postgres;

create aggregate pg_catalog.variance(double precision) (
    sfunc = pg_catalog.float8_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_var_samp,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.variance(double precision) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(double precision) owner to postgres;

create aggregate pg_catalog.variance(numeric) (
    sfunc = pg_catalog.numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_var_samp,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.numeric_accum,
    minvfunc = pg_catalog.numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_var_samp
    );

comment on aggregate pg_catalog.variance(numeric) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(numeric) owner to postgres;

create aggregate pg_catalog.stddev(bigint) (
    sfunc = pg_catalog.int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_stddev_samp,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int8_accum,
    minvfunc = pg_catalog.int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev(bigint) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(bigint) owner to postgres;

create aggregate pg_catalog.stddev(integer) (
    sfunc = pg_catalog.int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_stddev_samp,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int4_accum,
    minvfunc = pg_catalog.int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev(integer) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(integer) owner to postgres;

create aggregate pg_catalog.stddev(smallint) (
    sfunc = pg_catalog.int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_stddev_samp,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int2_accum,
    minvfunc = pg_catalog.int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev(smallint) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(smallint) owner to postgres;

create aggregate pg_catalog.stddev(real) (
    sfunc = pg_catalog.float4_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_stddev_samp,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev(real) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(real) owner to postgres;

create aggregate pg_catalog.stddev(double precision) (
    sfunc = pg_catalog.float8_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_stddev_samp,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev(double precision) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(double precision) owner to postgres;

create aggregate pg_catalog.stddev(numeric) (
    sfunc = pg_catalog.numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_stddev_samp,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.numeric_accum,
    minvfunc = pg_catalog.numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev(numeric) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(numeric) owner to postgres;

create aggregate pg_catalog.bit_and(smallint) (
    sfunc = pg_catalog.int2and,
    stype = smallint,
    combinefunc = pg_catalog.int2and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(smallint) is 'bitwise-and smallint aggregate';

alter aggregate pg_catalog.bit_and(smallint) owner to postgres;

create aggregate pg_catalog.bit_or(smallint) (
    sfunc = pg_catalog.int2or,
    stype = smallint,
    combinefunc = pg_catalog.int2or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(smallint) is 'bitwise-or smallint aggregate';

alter aggregate pg_catalog.bit_or(smallint) owner to postgres;

create aggregate pg_catalog.bit_and(integer) (
    sfunc = pg_catalog.int4and,
    stype = integer,
    combinefunc = pg_catalog.int4and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(integer) is 'bitwise-and integer aggregate';

alter aggregate pg_catalog.bit_and(integer) owner to postgres;

create aggregate pg_catalog.bit_or(integer) (
    sfunc = pg_catalog.int4or,
    stype = integer,
    combinefunc = pg_catalog.int4or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(integer) is 'bitwise-or integer aggregate';

alter aggregate pg_catalog.bit_or(integer) owner to postgres;

create aggregate pg_catalog.bit_and(bigint) (
    sfunc = pg_catalog.int8and,
    stype = bigint,
    combinefunc = pg_catalog.int8and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(bigint) is 'bitwise-and bigint aggregate';

alter aggregate pg_catalog.bit_and(bigint) owner to postgres;

create aggregate pg_catalog.bit_or(bigint) (
    sfunc = pg_catalog.int8or,
    stype = bigint,
    combinefunc = pg_catalog.int8or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(bigint) is 'bitwise-or bigint aggregate';

alter aggregate pg_catalog.bit_or(bigint) owner to postgres;

create aggregate pg_catalog.bit_and(bit) (
    sfunc = pg_catalog.bitand,
    stype = bit,
    combinefunc = pg_catalog.bitand,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(bit) is 'bitwise-and bit aggregate';

alter aggregate pg_catalog.bit_and(bit) owner to postgres;

create aggregate pg_catalog.bit_or(bit) (
    sfunc = pg_catalog.bitor,
    stype = bit,
    combinefunc = pg_catalog.bitor,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(bit) is 'bitwise-or bit aggregate';

alter aggregate pg_catalog.bit_or(bit) owner to postgres;

create aggregate pg_catalog.max(char) (
    sfunc = pg_catalog.bpchar_larger,
    stype = char,
    combinefunc = pg_catalog.bpchar_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(char) is 'maximum value of all bpchar input values';

alter aggregate pg_catalog.max(char) owner to postgres;

create aggregate pg_catalog.min(char) (
    sfunc = pg_catalog.bpchar_smaller,
    stype = char,
    combinefunc = pg_catalog.bpchar_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(char) is 'minimum value of all bpchar input values';

alter aggregate pg_catalog.min(char) owner to postgres;

create aggregate pg_catalog.array_agg(anynonarray) (
    sfunc = pg_catalog.array_agg_transfn,
    stype = internal,
    finalfunc = pg_catalog.array_agg_finalfn,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.array_agg(anynonarray) is 'concatenate aggregate input into an array';

alter aggregate pg_catalog.array_agg(anynonarray) owner to postgres;

create aggregate pg_catalog.bool_and(boolean) (
    sfunc = pg_catalog.booland_statefunc,
    stype = boolean,
    combinefunc = pg_catalog.booland_statefunc,
    parallel = safe,
    msfunc = pg_catalog.bool_accum,
    minvfunc = pg_catalog.bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = pg_catalog.bool_alltrue,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.bool_and(boolean) is 'boolean-and aggregate';

alter aggregate pg_catalog.bool_and(boolean) owner to postgres;

create aggregate pg_catalog.bool_or(boolean) (
    sfunc = pg_catalog.boolor_statefunc,
    stype = boolean,
    combinefunc = pg_catalog.boolor_statefunc,
    parallel = safe,
    msfunc = pg_catalog.bool_accum,
    minvfunc = pg_catalog.bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = pg_catalog.bool_anytrue,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.bool_or(boolean) is 'boolean-or aggregate';

alter aggregate pg_catalog.bool_or(boolean) owner to postgres;

create aggregate pg_catalog.every(boolean) (
    sfunc = pg_catalog.booland_statefunc,
    stype = boolean,
    combinefunc = pg_catalog.booland_statefunc,
    parallel = safe,
    msfunc = pg_catalog.bool_accum,
    minvfunc = pg_catalog.bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = pg_catalog.bool_alltrue,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.every(boolean) is 'boolean-and aggregate';

alter aggregate pg_catalog.every(boolean) owner to postgres;

create aggregate pg_catalog.var_samp(bigint) (
    sfunc = pg_catalog.int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_var_samp,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int8_accum,
    minvfunc = pg_catalog.int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_var_samp
    );

comment on aggregate pg_catalog.var_samp(bigint) is 'sample variance of bigint input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(bigint) owner to postgres;

create aggregate pg_catalog.var_samp(integer) (
    sfunc = pg_catalog.int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_var_samp,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int4_accum,
    minvfunc = pg_catalog.int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_var_samp
    );

comment on aggregate pg_catalog.var_samp(integer) is 'sample variance of integer input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(integer) owner to postgres;

create aggregate pg_catalog.var_samp(smallint) (
    sfunc = pg_catalog.int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_var_samp,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int2_accum,
    minvfunc = pg_catalog.int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_var_samp
    );

comment on aggregate pg_catalog.var_samp(smallint) is 'sample variance of smallint input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(smallint) owner to postgres;

create aggregate pg_catalog.var_samp(real) (
    sfunc = pg_catalog.float4_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_var_samp,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_samp(real) is 'sample variance of float4 input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(real) owner to postgres;

create aggregate pg_catalog.var_samp(double precision) (
    sfunc = pg_catalog.float8_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_var_samp,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_samp(double precision) is 'sample variance of float8 input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(double precision) owner to postgres;

create aggregate pg_catalog.var_samp(numeric) (
    sfunc = pg_catalog.numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_var_samp,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.numeric_accum,
    minvfunc = pg_catalog.numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_var_samp
    );

comment on aggregate pg_catalog.var_samp(numeric) is 'sample variance of numeric input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(numeric) owner to postgres;

create aggregate pg_catalog.stddev_samp(bigint) (
    sfunc = pg_catalog.int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_stddev_samp,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int8_accum,
    minvfunc = pg_catalog.int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(bigint) is 'sample standard deviation of bigint input values';

alter aggregate pg_catalog.stddev_samp(bigint) owner to postgres;

create aggregate pg_catalog.stddev_samp(integer) (
    sfunc = pg_catalog.int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_stddev_samp,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int4_accum,
    minvfunc = pg_catalog.int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(integer) is 'sample standard deviation of integer input values';

alter aggregate pg_catalog.stddev_samp(integer) owner to postgres;

create aggregate pg_catalog.stddev_samp(smallint) (
    sfunc = pg_catalog.int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_stddev_samp,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int2_accum,
    minvfunc = pg_catalog.int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(smallint) is 'sample standard deviation of smallint input values';

alter aggregate pg_catalog.stddev_samp(smallint) owner to postgres;

create aggregate pg_catalog.stddev_samp(real) (
    sfunc = pg_catalog.float4_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_stddev_samp,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_samp(real) is 'sample standard deviation of float4 input values';

alter aggregate pg_catalog.stddev_samp(real) owner to postgres;

create aggregate pg_catalog.stddev_samp(double precision) (
    sfunc = pg_catalog.float8_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_stddev_samp,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_samp(double precision) is 'sample standard deviation of float8 input values';

alter aggregate pg_catalog.stddev_samp(double precision) owner to postgres;

create aggregate pg_catalog.stddev_samp(numeric) (
    sfunc = pg_catalog.numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_stddev_samp,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.numeric_accum,
    minvfunc = pg_catalog.numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(numeric) is 'sample standard deviation of numeric input values';

alter aggregate pg_catalog.stddev_samp(numeric) owner to postgres;

create aggregate pg_catalog.var_pop(bigint) (
    sfunc = pg_catalog.int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_var_pop,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int8_accum,
    minvfunc = pg_catalog.int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_var_pop
    );

comment on aggregate pg_catalog.var_pop(bigint) is 'population variance of bigint input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(bigint) owner to postgres;

create aggregate pg_catalog.var_pop(integer) (
    sfunc = pg_catalog.int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_var_pop,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int4_accum,
    minvfunc = pg_catalog.int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_var_pop
    );

comment on aggregate pg_catalog.var_pop(integer) is 'population variance of integer input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(integer) owner to postgres;

create aggregate pg_catalog.var_pop(smallint) (
    sfunc = pg_catalog.int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_var_pop,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int2_accum,
    minvfunc = pg_catalog.int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_var_pop
    );

comment on aggregate pg_catalog.var_pop(smallint) is 'population variance of smallint input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(smallint) owner to postgres;

create aggregate pg_catalog.var_pop(real) (
    sfunc = pg_catalog.float4_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_var_pop,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_pop(real) is 'population variance of float4 input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(real) owner to postgres;

create aggregate pg_catalog.var_pop(double precision) (
    sfunc = pg_catalog.float8_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_var_pop,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_pop(double precision) is 'population variance of float8 input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(double precision) owner to postgres;

create aggregate pg_catalog.var_pop(numeric) (
    sfunc = pg_catalog.numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_var_pop,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.numeric_accum,
    minvfunc = pg_catalog.numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_var_pop
    );

comment on aggregate pg_catalog.var_pop(numeric) is 'population variance of numeric input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(numeric) owner to postgres;

create aggregate pg_catalog.stddev_pop(bigint) (
    sfunc = pg_catalog.int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_stddev_pop,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int8_accum,
    minvfunc = pg_catalog.int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(bigint) is 'population standard deviation of bigint input values';

alter aggregate pg_catalog.stddev_pop(bigint) owner to postgres;

create aggregate pg_catalog.stddev_pop(integer) (
    sfunc = pg_catalog.int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_stddev_pop,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int4_accum,
    minvfunc = pg_catalog.int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(integer) is 'population standard deviation of integer input values';

alter aggregate pg_catalog.stddev_pop(integer) owner to postgres;

create aggregate pg_catalog.stddev_pop(smallint) (
    sfunc = pg_catalog.int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = pg_catalog.numeric_poly_stddev_pop,
    combinefunc = pg_catalog.numeric_poly_combine,
    serialfunc = pg_catalog.numeric_poly_serialize,
    deserialfunc = pg_catalog.numeric_poly_deserialize,
    parallel = safe,
    msfunc = pg_catalog.int2_accum,
    minvfunc = pg_catalog.int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = pg_catalog.numeric_poly_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(smallint) is 'population standard deviation of smallint input values';

alter aggregate pg_catalog.stddev_pop(smallint) owner to postgres;

create aggregate pg_catalog.stddev_pop(real) (
    sfunc = pg_catalog.float4_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_stddev_pop,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_pop(real) is 'population standard deviation of float4 input values';

alter aggregate pg_catalog.stddev_pop(real) owner to postgres;

create aggregate pg_catalog.stddev_pop(double precision) (
    sfunc = pg_catalog.float8_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_stddev_pop,
    combinefunc = pg_catalog.float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_pop(double precision) is 'population standard deviation of float8 input values';

alter aggregate pg_catalog.stddev_pop(double precision) owner to postgres;

create aggregate pg_catalog.stddev_pop(numeric) (
    sfunc = pg_catalog.numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = pg_catalog.numeric_stddev_pop,
    combinefunc = pg_catalog.numeric_combine,
    serialfunc = pg_catalog.numeric_serialize,
    deserialfunc = pg_catalog.numeric_deserialize,
    parallel = safe,
    msfunc = pg_catalog.numeric_accum,
    minvfunc = pg_catalog.numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = pg_catalog.numeric_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(numeric) is 'population standard deviation of numeric input values';

alter aggregate pg_catalog.stddev_pop(numeric) owner to postgres;

create aggregate pg_catalog.max(tid) (
    sfunc = pg_catalog.tidlarger,
    stype = tid,
    combinefunc = pg_catalog.tidlarger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(tid) is 'maximum value of all tid input values';

alter aggregate pg_catalog.max(tid) owner to postgres;

create aggregate pg_catalog.min(tid) (
    sfunc = pg_catalog.tidsmaller,
    stype = tid,
    combinefunc = pg_catalog.tidsmaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(tid) is 'minimum value of all tid input values';

alter aggregate pg_catalog.min(tid) owner to postgres;

create aggregate pg_catalog.count() (
    sfunc = pg_catalog.int8inc,
    stype = bigint,
    combinefunc = pg_catalog.int8pl,
    initcond = '0',
    parallel = safe,
    msfunc = pg_catalog.int8inc,
    minvfunc = pg_catalog.int8dec,
    mstype = bigint,
    minitcond = '0'
    );

comment on aggregate pg_catalog.count() is 'number of input rows';

alter aggregate pg_catalog.count() owner to postgres;

create aggregate pg_catalog.regr_count(double precision, double precision) (
    sfunc = pg_catalog.int8inc_float8_float8,
    stype = bigint,
    combinefunc = pg_catalog.int8pl,
    initcond = '0',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_count(double precision, double precision) is 'number of input rows in which both expressions are not null';

alter aggregate pg_catalog.regr_count(double precision, double precision) owner to postgres;

create aggregate pg_catalog.regr_sxx(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_regr_sxx,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_sxx(double precision, double precision) is 'sum of squares of the independent variable (sum(X^2) - sum(X)^2/N)';

alter aggregate pg_catalog.regr_sxx(double precision, double precision) owner to postgres;

create aggregate pg_catalog.regr_syy(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_regr_syy,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_syy(double precision, double precision) is 'sum of squares of the dependent variable (sum(Y^2) - sum(Y)^2/N)';

alter aggregate pg_catalog.regr_syy(double precision, double precision) owner to postgres;

create aggregate pg_catalog.regr_sxy(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_regr_sxy,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_sxy(double precision, double precision) is 'sum of products of independent times dependent variable (sum(X*Y) - sum(X) * sum(Y)/N)';

alter aggregate pg_catalog.regr_sxy(double precision, double precision) owner to postgres;

create aggregate pg_catalog.regr_avgx(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_regr_avgx,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_avgx(double precision, double precision) is 'average of the independent variable (sum(X)/N)';

alter aggregate pg_catalog.regr_avgx(double precision, double precision) owner to postgres;

create aggregate pg_catalog.regr_avgy(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_regr_avgy,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_avgy(double precision, double precision) is 'average of the dependent variable (sum(Y)/N)';

alter aggregate pg_catalog.regr_avgy(double precision, double precision) owner to postgres;

create aggregate pg_catalog.regr_r2(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_regr_r2,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_r2(double precision, double precision) is 'square of the correlation coefficient';

alter aggregate pg_catalog.regr_r2(double precision, double precision) owner to postgres;

create aggregate pg_catalog.regr_slope(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_regr_slope,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_slope(double precision, double precision) is 'slope of the least-squares-fit linear equation determined by the (X, Y) pairs';

alter aggregate pg_catalog.regr_slope(double precision, double precision) owner to postgres;

create aggregate pg_catalog.regr_intercept(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_regr_intercept,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_intercept(double precision, double precision) is 'y-intercept of the least-squares-fit linear equation determined by the (X, Y) pairs';

alter aggregate pg_catalog.regr_intercept(double precision, double precision) owner to postgres;

create aggregate pg_catalog.covar_pop(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_covar_pop,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.covar_pop(double precision, double precision) is 'population covariance';

alter aggregate pg_catalog.covar_pop(double precision, double precision) owner to postgres;

create aggregate pg_catalog.covar_samp(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_covar_samp,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.covar_samp(double precision, double precision) is 'sample covariance';

alter aggregate pg_catalog.covar_samp(double precision, double precision) owner to postgres;

create aggregate pg_catalog.corr(double precision, double precision) (
    sfunc = pg_catalog.float8_regr_accum,
    stype = double precision[],
    finalfunc = pg_catalog.float8_corr,
    combinefunc = pg_catalog.float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.corr(double precision, double precision) is 'correlation coefficient';

alter aggregate pg_catalog.corr(double precision, double precision) owner to postgres;

create aggregate pg_catalog.xmlagg(xml) (
    sfunc = pg_catalog.xmlconcat2,
    stype = xml,
    parallel = safe
    );

comment on aggregate pg_catalog.xmlagg(xml) is 'concatenate XML values';

alter aggregate pg_catalog.xmlagg(xml) owner to postgres;

create aggregate pg_catalog.json_agg(anyelement) (
    sfunc = pg_catalog.json_agg_transfn,
    stype = internal,
    finalfunc = pg_catalog.json_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.json_agg(anyelement) is 'aggregate input into json';

alter aggregate pg_catalog.json_agg(anyelement) owner to postgres;

create aggregate pg_catalog.json_object_agg("any", "any") (
    sfunc = pg_catalog.json_object_agg_transfn,
    stype = internal,
    finalfunc = pg_catalog.json_object_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.json_object_agg("any", "any") is 'aggregate input into a json object';

alter aggregate pg_catalog.json_object_agg("any", "any") owner to postgres;

create aggregate pg_catalog.jsonb_agg(anyelement) (
    sfunc = pg_catalog.jsonb_agg_transfn,
    stype = internal,
    finalfunc = pg_catalog.jsonb_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.jsonb_agg(anyelement) is 'aggregate input into jsonb';

alter aggregate pg_catalog.jsonb_agg(anyelement) owner to postgres;

create aggregate pg_catalog.jsonb_object_agg("any", "any") (
    sfunc = pg_catalog.jsonb_object_agg_transfn,
    stype = internal,
    finalfunc = pg_catalog.jsonb_object_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.jsonb_object_agg("any", "any") is 'aggregate inputs into jsonb object';

alter aggregate pg_catalog.jsonb_object_agg("any", "any") owner to postgres;

create aggregate pg_catalog.max(anyenum) (
    sfunc = pg_catalog.enum_larger,
    stype = anyenum,
    combinefunc = pg_catalog.enum_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(anyenum) is 'maximum value of all enum input values';

alter aggregate pg_catalog.max(anyenum) owner to postgres;

create aggregate pg_catalog.min(anyenum) (
    sfunc = pg_catalog.enum_smaller,
    stype = anyenum,
    combinefunc = pg_catalog.enum_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(anyenum) is 'minimum value of all enum input values';

alter aggregate pg_catalog.min(anyenum) owner to postgres;

create aggregate pg_catalog.string_agg(text, text) (
    sfunc = pg_catalog.string_agg_transfn,
    stype = internal,
    finalfunc = pg_catalog.string_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.string_agg(text, text) is 'concatenate aggregate input into a string';

alter aggregate pg_catalog.string_agg(text, text) owner to postgres;

create aggregate pg_catalog.string_agg(bytea, bytea) (
    sfunc = pg_catalog.bytea_string_agg_transfn,
    stype = internal,
    finalfunc = pg_catalog.bytea_string_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.string_agg(bytea, bytea) is 'concatenate aggregate input into a bytea';

alter aggregate pg_catalog.string_agg(bytea, bytea) owner to postgres;

create aggregate pg_catalog.max(inet) (
    sfunc = pg_catalog.network_larger,
    stype = inet,
    combinefunc = pg_catalog.network_larger,
    parallel = safe,
    sortop = operator (pg_catalog.>)
    );

comment on aggregate pg_catalog.max(inet) is 'maximum value of all inet input values';

alter aggregate pg_catalog.max(inet) owner to postgres;

create aggregate pg_catalog.min(inet) (
    sfunc = pg_catalog.network_smaller,
    stype = inet,
    combinefunc = pg_catalog.network_smaller,
    parallel = safe,
    sortop = operator (pg_catalog.<)
    );

comment on aggregate pg_catalog.min(inet) is 'minimum value of all inet input values';

alter aggregate pg_catalog.min(inet) owner to postgres;

create aggregate pg_catalog.percentile_disc(double precision order by anyelement) (
    sfunc = pg_catalog.ordered_set_transition,
    stype = internal,
    finalfunc = pg_catalog.percentile_disc_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_disc(double precision, anyelement) is 'discrete percentile';

alter aggregate pg_catalog.percentile_disc(double precision order by anyelement) owner to postgres;

create aggregate pg_catalog.percentile_cont(double precision order by double precision) (
    sfunc = pg_catalog.ordered_set_transition,
    stype = internal,
    finalfunc = pg_catalog.percentile_cont_float8_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont(double precision, double precision) is 'continuous distribution percentile';

alter aggregate pg_catalog.percentile_cont(double precision order by double precision) owner to postgres;

create aggregate pg_catalog.percentile_cont(double precision order by interval) (
    sfunc = pg_catalog.ordered_set_transition,
    stype = internal,
    finalfunc = pg_catalog.percentile_cont_interval_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont(double precision, interval) is 'continuous distribution percentile';

alter aggregate pg_catalog.percentile_cont(double precision order by interval) owner to postgres;

create aggregate pg_catalog.percentile_disc(double precision[] order by anyelement) (
    sfunc = pg_catalog.ordered_set_transition,
    stype = internal,
    finalfunc = pg_catalog.percentile_disc_multi_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_disc(double precision[], anyelement) is 'multiple discrete percentiles';

alter aggregate pg_catalog.percentile_disc(double precision[] order by anyelement) owner to postgres;

create aggregate pg_catalog.percentile_cont(double precision[] order by double precision) (
    sfunc = pg_catalog.ordered_set_transition,
    stype = internal,
    finalfunc = pg_catalog.percentile_cont_float8_multi_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont(double precision[], double precision) is 'multiple continuous percentiles';

alter aggregate pg_catalog.percentile_cont(double precision[] order by double precision) owner to postgres;

create aggregate pg_catalog.percentile_cont(double precision[] order by interval) (
    sfunc = pg_catalog.ordered_set_transition,
    stype = internal,
    finalfunc = pg_catalog.percentile_cont_interval_multi_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont(double precision[], interval) is 'multiple continuous percentiles';

alter aggregate pg_catalog.percentile_cont(double precision[] order by interval) owner to postgres;

create aggregate pg_catalog.mode( order by anyelement) (
    sfunc = pg_catalog.ordered_set_transition,
    stype = internal,
    finalfunc = pg_catalog.mode_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.mode(anyelement) is 'most common value';

alter aggregate pg_catalog.mode( order by anyelement) owner to postgres;

create aggregate pg_catalog.rank("any") (
    sfunc = pg_catalog.ordered_set_transition_multi,
    stype = internal,
    finalfunc = pg_catalog.rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.rank("any") is 'rank of hypothetical row';

alter aggregate pg_catalog.rank("any") owner to postgres;

create aggregate pg_catalog.percent_rank("any") (
    sfunc = pg_catalog.ordered_set_transition_multi,
    stype = internal,
    finalfunc = pg_catalog.percent_rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.percent_rank("any") is 'fractional rank of hypothetical row';

alter aggregate pg_catalog.percent_rank("any") owner to postgres;

create aggregate pg_catalog.cume_dist("any") (
    sfunc = pg_catalog.ordered_set_transition_multi,
    stype = internal,
    finalfunc = pg_catalog.cume_dist_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.cume_dist("any") is 'cumulative distribution of hypothetical row';

alter aggregate pg_catalog.cume_dist("any") owner to postgres;

create aggregate pg_catalog.dense_rank("any") (
    sfunc = pg_catalog.ordered_set_transition_multi,
    stype = internal,
    finalfunc = pg_catalog.dense_rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.dense_rank("any") is 'rank of hypothetical row without gaps';

alter aggregate pg_catalog.dense_rank("any") owner to postgres;

create aggregate pg_catalog.array_agg(anyarray) (
    sfunc = pg_catalog.array_agg_array_transfn,
    stype = internal,
    finalfunc = pg_catalog.array_agg_array_finalfn,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.array_agg(anyarray) is 'concatenate aggregate input into an array';

alter aggregate pg_catalog.array_agg(anyarray) owner to postgres;

create aggregate first(anyelement, "any") (
    sfunc = _timescaledb_internal.first_sfunc,
    stype = internal,
    finalfunc = _timescaledb_internal.bookend_finalfunc,
    finalfunc_extra,
    combinefunc = _timescaledb_internal.first_combinefunc,
    serialfunc = _timescaledb_internal.bookend_serializefunc,
    deserialfunc = _timescaledb_internal.bookend_deserializefunc,
    parallel = safe
    );

alter aggregate first(anyelement, "any") owner to postgres;

create aggregate last(anyelement, "any") (
    sfunc = _timescaledb_internal.last_sfunc,
    stype = internal,
    finalfunc = _timescaledb_internal.bookend_finalfunc,
    finalfunc_extra,
    combinefunc = _timescaledb_internal.last_combinefunc,
    serialfunc = _timescaledb_internal.bookend_serializefunc,
    deserialfunc = _timescaledb_internal.bookend_deserializefunc,
    parallel = safe
    );

alter aggregate last(anyelement, "any") owner to postgres;

create aggregate histogram(double precision, double precision, double precision, integer) (
    sfunc = _timescaledb_internal.hist_sfunc,
    stype = internal,
    finalfunc = _timescaledb_internal.hist_finalfunc,
    finalfunc_extra,
    combinefunc = _timescaledb_internal.hist_combinefunc,
    serialfunc = _timescaledb_internal.hist_serializefunc,
    deserialfunc = _timescaledb_internal.hist_deserializefunc,
    parallel = safe
    );

alter aggregate histogram(double precision, double precision, double precision, integer) owner to postgres;

create aggregate _timescaledb_internal.finalize_agg(agg_name text, inner_agg_collation_schema name, inner_agg_collation_name name, inner_agg_input_types name[], inner_agg_serialized_state bytea, return_type_dummy_val anyelement) (
    sfunc = _timescaledb_internal.finalize_agg_sfunc,
    stype = internal,
    finalfunc = _timescaledb_internal.finalize_agg_ffunc,
    finalfunc_extra
    );

alter aggregate _timescaledb_internal.finalize_agg(agg_name text, inner_agg_collation_schema name, inner_agg_collation_name name, inner_agg_input_types name[], inner_agg_serialized_state bytea, return_type_dummy_val anyelement) owner to postgres;

